"use strict";
var dataStructureTyped = (() => {
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getOwnPropSymbols = Object.getOwnPropertySymbols;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __propIsEnum = Object.prototype.propertyIsEnumerable;
  var __knownSymbol = (name, symbol) => {
    if (symbol = Symbol[name])
      return symbol;
    throw Error("Symbol." + name + " is not defined");
  };
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __spreadValues = (a, b) => {
    for (var prop in b || (b = {}))
      if (__hasOwnProp.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    if (__getOwnPropSymbols)
      for (var prop of __getOwnPropSymbols(b)) {
        if (__propIsEnum.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      }
    return a;
  };
  var __export = (target, all) => {
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var __async = (__this, __arguments, generator) => {
    return new Promise((resolve, reject) => {
      var fulfilled = (value) => {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      };
      var rejected = (value) => {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      };
      var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
      step((generator = generator.apply(__this, __arguments)).next());
    });
  };
  var __await = function(promise, isYieldStar) {
    this[0] = promise;
    this[1] = isYieldStar;
  };
  var __yieldStar = (value) => {
    var obj = value[__knownSymbol("asyncIterator")];
    var isAwait = false;
    var method;
    var it = {};
    if (obj == null) {
      obj = value[__knownSymbol("iterator")]();
      method = (k) => it[k] = (x) => obj[k](x);
    } else {
      obj = obj.call(value);
      method = (k) => it[k] = (v) => {
        if (isAwait) {
          isAwait = false;
          if (k === "throw")
            throw v;
          return v;
        }
        isAwait = true;
        return {
          done: false,
          value: new __await(new Promise((resolve) => {
            var x = obj[k](v);
            if (!(x instanceof Object))
              throw TypeError("Object expected");
            resolve(x);
          }), 1)
        };
      };
    }
    return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
      throw x;
    }, "return" in obj && method("return"), it;
  };

  // src/index.ts
  var src_exports = {};
  __export(src_exports, {
    AVLTree: () => AVLTree,
    AVLTreeMultiMap: () => AVLTreeMultiMap,
    AVLTreeMultiMapNode: () => AVLTreeMultiMapNode,
    AVLTreeNode: () => AVLTreeNode,
    AbstractEdge: () => AbstractEdge,
    AbstractGraph: () => AbstractGraph,
    AbstractVertex: () => AbstractVertex,
    BST: () => BST,
    BSTNode: () => BSTNode,
    BinaryIndexedTree: () => BinaryIndexedTree,
    BinaryTree: () => BinaryTree,
    BinaryTreeNode: () => BinaryTreeNode,
    Character: () => Character,
    Deque: () => Deque,
    DirectedEdge: () => DirectedEdge,
    DirectedGraph: () => DirectedGraph,
    DirectedVertex: () => DirectedVertex,
    DoublyLinkedList: () => DoublyLinkedList,
    DoublyLinkedListNode: () => DoublyLinkedListNode,
    FibonacciHeap: () => FibonacciHeap,
    FibonacciHeapNode: () => FibonacciHeapNode,
    HashMap: () => HashMap,
    Heap: () => Heap,
    IterableElementBase: () => IterableElementBase,
    IterableEntryBase: () => IterableEntryBase,
    LinkedHashMap: () => LinkedHashMap,
    LinkedListQueue: () => LinkedListQueue,
    MapEdge: () => MapEdge,
    MapGraph: () => MapGraph,
    MapVertex: () => MapVertex,
    Matrix: () => Matrix,
    MaxHeap: () => MaxHeap,
    MaxPriorityQueue: () => MaxPriorityQueue,
    MinHeap: () => MinHeap,
    MinPriorityQueue: () => MinPriorityQueue,
    Navigator: () => Navigator,
    PriorityQueue: () => PriorityQueue,
    Queue: () => Queue,
    RedBlackTree: () => RedBlackTree,
    RedBlackTreeNode: () => RedBlackTreeNode,
    SegmentTree: () => SegmentTree,
    SegmentTreeNode: () => SegmentTreeNode,
    SinglyLinkedList: () => SinglyLinkedList,
    SinglyLinkedListNode: () => SinglyLinkedListNode,
    SkipList: () => SkipList,
    SkipListNode: () => SkipListNode,
    Stack: () => Stack,
    THUNK_SYMBOL: () => THUNK_SYMBOL,
    TreeMultiMap: () => TreeMultiMap,
    TreeMultiMapNode: () => TreeMultiMapNode,
    TreeNode: () => TreeNode,
    Trie: () => Trie,
    TrieNode: () => TrieNode,
    UndirectedEdge: () => UndirectedEdge,
    UndirectedGraph: () => UndirectedGraph,
    UndirectedVertex: () => UndirectedVertex,
    arrayRemove: () => arrayRemove,
    calcMinUnitsRequired: () => calcMinUnitsRequired,
    getMSB: () => getMSB,
    isComparable: () => isComparable,
    isThunk: () => isThunk,
    isWeakKey: () => isWeakKey,
    rangeCheck: () => rangeCheck,
    roundFixed: () => roundFixed,
    throwRangeError: () => throwRangeError,
    toBinaryString: () => toBinaryString,
    toThunk: () => toThunk,
    trampoline: () => trampoline,
    trampolineAsync: () => trampolineAsync,
    uuidV4: () => uuidV4
  });

  // src/data-structures/base/iterable-entry-base.ts
  var IterableEntryBase = class {
    // protected _toEntryFn?: (rawElement: R) => BTNEntry<K, V>;
    //
    // /**
    //  * The function returns the value of the _toEntryFn property.
    //  * @returns The function being returned is `this._toEntryFn`.
    //  */
    // get toEntryFn() {
    //   return this._toEntryFn;
    // }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function is an implementation of the Symbol.iterator method that returns an iterable iterator.
     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It
     * allows the function to accept any number of arguments as an array. In this case, the `args`
     * parameter is used to pass any additional arguments to the `_getIterator` method.
     */
    *[Symbol.iterator](...args) {
      yield* __yieldStar(this._getIterator(...args));
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields key-value pairs from the object, where the value can
     * be undefined.
     */
    *entries() {
      for (const item of this) {
        yield item;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields the keys of a data structure.
     */
    *keys() {
      for (const item of this) {
        yield item[0];
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields the values of a collection.
     */
    *values() {
      for (const item of this) {
        yield item[1];
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `every` function checks if every element in a collection satisfies a given condition.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is
     * met for the current element in the iteration.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the first argument to the `predicate` function. If `thisArg` is not provided
     * @returns The `every` method is returning a boolean value. It returns `true` if every element in
     * the collection satisfies the provided predicate function, and `false` otherwise.
     */
    every(predicate, thisArg) {
      let index = 0;
      for (const item of this) {
        if (!predicate.call(thisArg, item[1], item[0], index++, this)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The "some" function iterates over a collection and returns true if at least one element satisfies
     * a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `key`, and `index`. It should return a boolean value indicating whether the condition is
     * met for the current element in the iteration.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,
     * it will be passed as the first argument to the `predicate` function. If `thisArg` is
     * @returns a boolean value. It returns true if the predicate function returns true for any pair in
     * the collection, and false otherwise.
     */
    some(predicate, thisArg) {
      let index = 0;
      for (const item of this) {
        if (predicate.call(thisArg, item[1], item[0], index++, this)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `forEach` function iterates over each key-value pair in a collection and executes a callback
     * function for each pair.
     * @param callbackfn - The callback function that will be called for each element in the collection.
     * It takes four parameters: the value of the current element, the key of the current element, the
     * index of the current element, and the collection itself.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If `thisArg` is provided, it will be
     * used as the `this` value when calling the callback function. If `thisArg` is not provided, `
     */
    forEach(callbackfn, thisArg) {
      let index = 0;
      for (const item of this) {
        const [key, value] = item;
        callbackfn.call(thisArg, value, key, index++, this);
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `find` function iterates over the entries of a collection and returns the first value for
     * which the callback function returns true.
     * @param callbackfn - The callback function that will be called for each entry in the collection. It
     * takes three arguments: the value of the entry, the key of the entry, and the index of the entry in
     * the collection. It should return a boolean value indicating whether the current entry matches the
     * desired condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     * @returns The method `find` returns the value of the first element in the iterable that satisfies
     * the provided callback function. If no element satisfies the callback function, `undefined` is
     * returned.
     */
    find(callbackfn, thisArg) {
      let index = 0;
      for (const item of this) {
        const [key, value] = item;
        if (callbackfn.call(thisArg, value, key, index++, this))
          return item;
      }
      return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given key exists in a collection.
     * @param {K} key - The parameter "key" is of type K, which means it can be any type. It represents
     * the key that we want to check for existence in the data structure.
     * @returns a boolean value. It returns true if the key is found in the collection, and false
     * otherwise.
     */
    has(key) {
      for (const item of this) {
        const [itemKey] = item;
        if (itemKey === key)
          return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given value exists in a collection.
     * @param {V} value - The parameter "value" is the value that we want to check if it exists in the
     * collection.
     * @returns a boolean value, either true or false.
     */
    hasValue(value) {
      for (const [, elementValue] of this) {
        if (elementValue === value)
          return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `get` function retrieves the value associated with a given key from a collection.
     * @param {K} key - K (the type of the key) - This parameter represents the key that is being
     * searched for in the collection.
     * @returns The `get` method returns the value associated with the specified key if it exists in the
     * collection, otherwise it returns `undefined`.
     */
    get(key) {
      for (const item of this) {
        const [itemKey, value] = item;
        if (itemKey === key)
          return value;
      }
      return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reduce` function iterates over key-value pairs and applies a callback function to each pair,
     * accumulating a single value.
     * @param callbackfn - The callback function that will be called for each element in the collection.
     * It takes four arguments: the current accumulator value, the current value of the element, the key
     * of the element, and the index of the element in the collection. It should return the updated
     * accumulator value.
     * @param {U} initialValue - The `initialValue` parameter is the initial value of the accumulator. It
     * is the value that will be used as the first argument to the `callbackfn` function when reducing
     * the elements of the collection.
     * @returns The `reduce` method is returning the final value of the accumulator after iterating over
     * all the elements in the collection.
     */
    reduce(callbackfn, initialValue) {
      let accumulator = initialValue;
      let index = 0;
      for (const item of this) {
        const [key, value] = item;
        accumulator = callbackfn(accumulator, value, key, index++, this);
      }
      return accumulator;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The print function logs the elements of an array to the console.
     */
    print() {
      console.log([...this]);
    }
  };

  // src/data-structures/base/iterable-element-base.ts
  var IterableElementBase = class {
    /**
     * The protected constructor initializes the options for the IterableElementBase class, including the
     * toElementFn function.
     * @param [options] - An optional object that contains the following properties:
     */
    constructor(options) {
      __publicField(this, "_toElementFn");
      if (options) {
        const { toElementFn } = options;
        if (typeof toElementFn === "function")
          this._toElementFn = toElementFn;
        else if (toElementFn)
          throw new TypeError("toElementFn must be a function type");
      }
    }
    /**
     * The function returns the _toElementFn property, which is a function that converts a raw element to
     * a specific type.
     * @returns The function `get toElementFn()` is returning either a function that takes a raw element
     * `rawElement` of type `R` and returns an element `E`, or `undefined` if no function is assigned to
     * `_toElementFn`.
     */
    get toElementFn() {
      return this._toElementFn;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function is an implementation of the Symbol.iterator method that returns an IterableIterator.
     * @param {any[]} args - The `args` parameter in the code snippet represents a rest parameter. It
     * allows the function to accept any number of arguments as an array. In this case, the `args`
     * parameter is used to pass any number of arguments to the `_getIterator` method.
     */
    *[Symbol.iterator](...args) {
      yield* __yieldStar(this._getIterator(...args));
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function returns an iterator that yields all the values in the object.
     */
    *values() {
      for (const item of this) {
        yield item;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `every` function checks if every element in the array satisfies a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * the current element being processed, its index, and the array it belongs to. It should return a
     * boolean value indicating whether the element satisfies a certain condition or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `every` method is returning a boolean value. It returns `true` if every element in
     * the array satisfies the provided predicate function, and `false` otherwise.
     */
    every(predicate, thisArg) {
      let index = 0;
      for (const item of this) {
        if (!predicate.call(thisArg, item, index++, this)) {
          return false;
        }
      }
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The "some" function checks if at least one element in a collection satisfies a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `value`, `index`, and `array`. It should return a boolean value indicating whether the current
     * element satisfies the condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as the `this` value when executing the `predicate` function. If `thisArg` is provided,
     * it will be passed as the `this` value to the `predicate` function. If `thisArg
     * @returns a boolean value. It returns true if the predicate function returns true for any element
     * in the collection, and false otherwise.
     */
    some(predicate, thisArg) {
      let index = 0;
      for (const item of this) {
        if (predicate.call(thisArg, item, index++, this)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `forEach` function iterates over each element in an array-like object and calls a callback
     * function for each element.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes three arguments: the current element being processed, the index of the current
     * element, and the array that forEach was called upon.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     */
    forEach(callbackfn, thisArg) {
      let index = 0;
      for (const item of this) {
        callbackfn.call(thisArg, item, index++, this);
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `find` function iterates over the elements of an array-like object and returns the first
     * element that satisfies the provided callback function.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes three arguments: the current element being processed, the index of the current
     * element, and the array itself. The function should return a boolean value indicating whether the
     * current element matches the desired condition.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     * @returns The `find` method returns the first element in the array that satisfies the provided
     * callback function. If no element satisfies the callback function, `undefined` is returned.
     */
    find(callbackfn, thisArg) {
      let index = 0;
      for (const item of this) {
        if (callbackfn.call(thisArg, item, index++, this))
          return item;
      }
      return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function checks if a given element exists in a collection.
     * @param {E} element - The parameter "element" is of type E, which means it can be any type. It
     * represents the element that we want to check for existence in the collection.
     * @returns a boolean value. It returns true if the element is found in the collection, and false
     * otherwise.
     */
    has(element) {
      for (const ele of this) {
        if (ele === element)
          return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reduce` function iterates over the elements of an array-like object and applies a callback
     * function to reduce them into a single value.
     * @param callbackfn - The callbackfn parameter is a function that will be called for each element in
     * the array. It takes four arguments:
     * @param {U} initialValue - The initialValue parameter is the initial value of the accumulator. It
     * is the value that the accumulator starts with before the reduction operation begins.
     * @returns The `reduce` method is returning the final value of the accumulator after iterating over
     * all the elements in the array and applying the callback function to each element.
     */
    reduce(callbackfn, initialValue) {
      let accumulator = initialValue;
      let index = 0;
      for (const item of this) {
        accumulator = callbackfn(accumulator, item, index++, this);
      }
      return accumulator;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The print function logs the elements of an array to the console.
     */
    print() {
      console.log([...this]);
    }
  };

  // src/utils/utils.ts
  var uuidV4 = function() {
    return "xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx".replace(/[x]/g, function(c) {
      const r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  };
  var arrayRemove = function(array, predicate) {
    let i = -1, len = array ? array.length : 0;
    const result = [];
    while (++i < len) {
      const value = array[i];
      if (predicate(value, i, array)) {
        result.push(value);
        Array.prototype.splice.call(array, i--, 1);
        len--;
      }
    }
    return result;
  };
  var THUNK_SYMBOL = Symbol("thunk");
  var isThunk = (fnOrValue) => {
    return typeof fnOrValue === "function" && fnOrValue.__THUNK__ === THUNK_SYMBOL;
  };
  var toThunk = (fn) => {
    const thunk = () => fn();
    thunk.__THUNK__ = THUNK_SYMBOL;
    return thunk;
  };
  var trampoline = (fn) => {
    const cont = (...args) => toThunk(() => fn(...args));
    return Object.assign(
      (...args) => {
        let result = fn(...args);
        while (isThunk(result) && typeof result === "function") {
          result = result();
        }
        return result;
      },
      { cont }
    );
  };
  var trampolineAsync = (fn) => {
    const cont = (...args) => toThunk(() => fn(...args));
    return Object.assign(
      (...args) => __async(void 0, null, function* () {
        let result = yield fn(...args);
        while (isThunk(result) && typeof result === "function") {
          result = yield result();
        }
        return result;
      }),
      { cont }
    );
  };
  var getMSB = (value) => {
    if (value <= 0) {
      return 0;
    }
    return 1 << 31 - Math.clz32(value);
  };
  var rangeCheck = (index, min, max, message = "Index out of bounds.") => {
    if (index < min || index > max)
      throw new RangeError(message);
  };
  var throwRangeError = (message = "The value is off-limits.") => {
    throw new RangeError(message);
  };
  var isWeakKey = (input) => {
    const inputType = typeof input;
    return inputType === "object" && input !== null || inputType === "function";
  };
  var calcMinUnitsRequired = (totalQuantity, unitSize) => Math.floor((totalQuantity + unitSize - 1) / unitSize);
  var roundFixed = (num, digit = 10) => {
    const multiplier = Math.pow(10, digit);
    return Math.round(num * multiplier) / multiplier;
  };
  function isComparable(key) {
    const keyType = typeof key;
    if (keyType === "number")
      return !isNaN(key);
    if (keyType === "string")
      return true;
    if (keyType === "bigint")
      return true;
    if (keyType === "boolean")
      return true;
    if (keyType === "symbol")
      return false;
    if (keyType === "undefined")
      return false;
    if (keyType === "function")
      return isComparable(key());
    if (keyType === "object") {
      if (key === null)
        return true;
      return false;
    }
    return false;
  }

  // src/utils/number.ts
  function toBinaryString(num, digit = 32) {
    let binaryString = (num >>> 0).toString(2);
    binaryString = binaryString.padStart(digit, "0");
    return binaryString;
  }

  // src/data-structures/hash/hash-map.ts
  var HashMap = class _HashMap extends IterableEntryBase {
    /**
     * The constructor function initializes a HashMap object with an optional initial collection and
     * options.
     * @param entryOrRawElements - The `entryOrRawElements` parameter is an iterable collection of elements of a type
     * `T`. It is an optional parameter and its default value is an empty array `[]`.
     * @param [options] - The `options` parameter is an optional object that can contain two properties:
     */
    constructor(entryOrRawElements = [], options) {
      super();
      __publicField(this, "_store", {});
      __publicField(this, "_objMap", /* @__PURE__ */ new Map());
      __publicField(this, "_toEntryFn");
      __publicField(this, "_size", 0);
      __publicField(this, "_hashFn", (key) => String(key));
      if (options) {
        const { hashFn, toEntryFn } = options;
        if (hashFn) {
          this._hashFn = hashFn;
        }
        if (toEntryFn) {
          this._toEntryFn = toEntryFn;
        }
      }
      if (entryOrRawElements) {
        this.setMany(entryOrRawElements);
      }
    }
    /**
     * The function returns the store object, which is a dictionary of HashMapStoreItem objects.
     * @returns The store property is being returned. It is a dictionary-like object with string keys and
     * values of type HashMapStoreItem<K, V>.
     */
    get store() {
      return this._store;
    }
    /**
     * The function returns the object map.
     * @returns The `objMap` property is being returned, which is a `Map` object with keys of type
     * `object` and values of type `V`.
     */
    get objMap() {
      return this._objMap;
    }
    /**
     * The function returns the value of the _toEntryFn property.
     * @returns The function being returned is `this._toEntryFn`.
     */
    get toEntryFn() {
      return this._toEntryFn;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
      return this._size;
    }
    /**
     * The hasFn function is a function that takes in an item and returns a boolean
     * indicating whether the item is contained within the hash table.
     *
     * @return The hash function
     */
    get hashFn() {
      return this._hashFn;
    }
    /**
     * The function checks if a given element is an array with exactly two elements.
     * @param {any} rawElement - The `rawElement` parameter is of type `any`, which means it can be any
     * data type.
     * @returns a boolean value.
     */
    isEntry(rawElement) {
      return Array.isArray(rawElement) && rawElement.length === 2;
    }
    /**
     * The function checks if the size of an object is equal to zero and returns a boolean value.
     * @returns A boolean value indicating whether the size of the object is 0 or not.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * The clear() function resets the state of an object by clearing its internal store, object map, and
     * size.
     */
    clear() {
      this._store = {};
      this._objMap.clear();
      this._size = 0;
    }
    /**
     * The `set` function adds a key-value pair to a map-like data structure, incrementing the size if
     * the key is not already present.
     * @param {K} key - The key parameter is the key used to identify the value in the data structure. It
     * can be of any type, but if it is an object, it will be stored in a Map, otherwise it will be
     * stored in a regular JavaScript object.
     * @param {V} value - The value parameter represents the value that you want to associate with the
     * key in the data structure.
     */
    set(key, value) {
      if (this._isObjKey(key)) {
        if (!this.objMap.has(key)) {
          this._size++;
        }
        this.objMap.set(key, value);
      } else {
        const strKey = this._getNoObjKey(key);
        if (this.store[strKey] === void 0) {
          this._size++;
        }
        this._store[strKey] = { key, value };
      }
      return true;
    }
    /**
     * The function `setMany` takes an iterable collection of objects, maps each object to a key-value
     * pair using a mapping function, and sets each key-value pair in the current object.
     * @param entryOrRawElements - The `entryOrRawElements` parameter is an iterable collection of elements of a type
     * `T`.
     * @returns The `setMany` function is returning an array of booleans.
     */
    setMany(entryOrRawElements) {
      const results = [];
      for (const rawEle of entryOrRawElements) {
        let key, value;
        if (this.isEntry(rawEle)) {
          key = rawEle[0];
          value = rawEle[1];
        } else if (this.toEntryFn) {
          const item = this.toEntryFn(rawEle);
          key = item[0];
          value = item[1];
        }
        if (key !== void 0 && value !== void 0)
          results.push(this.set(key, value));
      }
      return results;
    }
    /**
     * The `get` function retrieves a value from a map based on a given key, either from an object map or
     * a string map.
     * @param {K} key - The `key` parameter is the key used to retrieve a value from the map. It can be
     * of any type, but it should be compatible with the key type used when the map was created.
     * @returns The method `get(key: K)` returns a value of type `V` if the key exists in the `_objMap`
     * or `_store`, otherwise it returns `undefined`.
     */
    get(key) {
      var _a;
      if (this._isObjKey(key)) {
        return this.objMap.get(key);
      } else {
        const strKey = this._getNoObjKey(key);
        return (_a = this._store[strKey]) == null ? void 0 : _a.value;
      }
    }
    /**
     * The `has` function checks if a given key exists in the `_objMap` or `_store` based on whether it
     * is an object key or not.
     * @param {K} key - The parameter "key" is of type K, which means it can be any type.
     * @returns The `has` method is returning a boolean value.
     */
    has(key) {
      if (this._isObjKey(key)) {
        return this.objMap.has(key);
      } else {
        const strKey = this._getNoObjKey(key);
        return strKey in this.store;
      }
    }
    /**
     * The `delete` function removes an element from a map-like data structure based on the provided key.
     * @param {K} key - The `key` parameter is the key of the element that you want to delete from the
     * data structure.
     * @returns The `delete` method returns a boolean value. It returns `true` if the key was
     * successfully deleted from the map, and `false` if the key was not found in the map.
     */
    delete(key) {
      if (this._isObjKey(key)) {
        if (this.objMap.has(key)) {
          this._size--;
        }
        return this.objMap.delete(key);
      } else {
        const strKey = this._getNoObjKey(key);
        if (strKey in this.store) {
          delete this.store[strKey];
          this._size--;
          return true;
        }
        return false;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The clone function creates a new HashMap with the same key-value pairs as
     * this one. The clone function is useful for creating a copy of an existing
     * HashMap, and then modifying that copy without affecting the original.
     *
     * @return A new hashmap with the same values as this one
     */
    clone() {
      return new _HashMap(this, { hashFn: this.hashFn, toEntryFn: this.toEntryFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function in TypeScript creates a new HashMap by applying a callback function to each
     * key-value pair in the original HashMap.
     * @param callbackfn - The callback function that will be called for each key-value pair in the
     * HashMap. It takes four parameters:
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callbackfn` function. If `thisArg` is provided, it will
     * be passed as the `this` value to the `callbackfn` function. If `thisArg
     * @returns The `map` method is returning a new `HashMap` object with the transformed values based on
     * the provided callback function.
     */
    map(callbackfn, thisArg) {
      const resultMap = new _HashMap();
      let index = 0;
      for (const [key, value] of this) {
        resultMap.set(key, callbackfn.call(thisArg, value, key, index++, this));
      }
      return resultMap;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new HashMap containing key-value pairs from the original HashMap
     * that satisfy a given predicate function.
     * @param predicate - The predicate parameter is a function that takes four arguments: value, key,
     * index, and map. It is used to determine whether an element should be included in the filtered map
     * or not. The function should return a boolean value - true if the element should be included, and
     * false otherwise.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `filter` method is returning a new `HashMap` object that contains the key-value pairs
     * from the original `HashMap` that pass the provided `predicate` function.
     */
    filter(predicate, thisArg) {
      const filteredMap = new _HashMap();
      let index = 0;
      for (const [key, value] of this) {
        if (predicate.call(thisArg, value, key, index++, this)) {
          filteredMap.set(key, value);
        }
      }
      return filteredMap;
    }
    /**
     * The put function sets a value in a data structure using a specified key.
     * @param {K} key - The key parameter is of type K, which represents the type of the key being passed
     * to the function.
     * @param {V} value - The value parameter represents the value that you want to associate with the
     * specified key in the data structure.
     * @returns The method is returning a boolean value.
     */
    put(key, value) {
      return this.set(key, value);
    }
    /**
     * The function returns an iterator that yields key-value pairs from both an object store and an
     * object map.
     */
    *_getIterator() {
      for (const node of Object.values(this.store)) {
        yield [node.key, node.value];
      }
      for (const node of this.objMap) {
        yield node;
      }
    }
    /**
     * The function checks if a given key is an object or a function.
     * @param {any} key - The parameter "key" can be of any type.
     * @returns a boolean value.
     */
    _isObjKey(key) {
      const keyType = typeof key;
      return (keyType === "object" || keyType === "function") && key !== null;
    }
    /**
     * The function `_getNoObjKey` takes a key and returns a string representation of the key, handling
     * different types of keys.
     * @param {K} key - The `key` parameter is of type `K`, which represents the type of the key being
     * passed to the `_getNoObjKey` function.
     * @returns a string value.
     */
    _getNoObjKey(key) {
      const keyType = typeof key;
      let strKey;
      if (keyType !== "string" && keyType !== "number" && keyType !== "symbol") {
        strKey = this.hashFn(key);
      } else {
        if (keyType === "number") {
          strKey = key;
        } else {
          strKey = key;
        }
      }
      return strKey;
    }
  };
  var LinkedHashMap = class _LinkedHashMap extends IterableEntryBase {
    /**
     * The constructor initializes a LinkedHashMap object with an optional raw collection and options.
     * @param entryOrRawElements - The `entryOrRawElements` parameter is an iterable collection of elements. It is
     * used to initialize the HashMapLinked instance with key-value pairs. Each element in the
     * `entryOrRawElements` is converted to a key-value pair using the `toEntryFn` function (if provided) and
     * then added to the HashMap
     * @param [options] - The `options` parameter is an optional object that can contain the following
     * properties:
     */
    constructor(entryOrRawElements = [], options) {
      super();
      __publicField(this, "_sentinel");
      __publicField(this, "_hashFn", (key) => String(key));
      __publicField(this, "_objHashFn", (key) => key);
      __publicField(this, "_noObjMap", {});
      __publicField(this, "_objMap", /* @__PURE__ */ new WeakMap());
      __publicField(this, "_head");
      __publicField(this, "_tail");
      __publicField(this, "_toEntryFn", (rawElement) => {
        if (this.isEntry(rawElement)) {
          return rawElement;
        } else {
          throw new Error(
            "If the provided entryOrRawElements does not adhere to the [key, value] type format, the toEntryFn in the constructor's options parameter needs to specified."
          );
        }
      });
      __publicField(this, "_size", 0);
      this._sentinel = {};
      this._sentinel.prev = this._sentinel.next = this._head = this._tail = this._sentinel;
      if (options) {
        const { hashFn, objHashFn, toEntryFn } = options;
        if (hashFn)
          this._hashFn = hashFn;
        if (objHashFn)
          this._objHashFn = objHashFn;
        if (toEntryFn) {
          this._toEntryFn = toEntryFn;
        }
      }
      if (entryOrRawElements) {
        for (const el of entryOrRawElements) {
          const [key, value] = this.toEntryFn(el);
          this.set(key, value);
        }
      }
    }
    /**
     * The function returns the hash function used for generating a hash value for a given key.
     * @returns The hash function that takes a key of type K and returns a string.
     */
    get hashFn() {
      return this._hashFn;
    }
    /**
     * The function returns the object hash function.
     * @returns The function `objHashFn` is being returned.
     */
    get objHashFn() {
      return this._objHashFn;
    }
    /**
     * The function returns a record of HashMapLinkedNode objects with string keys.
     * @returns The method is returning a Record object, which is a TypeScript type that represents an
     * object with string keys and values that are HashMapLinkedNode objects with keys of type K and
     * values of type V or undefined.
     */
    get noObjMap() {
      return this._noObjMap;
    }
    /**
     * The function returns the WeakMap object used to map objects to HashMapLinkedNode instances.
     * @returns The `objMap` property is being returned.
     */
    get objMap() {
      return this._objMap;
    }
    /**
     * The function returns the head node of a HashMapLinkedNode.
     * @returns The method `getHead()` is returning a `HashMapLinkedNode` object with key type `K` and
     * a value type `V | undefined`.
     */
    get head() {
      return this._head;
    }
    /**
     * The function returns the tail node of a HashMapLinkedNode.
     * @returns The `_tail` property of type `HashMapLinkedNode<K, V | undefined>` is being returned.
     */
    get tail() {
      return this._tail;
    }
    /**
     * The function returns the value of the _toEntryFn property.
     * @returns The function being returned is `this._toEntryFn`.
     */
    get toEntryFn() {
      return this._toEntryFn;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object.
     */
    get size() {
      return this._size;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function returns the key-value pair at the front of a data structure.
     * @returns The front element of the data structure, represented as a tuple with a key (K) and a
     * value (V).
     */
    get first() {
      if (this._size === 0)
        return;
      return [this.head.key, this.head.value];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function returns the key-value pair at the end of a data structure.
     * @returns The method is returning an array containing the key-value pair of the tail element in the
     * data structure.
     */
    get last() {
      if (this._size === 0)
        return;
      return [this.tail.key, this.tail.value];
    }
    /**
     * The `begin()` function in TypeScript iterates over a linked list and yields key-value pairs.
     */
    *begin() {
      let node = this.head;
      while (node !== this._sentinel) {
        yield [node.key, node.value];
        node = node.next;
      }
    }
    /**
     * The function `reverseBegin()` iterates over a linked list in reverse order, yielding each node's
     * key and value.
     */
    *reverseBegin() {
      let node = this.tail;
      while (node !== this._sentinel) {
        yield [node.key, node.value];
        node = node.prev;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `set` function adds a new key-value pair to a data structure, either using an object key or a
     * string key.
     * @param {K} key - The `key` parameter is the key to be set in the data structure. It can be of any
     * type, but typically it is a string or symbol.
     * @param {V} [value] - The `value` parameter is an optional parameter of type `V`. It represents the
     * value associated with the key being set in the data structure.
     * @returns the size of the data structure after the key-value pair has been set.
     */
    set(key, value) {
      let node;
      const isNewKey = !this.has(key);
      if (isWeakKey(key)) {
        const hash = this.objHashFn(key);
        node = this.objMap.get(hash);
        if (!node && isNewKey) {
          node = { key: hash, value, prev: this.tail, next: this._sentinel };
          this.objMap.set(hash, node);
        } else if (node) {
          node.value = value;
        }
      } else {
        const hash = this.hashFn(key);
        node = this.noObjMap[hash];
        if (!node && isNewKey) {
          this.noObjMap[hash] = node = { key, value, prev: this.tail, next: this._sentinel };
        } else if (node) {
          node.value = value;
        }
      }
      if (node && isNewKey) {
        if (this._size === 0) {
          this._head = node;
          this._sentinel.next = node;
        } else {
          this.tail.next = node;
          node.prev = this.tail;
        }
        this._tail = node;
        this._sentinel.prev = node;
        this._size++;
      }
      return true;
    }
    /**
     * The function `setMany` takes an iterable collection, converts each element into a key-value pair
     * using a provided function, and sets each key-value pair in the current object, returning an array
     * of booleans indicating the success of each set operation.
     * @param entryOrRawElements - The entryOrRawElements parameter is an iterable collection of elements of type
     * R.
     * @returns The `setMany` function returns an array of booleans.
     */
    setMany(entryOrRawElements) {
      const results = [];
      for (const rawEle of entryOrRawElements) {
        const [key, value] = this.toEntryFn(rawEle);
        results.push(this.set(key, value));
      }
      return results;
    }
    /**
     * The function checks if a given key exists in a map, using different logic depending on whether the
     * key is a weak key or not.
     * @param {K} key - The `key` parameter is the key that is being checked for existence in the map.
     * @returns The method `has` is returning a boolean value.
     */
    has(key) {
      if (isWeakKey(key)) {
        const hash = this.objHashFn(key);
        return this.objMap.has(hash);
      } else {
        const hash = this.hashFn(key);
        return hash in this.noObjMap;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `get` retrieves the value associated with a given key from a map, either by using the
     * key directly or by using an index stored in the key object.
     * @param {K} key - The `key` parameter is the key used to retrieve a value from the map. It can be
     * of any type, but typically it is a string or symbol.
     * @returns The value associated with the given key is being returned. If the key is an object key,
     * the value is retrieved from the `_nodes` array using the index stored in the `OBJ_KEY_INDEX`
     * property of the key. If the key is a string key, the value is retrieved from the `_noObjMap` object
     * using the key itself. If the key is not found, `undefined` is
     */
    get(key) {
      if (isWeakKey(key)) {
        const hash = this.objHashFn(key);
        const node = this.objMap.get(hash);
        return node ? node.value : void 0;
      } else {
        const hash = this.hashFn(key);
        const node = this.noObjMap[hash];
        return node ? node.value : void 0;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `at` retrieves the key-value pair at a specified index in a linked list.
     * @param {number} index - The index parameter is a number that represents the position of the
     * element we want to retrieve from the data structure.
     * @returns The method `at(index: number)` is returning an array containing the key-value pair at
     * the specified index in the data structure. The key-value pair is represented as a tuple `[K, V]`,
     * where `K` is the key and `V` is the value.
     */
    at(index) {
      rangeCheck(index, 0, this._size - 1);
      let node = this.head;
      while (index--) {
        node = node.next;
      }
      return node.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a key-value pair from a map-like data structure.
     * @param {K} key - The `key` parameter is the key that you want to delete from the data structure.
     * It can be of any type, but typically it is a string or an object.
     * @returns a boolean value. It returns `true` if the deletion was successful, and `false` if the key
     * was not found.
     */
    delete(key) {
      let node;
      if (isWeakKey(key)) {
        const hash = this.objHashFn(key);
        node = this.objMap.get(hash);
        if (!node) {
          return false;
        }
        this.objMap.delete(hash);
      } else {
        const hash = this.hashFn(key);
        node = this.noObjMap[hash];
        if (!node) {
          return false;
        }
        delete this.noObjMap[hash];
      }
      this._deleteNode(node);
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `deleteAt` function deletes a node at a specified index in a linked list.
     * @param {number} index - The index parameter represents the position at which the node should be
     * deleted in the linked list.
     * @returns The size of the list after deleting the element at the specified index.
     */
    deleteAt(index) {
      rangeCheck(index, 0, this._size - 1);
      let node = this.head;
      while (index--) {
        node = node.next;
      }
      return this._deleteNode(node);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if a data structure is empty by comparing its size to zero.
     * @returns The method is returning a boolean value indicating whether the size of the object is 0 or
     * not.
     */
    isEmpty() {
      return this._size === 0;
    }
    /**
     * The function checks if a given element is an array with exactly two elements.
     * @param {any} rawElement - The `rawElement` parameter is of type `any`, which means it can be any
     * data type.
     * @returns a boolean value.
     */
    isEntry(rawElement) {
      return Array.isArray(rawElement) && rawElement.length === 2;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `clear` function clears all the entries in a data structure and resets its properties.
     */
    clear() {
      this._noObjMap = {};
      this._size = 0;
      this._head = this._tail = this._sentinel.prev = this._sentinel.next = this._sentinel;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function creates a new instance of a `LinkedHashMap` with the same key-value pairs as
     * the original.
     * @returns The `clone()` method is returning a new instance of `LinkedHashMap<K, V>` that is a clone
     * of the original `LinkedHashMap` object.
     */
    clone() {
      const cloned = new _LinkedHashMap([], { hashFn: this.hashFn, objHashFn: this.objHashFn });
      for (const entry of this) {
        const [key, value] = entry;
        cloned.set(key, value);
      }
      return cloned;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new `LinkedHashMap` containing key-value pairs from the original
     * map that satisfy a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that takes four arguments:
     * `value`, `key`, `index`, and `this`. It should return a boolean value indicating whether the
     * current element should be included in the filtered map or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. It is used when you want to bind a
     * specific object as the context for the `predicate` function. If `thisArg` is not provided, `this
     * @returns a new `LinkedHashMap` object that contains the key-value pairs from the original
     * `LinkedHashMap` object that satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
      const filteredMap = new _LinkedHashMap();
      let index = 0;
      for (const [key, value] of this) {
        if (predicate.call(thisArg, value, key, index, this)) {
          filteredMap.set(key, value);
        }
        index++;
      }
      return filteredMap;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function in TypeScript creates a new `LinkedHashMap` by applying a callback function to
     * each key-value pair in the original map.
     * @param callback - The callback parameter is a function that will be called for each key-value pair
     * in the map. It takes four arguments: the value of the current key-value pair, the key of the
     * current key-value pair, the index of the current key-value pair, and the map itself. The callback
     * function should
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If provided, the callback function will
     * be called with `thisArg` as its `this` value. If not provided, `this` will refer to the current
     * map
     * @returns a new `LinkedHashMap` object with the values mapped according to the provided callback
     * function.
     */
    map(callback, thisArg) {
      const mappedMap = new _LinkedHashMap();
      let index = 0;
      for (const [key, value] of this) {
        const newValue = callback.call(thisArg, value, key, index, this);
        mappedMap.set(key, newValue);
        index++;
      }
      return mappedMap;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The put function sets a value in a data structure using a specified key.
     * @param {K} key - The key parameter is of type K, which represents the type of the key being passed
     * to the function.
     * @param {V} value - The value parameter represents the value that you want to associate with the
     * specified key in the data structure.
     * @returns The method is returning a boolean value.
     */
    put(key, value) {
      return this.set(key, value);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * where n is the number of entries in the LinkedHashMap.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * where n is the number of entries in the LinkedHashMap.
     *
     * The above function is an iterator that yields key-value pairs from a linked list.
     */
    *_getIterator() {
      let node = this.head;
      while (node !== this._sentinel) {
        yield [node.key, node.value];
        node = node.next;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_deleteNode` function removes a node from a doubly linked list and updates the head and tail
     * pointers if necessary.
     * @param node - The `node` parameter is an instance of the `HashMapLinkedNode` class, which
     * represents a node in a linked list. It contains a key-value pair and references to the previous
     * and next nodes in the list.
     */
    _deleteNode(node) {
      const { prev, next } = node;
      prev.next = next;
      next.prev = prev;
      if (node === this.head) {
        this._head = next;
      }
      if (node === this.tail) {
        this._tail = prev;
      }
      this._size -= 1;
      return true;
    }
  };

  // src/data-structures/linked-list/singly-linked-list.ts
  var SinglyLinkedListNode = class {
    /**
     * The constructor function initializes an instance of a class with a given value and sets the next property to undefined.
     * @param {E} value - The "value" parameter is of type E, which means it can be any data type. It represents the value that
     * will be stored in the node of a linked list.
     */
    constructor(value) {
      __publicField(this, "_value");
      __publicField(this, "_next");
      this._value = value;
      this._next = void 0;
    }
    /**
     * The function returns the value of a protected variable.
     * @returns The value of the variable `_value` is being returned.
     */
    get value() {
      return this._value;
    }
    /**
     * The above function sets the value of a variable.
     * @param {E} value - The parameter "value" is of type E, which means it can be any type.
     */
    set value(value) {
      this._value = value;
    }
    /**
     * The `next` function returns the next node in a singly linked list.
     * @returns The `next` property is being returned. It can be either a `SinglyLinkedListNode<E>`
     * object or `undefined`.
     */
    get next() {
      return this._next;
    }
    /**
     * The "next" property of a SinglyLinkedListNode is set to the provided value.
     * @param {SinglyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `SinglyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `SinglyLinkedListNode` object or `undefined` as its value.
     */
    set next(value) {
      this._next = value;
    }
  };
  var SinglyLinkedList = class _SinglyLinkedList extends IterableElementBase {
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_head");
      __publicField(this, "_tail");
      __publicField(this, "_size", 0);
      if (elements) {
        for (const el of elements) {
          if (this.toElementFn) {
            this.push(this.toElementFn(el));
          } else {
            this.push(el);
          }
        }
      }
    }
    /**
     * The `head` function returns the first node of a singly linked list.
     * @returns The method is returning either a SinglyLinkedListNode object or undefined.
     */
    get head() {
      return this._head;
    }
    /**
     * The `tail` function returns the last node of a singly linked list.
     * @returns The method is returning either a SinglyLinkedListNode object or undefined.
     */
    get tail() {
      return this._tail;
    }
    /**
     * The above function returns the value of the first element in a linked list, or undefined if the
     * list is empty.
     * @returns The value of the first node in the linked list, or undefined if the linked list is empty.
     */
    get first() {
      var _a;
      return (_a = this.head) == null ? void 0 : _a.value;
    }
    /**
     * The function returns the value of the last element in a linked list, or undefined if the list is
     * empty.
     * @returns The value of the last node in the linked list, or undefined if the linked list is empty.
     */
    get last() {
      var _a;
      return (_a = this.tail) == null ? void 0 : _a.value;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
      return this._size;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * Linear time, where n is the length of the input array, as it performs a loop to push each element into the linked list.
     * Linear space, as it creates a new node for each element in the array.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `fromArray` function creates a new SinglyLinkedList instance and populates it with the elements from the given
     * array.
     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.
     * @returns The `fromArray` function returns a `SinglyLinkedList` object.
     */
    static fromArray(data) {
      const singlyLinkedList = new _SinglyLinkedList();
      for (const item of data) {
        singlyLinkedList.push(item);
      }
      return singlyLinkedList;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The push function adds a new element to the end of a singly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the linked list.
     * @returns The `push` method is returning a boolean value, `true`.
     */
    push(element) {
      const newNode = new SinglyLinkedListNode(element);
      if (!this.head) {
        this._head = newNode;
        this._tail = newNode;
      } else {
        this.tail.next = newNode;
        this._tail = newNode;
      }
      this._size++;
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     * Linear time in the worst case, as it may need to traverse the list to find the last element.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `pop` function removes and returns the value of the last element in a linked list.
     * @returns The method is returning the value of the element that is being popped from the end of the
     * list.
     */
    pop() {
      if (!this.head)
        return void 0;
      if (this.head === this.tail) {
        const value2 = this.head.value;
        this._head = void 0;
        this._tail = void 0;
        this._size--;
        return value2;
      }
      let current = this.head;
      while (current.next !== this.tail) {
        current = current.next;
      }
      const value = this.tail.value;
      current.next = void 0;
      this._tail = current;
      this._size--;
      return value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `shift()` function removes and returns the value of the first element in a linked list.
     * @returns The value of the removed node.
     */
    shift() {
      if (!this.head)
        return void 0;
      const removedNode = this.head;
      this._head = this.head.next;
      this._size--;
      return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The unshift function adds a new element to the beginning of a singly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the beginning of the singly linked list.
     * @returns The `unshift` method is returning a boolean value, `true`.
     */
    unshift(element) {
      const newNode = new SinglyLinkedListNode(element);
      if (!this.head) {
        this._head = newNode;
        this._tail = newNode;
      } else {
        newNode.next = this.head;
        this._head = newNode;
      }
      this._size++;
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `at` returns the value at a specified index in a linked list, or undefined if the index is out of range.
     * @param {number} index - The index parameter is a number that represents the position of the element we want to
     * retrieve from the list.
     * @returns The method `at(index: number): E | undefined` returns the value at the specified index in the linked list, or
     * `undefined` if the index is out of bounds.
     */
    at(index) {
      if (index < 0 || index >= this.size)
        return void 0;
      let current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
      return current.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `getNodeAt` returns the node at a given index in a singly linked list.
     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to
     * retrieve from the linked list. It indicates the zero-based index of the node we want to access.
     * @returns The method `getNodeAt(index: number)` returns a `SinglyLinkedListNode<E>` object if the node at the
     * specified index exists, or `undefined` if the index is out of bounds.
     */
    getNodeAt(index) {
      let current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
      return current;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.
     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the
     * data structure. It is of type number.
     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of
     * bounds.
     */
    deleteAt(index) {
      if (index < 0 || index >= this.size)
        return false;
      if (index === 0) {
        this.shift();
        return true;
      }
      if (index === this.size - 1) {
        this.pop();
        return true;
      }
      const prevNode = this.getNodeAt(index - 1);
      const removedNode = prevNode.next;
      prevNode.next = removedNode.next;
      this._size--;
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The delete function removes a node with a specific value from a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} valueOrNode - The `valueOrNode` parameter can accept either a value of type `E`
     * or a `SinglyLinkedListNode<E>` object.
     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node is found and
     * successfully deleted from the linked list, and `false` if the value or node is not found in the linked list.
     */
    delete(valueOrNode) {
      if (!valueOrNode)
        return false;
      let value;
      if (valueOrNode instanceof SinglyLinkedListNode) {
        value = valueOrNode.value;
      } else {
        value = valueOrNode;
      }
      let current = this.head, prev = void 0;
      while (current) {
        if (current.value === value) {
          if (prev === void 0) {
            this._head = current.next;
            if (current === this.tail) {
              this._tail = void 0;
            }
          } else {
            prev.next = current.next;
            if (current === this.tail) {
              this._tail = prev;
            }
          }
          this._size--;
          return true;
        }
        prev = current;
        current = current.next;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addAt` function inserts a value at a specified index in a singly linked list.
     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the
     * linked list. It is of type number.
     * @param {E} value - The `value` parameter represents the value that you want to insert into the linked list at the
     * specified index.
     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`
     * if the index is out of bounds.
     */
    addAt(index, value) {
      if (index < 0 || index > this.size)
        return false;
      if (index === 0) {
        this.unshift(value);
        return true;
      }
      if (index === this.size) {
        this.push(value);
        return true;
      }
      const newNode = new SinglyLinkedListNode(value);
      const prevNode = this.getNodeAt(index - 1);
      newNode.next = prevNode.next;
      prevNode.next = newNode;
      this._size++;
      return true;
    }
    /**
     * The function checks if the length of a data structure is equal to zero and returns a boolean value indicating
     * whether it is empty or not.
     * @returns A boolean value indicating whether the length of the object is equal to 0.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * The `clear` function resets the linked list by setting the head, tail, and length to undefined and 0 respectively.
     */
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * Linear time, where n is the length of the list, as it needs to traverse the entire list to convert it to an array.
     * Linear space, as it creates an array with the same length as the list.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toArray` function converts a linked list into an array.
     * @returns The `toArray()` method is returning an array of type `E[]`.
     */
    toArray() {
      const array = [];
      let current = this.head;
      while (current) {
        array.push(current.value);
        current = current.next;
      }
      return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reverse` function reverses the order of the nodes in a singly linked list.
     * @returns The reverse() method does not return anything. It has a return type of void.
     */
    reverse() {
      if (!this.head || this.head === this.tail)
        return this;
      let prev = void 0;
      let current = this.head;
      let next = void 0;
      while (current) {
        next = current.next;
        current.next = prev;
        prev = current;
        current = next;
      }
      [this._head, this._tail] = [this.tail, this.head];
      return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `indexOf` function returns the index of the first occurrence of a given value in a linked list.
     * @param {E} value - The value parameter is the value that you want to find the index of in the linked list.
     * @returns The method is returning the index of the first occurrence of the specified value in the linked list. If the
     * value is not found, it returns -1.
     */
    indexOf(value) {
      let index = 0;
      let current = this.head;
      while (current) {
        if (current.value === value) {
          return index;
        }
        index++;
        current = current.next;
      }
      return -1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function finds a node in a singly linked list by its value and returns the node if found, otherwise returns
     * undefined.
     * @param {E} value - The value parameter is the value that we want to search for in the linked list.
     * @returns a `SinglyLinkedListNode<E>` if a node with the specified value is found in the linked list. If no node with
     * the specified value is found, the function returns `undefined`.
     */
    getNode(value) {
      let current = this.head;
      while (current) {
        if (current.value === value) {
          return current;
        }
        current = current.next;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addBefore` function inserts a new value before an existing value in a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node that you want to insert the
     * new value before. It can be either the value itself or a node containing the value in the linked list.
     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the linked list.
     * @returns The method `addBefore` returns a boolean value. It returns `true` if the new value was successfully
     * inserted before the existing value, and `false` otherwise.
     */
    addBefore(existingValueOrNode, newValue) {
      if (!this.head)
        return false;
      let existingValue;
      if (existingValueOrNode instanceof SinglyLinkedListNode) {
        existingValue = existingValueOrNode.value;
      } else {
        existingValue = existingValueOrNode;
      }
      if (this.head.value === existingValue) {
        this.unshift(newValue);
        return true;
      }
      let current = this.head;
      while (current.next) {
        if (current.next.value === existingValue) {
          const newNode = new SinglyLinkedListNode(newValue);
          newNode.next = current.next;
          current.next = newNode;
          this._size++;
          return true;
        }
        current = current.next;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `addAfter` function inserts a new node with a given value after an existing node in a singly linked list.
     * @param {E | SinglyLinkedListNode<E>} existingValueOrNode - The existing value or node in the linked list after which
     * the new value will be inserted. It can be either the value of the existing node or the existing node itself.
     * @param {E} newValue - The value that you want to insert into the linked list after the existing value or node.
     * @returns The method returns a boolean value. It returns true if the new value was successfully inserted after the
     * existing value or node, and false if the existing value or node was not found in the linked list.
     */
    addAfter(existingValueOrNode, newValue) {
      let existingNode;
      if (existingValueOrNode instanceof SinglyLinkedListNode) {
        existingNode = existingValueOrNode;
      } else {
        existingNode = this.getNode(existingValueOrNode);
      }
      if (existingNode) {
        const newNode = new SinglyLinkedListNode(newValue);
        newNode.next = existingNode.next;
        existingNode.next = newNode;
        if (existingNode === this.tail) {
          this._tail = newNode;
        }
        this._size++;
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function counts the number of occurrences of a given value in a linked list.
     * @param {E} value - The value parameter is the value that you want to count the occurrences of in the linked list.
     * @returns The count of occurrences of the given value in the linked list.
     */
    countOccurrences(value) {
      let count = 0;
      let current = this.head;
      while (current) {
        if (current.value === value) {
          count++;
        }
        current = current.next;
      }
      return count;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function returns a new instance of the `SinglyLinkedList` class with the same values
     * as the original list.
     * @returns The `clone()` method is returning a new instance of the `SinglyLinkedList` class, which
     * is a clone of the original list.
     */
    clone() {
      return new _SinglyLinkedList(this, { toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new SinglyLinkedList by iterating over the elements of the current
     * list and applying a callback function to each element to determine if it should be included in the
     * filtered list.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * list. It takes three arguments: the current element, the index of the current element, and the
     * list itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list or not
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `SinglyLinkedList` object that contains the
     * elements that pass the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredList = new _SinglyLinkedList([], { toElementFn: this.toElementFn });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredList.push(current);
        }
        index++;
      }
      return filteredList;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and returns a new SinglyLinkedList with the results
     * of applying the callback to each element in the original list.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the original list. It takes three arguments: `current` (the current element being processed),
     * `index` (the index of the current element), and `this` (the original list). It should return a
     * value
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as
     * input and returns the converted element. If this parameter is not provided, the raw element will
     * be used as is.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `SinglyLinkedList` class with the mapped elements.
     */
    map(callback, toElementFn, thisArg) {
      const mappedList = new _SinglyLinkedList([], { toElementFn });
      let index = 0;
      for (const current of this) {
        mappedList.push(callback.call(thisArg, current, index, this));
        index++;
      }
      return mappedList;
    }
    /**
     * The function `_getIterator` returns an iterable iterator that yields the values of a linked list.
     */
    *_getIterator() {
      let current = this.head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };

  // src/data-structures/linked-list/doubly-linked-list.ts
  var DoublyLinkedListNode = class {
    /**
     * The constructor function initializes the value, next, and previous properties of an object.
     * @param {E} value - The "value" parameter is the value that will be stored in the node. It can be of any data type, as it
     * is defined as a generic type "E".
     */
    constructor(value) {
      __publicField(this, "_value");
      __publicField(this, "_next");
      __publicField(this, "_prev");
      this._value = value;
      this._next = void 0;
      this._prev = void 0;
    }
    /**
     * The function returns the value of a protected variable.
     * @returns The value of the variable `_value` is being returned.
     */
    get value() {
      return this._value;
    }
    /**
     * The above function sets the value of a variable.
     * @param {E} value - The parameter "value" is of type E, which means it can be any type.
     */
    set value(value) {
      this._value = value;
    }
    /**
     * The "next" function returns the next node in a doubly linked list.
     * @returns The `next` property is being returned. It can be either a `DoublyLinkedListNode<E>`
     * object or `undefined`.
     */
    get next() {
      return this._next;
    }
    /**
     * The "next" property of a DoublyLinkedListNode is set to the provided value.
     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `DoublyLinkedListNode` object or `undefined` as its value.
     */
    set next(value) {
      this._next = value;
    }
    /**
     * The `prev` function returns the previous node in a doubly linked list.
     * @returns The `prev` property of the `DoublyLinkedListNode` class is being returned. It can either
     * be a `DoublyLinkedListNode` object or `undefined`.
     */
    get prev() {
      return this._prev;
    }
    /**
     * The function sets the previous node of a doubly linked list node.
     * @param {DoublyLinkedListNode<E> | undefined} value - The `value` parameter is of type
     * `DoublyLinkedListNode<E> | undefined`. This means that it can accept either a
     * `DoublyLinkedListNode` object or `undefined` as its value.
     */
    set prev(value) {
      this._prev = value;
    }
  };
  var DoublyLinkedList = class _DoublyLinkedList extends IterableElementBase {
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_head");
      __publicField(this, "_tail");
      __publicField(this, "_size");
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
      if (elements) {
        for (const el of elements) {
          if (this.toElementFn) {
            this.push(this.toElementFn(el));
          } else
            this.push(el);
        }
      }
    }
    /**
     * The `head` function returns the first node of a doubly linked list.
     * @returns The method `getHead()` returns either a `DoublyLinkedListNode<E>` object or `undefined`.
     */
    get head() {
      return this._head;
    }
    /**
     * The `tail` function returns the last node of a doubly linked list.
     * @returns The `get tail()` method is returning either a `DoublyLinkedListNode<E>` object or
     * `undefined`.
     */
    get tail() {
      return this._tail;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
      return this._size;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     * where n is the number of elements in the linked list.
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `get first` function returns the first node in a doubly linked list, or undefined if the list is empty.
     * @returns The method `get first()` returns the first node of the doubly linked list, or `undefined` if the list is empty.
     */
    get first() {
      var _a;
      return (_a = this.head) == null ? void 0 : _a.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `get last` function returns the last node in a doubly linked list, or undefined if the list is empty.
     * @returns The method `get last()` returns the last node of the doubly linked list, or `undefined` if the list is empty.
     */
    get last() {
      var _a;
      return (_a = this.tail) == null ? void 0 : _a.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `fromArray` function creates a new instance of a DoublyLinkedList and populates it with the elements from the
     * given array.
     * @param {E[]} data - The `data` parameter is an array of elements of type `E`.
     * @returns The `fromArray` function returns a DoublyLinkedList object.
     */
    static fromArray(data) {
      return new _DoublyLinkedList(data);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The push function adds a new element to the end of a doubly linked list.
     * @param {E} element - The "element" parameter represents the value that you want to add to the
     * doubly linked list.
     * @returns The `push` method is returning a boolean value, `true`.
     */
    push(element) {
      const newNode = new DoublyLinkedListNode(element);
      if (!this.head) {
        this._head = newNode;
        this._tail = newNode;
      } else {
        newNode.prev = this.tail;
        this.tail.next = newNode;
        this._tail = newNode;
      }
      this._size++;
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The `pop()` function removes and returns the value of the last element in a linked list.
     * @returns The method is returning the value of the removed node.
     */
    pop() {
      if (!this.tail)
        return void 0;
      const removedNode = this.tail;
      if (this.head === this.tail) {
        this._head = void 0;
        this._tail = void 0;
      } else {
        this._tail = removedNode.prev;
        this.tail.next = void 0;
      }
      this._size--;
      return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The `shift()` function removes and returns the value of the first element in a doubly linked list.
     * @returns The value of the removed node.
     */
    shift() {
      if (!this.head)
        return void 0;
      const removedNode = this.head;
      if (this.head === this.tail) {
        this._head = void 0;
        this._tail = void 0;
      } else {
        this._head = removedNode.next;
        this.head.prev = void 0;
      }
      this._size--;
      return removedNode.value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * The unshift function adds a new element to the beginning of a doubly linked list.
     * @param {E} element - The "element" parameter represents the value of the element that you want to
     * add to the beginning of the doubly linked list.
     * @returns The `unshift` method is returning a boolean value, `true`.
     */
    unshift(element) {
      const newNode = new DoublyLinkedListNode(element);
      if (!this.head) {
        this._head = newNode;
        this._tail = newNode;
      } else {
        newNode.next = this.head;
        this.head.prev = newNode;
        this._head = newNode;
      }
      this._size++;
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `at` function returns the value at a specified index in a linked list, or undefined if the index is out of bounds.
     * @param {number} index - The index parameter is a number that represents the position of the element we want to
     * retrieve from the list.
     * @returns The method is returning the value at the specified index in the linked list. If the index is out of bounds
     * or the linked list is empty, it will return undefined.
     */
    at(index) {
      if (index < 0 || index >= this.size)
        return void 0;
      let current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
      return current.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `getNodeAt` returns the node at a given index in a doubly linked list, or undefined if the index is out of
     * range.
     * @param {number} index - The `index` parameter is a number that represents the position of the node we want to
     * retrieve from the doubly linked list. It indicates the zero-based index of the node we want to access.
     * @returns The method `getNodeAt(index: number)` returns a `DoublyLinkedListNode<E>` object if the index is within the
     * valid range of the linked list, otherwise it returns `undefined`.
     */
    getNodeAt(index) {
      if (index < 0 || index >= this.size)
        return void 0;
      let current = this.head;
      for (let i = 0; i < index; i++) {
        current = current.next;
      }
      return current;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `findNodeByValue` searches for a node with a specific value in a doubly linked list and returns the
     * node if found, otherwise it returns undefined.
     * @param {E} value - The `value` parameter is the value that we want to search for in the doubly linked list.
     * @returns The function `findNodeByValue` returns a `DoublyLinkedListNode<E>` if a node with the specified value `value`
     * is found in the linked list. If no such node is found, it returns `undefined`.
     */
    getNode(value) {
      let current = this.head;
      while (current) {
        if (current.value === value) {
          return current;
        }
        current = current.next;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `insert` function inserts a value at a specified index in a doubly linked list.
     * @param {number} index - The index parameter represents the position at which the new value should be inserted in the
     * DoublyLinkedList. It is of type number.
     * @param {E} value - The `value` parameter represents the value that you want to insert into the Doubly Linked List at the
     * specified index.
     * @returns The `insert` method returns a boolean value. It returns `true` if the insertion is successful, and `false`
     * if the index is out of bounds.
     */
    addAt(index, value) {
      if (index < 0 || index > this.size)
        return false;
      if (index === 0) {
        this.unshift(value);
        return true;
      }
      if (index === this.size) {
        this.push(value);
        return true;
      }
      const newNode = new DoublyLinkedListNode(value);
      const prevNode = this.getNodeAt(index - 1);
      const nextNode = prevNode.next;
      newNode.prev = prevNode;
      newNode.next = nextNode;
      prevNode.next = newNode;
      nextNode.prev = newNode;
      this._size++;
      return true;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     * where n is the number of elements in the linked list.
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `addBefore` function inserts a new value before an existing value or node in a doubly linked list.
     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list
     * before which the new value will be inserted. It can be either the value of the existing node or the existing node
     * itself.
     * @param {E} newValue - The `newValue` parameter represents the value that you want to insert into the doubly linked
     * list.
     * @returns The method returns a boolean value. It returns `true` if the insertion is successful, and `false` if the
     * insertion fails.
     */
    addBefore(existingValueOrNode, newValue) {
      let existingNode;
      if (existingValueOrNode instanceof DoublyLinkedListNode) {
        existingNode = existingValueOrNode;
      } else {
        existingNode = this.getNode(existingValueOrNode);
      }
      if (existingNode) {
        const newNode = new DoublyLinkedListNode(newValue);
        newNode.prev = existingNode.prev;
        if (existingNode.prev) {
          existingNode.prev.next = newNode;
        }
        newNode.next = existingNode;
        existingNode.prev = newNode;
        if (existingNode === this.head) {
          this._head = newNode;
        }
        this._size++;
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `addAfter` function inserts a new node with a given value after an existing node in a doubly linked list.
     * @param {E | DoublyLinkedListNode<E>} existingValueOrNode - The existing value or node in the doubly linked list
     * after which the new value will be inserted. It can be either the value of the existing node or the existing node
     * itself.
     * @param {E} newValue - The value that you want to insert into the doubly linked list.
     * @returns The method returns a boolean value. It returns true if the insertion is successful, and false if the
     * existing value or node is not found in the doubly linked list.
     */
    addAfter(existingValueOrNode, newValue) {
      let existingNode;
      if (existingValueOrNode instanceof DoublyLinkedListNode) {
        existingNode = existingValueOrNode;
      } else {
        existingNode = this.getNode(existingValueOrNode);
      }
      if (existingNode) {
        const newNode = new DoublyLinkedListNode(newValue);
        newNode.next = existingNode.next;
        if (existingNode.next) {
          existingNode.next.prev = newNode;
        }
        newNode.prev = existingNode;
        existingNode.next = newNode;
        if (existingNode === this.tail) {
          this._tail = newNode;
        }
        this._size++;
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `deleteAt` function removes an element at a specified index from a linked list and returns the removed element.
     * @param {number} index - The index parameter represents the position of the element that needs to be deleted in the
     * data structure. It is of type number.
     * @returns The method `deleteAt` returns the value of the node that was deleted, or `undefined` if the index is out of
     * bounds.
     */
    deleteAt(index) {
      if (index < 0 || index >= this.size)
        return false;
      if (index === 0) {
        this.shift();
        return true;
      }
      if (index === this.size - 1) {
        this.pop();
        return true;
      }
      const removedNode = this.getNodeAt(index);
      const prevNode = removedNode.prev;
      const nextNode = removedNode.next;
      prevNode.next = nextNode;
      nextNode.prev = prevNode;
      this._size--;
      return true;
    }
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1) or O(n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a node from a doubly linked list based on either the node itself or its value.
     * @param {E | DoublyLinkedListNode<E>} valOrNode - The `valOrNode` parameter can accept either a value of type `E` or
     * a `DoublyLinkedListNode<E>` object.
     * @returns The `delete` method returns a boolean value. It returns `true` if the value or node was successfully
     * deleted from the doubly linked list, and `false` if the value or node was not found in the list.
     */
    delete(valOrNode) {
      let node;
      if (valOrNode instanceof DoublyLinkedListNode) {
        node = valOrNode;
      } else {
        node = this.getNode(valOrNode);
      }
      if (node) {
        if (node === this.head) {
          this.shift();
        } else if (node === this.tail) {
          this.pop();
        } else {
          const prevNode = node.prev;
          const nextNode = node.next;
          prevNode.next = nextNode;
          nextNode.prev = prevNode;
          this._size--;
        }
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if a variable has a size greater than zero and returns a boolean value.
     * @returns A boolean value is being returned.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `clear` function resets the linked list by setting the head, tail, and size to undefined and 0 respectively.
     */
    clear() {
      this._head = void 0;
      this._tail = void 0;
      this._size = 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function returns the index of the first occurrence of a given value in a linked list.
     * @param {E} value - The parameter `value` is of type `E`, which means it can be any data type. It represents the value
     * that we are searching for in the linked list.
     * @returns The method `indexOf` returns the index of the first occurrence of the specified value `value` in the linked
     * list. If the value is not found, it returns -1.
     */
    indexOf(value) {
      let index = 0;
      let current = this.head;
      while (current) {
        if (current.value === value) {
          return index;
        }
        index++;
        current = current.next;
      }
      return -1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `findBackward` function iterates through a linked list from the last node to the first node and returns the last
     * value that satisfies the given callback function, or undefined if no value satisfies the callback.
     * @param callback - A function that takes a value of type E as its parameter and returns a boolean value. This
     * function is used to determine whether a given value satisfies a certain condition.
     * @returns The method `findBackward` returns the last value in the linked list that satisfies the condition specified by
     * the callback function. If no value satisfies the condition, it returns `undefined`.
     */
    findBackward(callback) {
      let current = this.tail;
      while (current) {
        if (callback(current.value)) {
          return current.value;
        }
        current = current.prev;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `reverse` function reverses the order of the elements in a doubly linked list.
     */
    reverse() {
      let current = this.head;
      [this._head, this._tail] = [this.tail, this.head];
      while (current) {
        const next = current.next;
        [current.prev, current.next] = [current.next, current.prev];
        current = next;
      }
      return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toArray` function converts a linked list into an array.
     * @returns The `toArray()` method is returning an array of type `E[]`.
     */
    toArray() {
      const array = [];
      let current = this.head;
      while (current) {
        array.push(current.value);
        current = current.next;
      }
      return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toReversedArray` function converts a doubly linked list into an array in reverse order.
     * @returns The `toReversedArray()` function returns an array of type `E[]`.
     */
    toReversedArray() {
      const array = [];
      let current = this.tail;
      while (current) {
        array.push(current.value);
        current = current.prev;
      }
      return array;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function creates a new instance of the `DoublyLinkedList` class with the same values
     * as the original list.
     * @returns The `clone()` method is returning a new instance of the `DoublyLinkedList` class, which
     * is a copy of the original list.
     */
    clone() {
      return new _DoublyLinkedList(this);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new DoublyLinkedList by iterating over the elements of the current
     * list and applying a callback function to each element, returning only the elements for which the
     * callback function returns true.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the DoublyLinkedList. It takes three arguments: the current element, the index of the current
     * element, and the DoublyLinkedList itself. The callback function should return a boolean value
     * indicating whether the current element should be included
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `DoublyLinkedList` object that contains the
     * elements that pass the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredList = new _DoublyLinkedList([], { toElementFn: this.toElementFn });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredList.push(current);
        }
        index++;
      }
      return filteredList;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and returns a new DoublyLinkedList with the results
     * of applying the callback to each element in the original list.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * original DoublyLinkedList. It takes three arguments: current (the current element being
     * processed), index (the index of the current element), and this (the original DoublyLinkedList).
     * The callback function should return a value of type
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * convert the raw element (`RR`) to the desired element type (`T`). It takes the raw element as
     * input and returns the converted element. If this parameter is not provided, the raw element will
     * be used as is.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `DoublyLinkedList` class with elements of type `T` and `RR`.
     */
    map(callback, toElementFn, thisArg) {
      const mappedList = new _DoublyLinkedList([], { toElementFn });
      let index = 0;
      for (const current of this) {
        mappedList.push(callback.call(thisArg, current, index, this));
        index++;
      }
      return mappedList;
    }
    /**
     * The function returns an iterator that iterates over the values of a linked list.
     */
    *_getIterator() {
      let current = this.head;
      while (current) {
        yield current.value;
        current = current.next;
      }
    }
  };

  // src/data-structures/linked-list/skip-linked-list.ts
  var SkipListNode = class {
    constructor(key, value, level) {
      __publicField(this, "key");
      __publicField(this, "value");
      __publicField(this, "forward");
      this.key = key;
      this.value = value;
      this.forward = new Array(level);
    }
  };
  var SkipList = class {
    /**
     * The constructor function initializes a SkipLinkedList object with optional options and elements.
     * @param elements - The `elements` parameter is an iterable containing key-value pairs `[K, V]`. It
     * is used to initialize the SkipLinkedList with the given key-value pairs. If no elements are
     * provided, the SkipLinkedList will be empty.
     * @param {SkipLinkedListOptions} [options] - The `options` parameter is an optional object that can
     * contain two properties:
     */
    constructor(elements = [], options) {
      __publicField(this, "_head", new SkipListNode(void 0, void 0, this.maxLevel));
      __publicField(this, "_level", 0);
      __publicField(this, "_maxLevel", 16);
      __publicField(this, "_probability", 0.5);
      if (options) {
        const { maxLevel, probability } = options;
        if (typeof maxLevel === "number")
          this._maxLevel = maxLevel;
        if (typeof probability === "number")
          this._probability = probability;
      }
      if (elements) {
        for (const [key, value] of elements)
          this.add(key, value);
      }
    }
    /**
     * The function returns the head node of a SkipList.
     * @returns The method is returning a SkipListNode object with generic key type K and value type V.
     */
    get head() {
      return this._head;
    }
    /**
     * The function returns the value of the protected variable _level.
     * @returns The level property of the object.
     */
    get level() {
      return this._level;
    }
    /**
     * The function returns the maximum level.
     * @returns The value of the variable `_maxLevel` is being returned.
     */
    get maxLevel() {
      return this._maxLevel;
    }
    /**
     * The function returns the probability value.
     * @returns The probability value stored in the protected variable `_probability` is being returned.
     */
    get probability() {
      return this._probability;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Get the value of the first element (the smallest element) in the Skip List.
     * @returns The value of the first element, or undefined if the Skip List is empty.
     */
    get first() {
      const firstNode = this.head.forward[0];
      return firstNode ? firstNode.value : void 0;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the last element (the largest element) in the Skip List.
     * @returns The value of the last element, or undefined if the Skip List is empty.
     */
    get last() {
      let current = this.head;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i]) {
          current = current.forward[i];
        }
      }
      return current.value;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The add function adds a new node with a given key and value to a Skip List data structure.
     * @param {K} key - The key parameter represents the key of the node that needs to be added to the skip list.
     * @param {V} value - The "value" parameter represents the value associated with the key that is being added to the Skip
     * List.
     */
    add(key, value) {
      const newNode = new SkipListNode(key, value, this._randomLevel());
      const update = new Array(this.maxLevel).fill(this.head);
      let current = this.head;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i] && current.forward[i].key < key) {
          current = current.forward[i];
        }
        update[i] = current;
      }
      for (let i = 0; i < newNode.forward.length; i++) {
        newNode.forward[i] = update[i].forward[i];
        update[i].forward[i] = newNode;
      }
      if (!newNode.forward[0]) {
        this._level = Math.max(this.level, newNode.forward.length);
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `get` retrieves the value associated with a given key from a skip list data structure.
     * @param {K} key - The `key` parameter is the key of the element that we want to retrieve from the data structure.
     * @returns The method `get(key: K)` returns the value associated with the given key if it exists in the data structure,
     * otherwise it returns `undefined`.
     */
    get(key) {
      let current = this.head;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i] && current.forward[i].key < key) {
          current = current.forward[i];
        }
      }
      current = current.forward[0];
      if (current && current.key === key) {
        return current.value;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * The function checks if a key exists in a data structure.
     * @param {K} key - The parameter "key" is of type K, which represents the type of the key being
     * checked.
     * @returns a boolean value.
     */
    has(key) {
      return this.get(key) !== void 0;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes a node with a specific key from a Skip List data structure.
     * @param {K} key - The key parameter represents the key of the node that needs to be removed from the skip list.
     * @returns The `delete` method returns a boolean value. It returns `true` if the key was successfully removed from the
     * skip list, and `false` if the key was not found in the skip list.
     */
    delete(key) {
      const update = new Array(this.maxLevel).fill(this.head);
      let current = this.head;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i] && current.forward[i].key < key) {
          current = current.forward[i];
        }
        update[i] = current;
      }
      current = current.forward[0];
      if (current && current.key === key) {
        for (let i = 0; i < this.level; i++) {
          if (update[i].forward[i] !== current) {
            break;
          }
          update[i].forward[i] = current.forward[i];
        }
        while (this.level > 0 && !this.head.forward[this.level - 1]) {
          this._level--;
        }
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the first element in the Skip List that is greater than the given key.
     * @param key - the given key.
     * @returns The value of the first element greater than the given key, or undefined if there is no such element.
     */
    higher(key) {
      let current = this.head;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i] && current.forward[i].key <= key) {
          current = current.forward[i];
        }
      }
      const nextNode = current.forward[0];
      return nextNode ? nextNode.value : void 0;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Get the value of the last element in the Skip List that is less than the given key.
     * @param key - the given key.
     * @returns The value of the last element less than the given key, or undefined if there is no such element.
     */
    lower(key) {
      let current = this.head;
      let lastLess = void 0;
      for (let i = this.level - 1; i >= 0; i--) {
        while (current.forward[i] && current.forward[i].key < key) {
          current = current.forward[i];
        }
        if (current.key < key) {
          lastLess = current;
        }
      }
      return lastLess ? lastLess.value : void 0;
    }
    /**
     * Time Complexity: O(maxLevel)
     * Space Complexity: O(1)
     * where maxLevel is the maximum level of the SkipList, as it may iterate up to maxLevel times in the worst case.
     */
    /**
     * Time Complexity: O(maxLevel)
     * Space Complexity: O(1)
     *
     * The function "_randomLevel" generates a random level based on a given probability and maximum level.
     * @returns the level, which is a number.
     */
    _randomLevel() {
      let level = 1;
      while (Math.random() < this.probability && level < this.maxLevel) {
        level++;
      }
      return level;
    }
  };

  // src/data-structures/stack/stack.ts
  var Stack = class _Stack extends IterableElementBase {
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_elements", []);
      if (elements) {
        for (const el of elements) {
          if (this.toElementFn) {
            this.push(this.toElementFn(el));
          } else {
            this.push(el);
          }
        }
      }
    }
    /**
     * The elements function returns the elements of this set.
     * @return An array of elements
     */
    get elements() {
      return this._elements;
    }
    /**
     * The size() function returns the number of elements in an array.
     * @returns The size of the elements array.
     */
    get size() {
      return this.elements.length;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function "fromArray" creates a new Stack object from an array of elements.
     * @param {E[]} elements - The `elements` parameter is an array of elements of type `E`.
     * @returns {Stack} The method is returning a new instance of the Stack class, initialized with the elements from the input
     * array.
     */
    static fromArray(elements) {
      return new _Stack(elements);
    }
    /**
     * The function checks if an array is empty and returns a boolean value.
     * @returns A boolean value indicating whether the `_elements` array is empty or not.
     */
    isEmpty() {
      return this.elements.length === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `peek` function returns the last element of an array, or undefined if the array is empty.
     * @returns The `peek()` function returns the last element of the `_elements` array, or `undefined` if the array is empty.
     */
    peek() {
      if (this.isEmpty())
        return void 0;
      return this.elements[this.elements.length - 1];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The push function adds an element to the stack and returns the updated stack.
     * @param {E} element - The parameter "element" is of type E, which means it can be any data type.
     * @returns The `push` method is returning the updated `Stack<E>` object.
     */
    push(element) {
      this.elements.push(element);
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `pop` function removes and returns the last element from an array, or returns undefined if the array is empty.
     * @returns The `pop()` method is returning the last element of the array `_elements` if the array is not empty. If the
     * array is empty, it returns `undefined`.
     */
    pop() {
      if (this.isEmpty())
        return;
      return this.elements.pop();
    }
    /**
     * The delete function removes an element from the stack.
     * @param element: E Specify the element to be deleted
     * @return A boolean value indicating whether the element was successfully deleted or not
     */
    delete(element) {
      const index = this.elements.indexOf(element);
      return this.deleteAt(index);
    }
    /**
     * The deleteAt function deletes the element at a given index.
     * @param index: number Determine the index of the element to be deleted
     * @return A boolean value
     */
    deleteAt(index) {
      const spliced = this.elements.splice(index, 1);
      return spliced.length === 1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The toArray function returns a copy of the elements in an array.
     * @returns An array of type E.
     */
    toArray() {
      return this.elements.slice();
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear function clears the elements array.
     */
    clear() {
      this._elements = [];
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone()` function returns a new `Stack` object with the same elements as the original stack.
     * @returns The `clone()` method is returning a new `Stack` object with a copy of the `_elements` array.
     */
    clone() {
      return new _Stack(this, { toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new stack containing elements from the original stack that satisfy
     * a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * the current element being iterated over, the index of the current element, and the stack itself.
     * It should return a boolean value indicating whether the element should be included in the filtered
     * stack or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `filter` method is returning a new `Stack` object that contains the elements that
     * satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
      const newStack = new _Stack([], { toElementFn: this.toElementFn });
      let index = 0;
      for (const el of this) {
        if (predicate.call(thisArg, el, index, this)) {
          newStack.push(el);
        }
        index++;
      }
      return newStack;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and applies it to each element in the stack,
     * returning a new stack with the results.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * stack. It takes three arguments: the current element, the index of the element, and the stack
     * itself. It should return a new value that will be added to the new stack.
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * transform the raw element (`RM`) into a new element (`EM`) before pushing it into the new stack.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new Stack object with elements of type EM and raw elements of type RM.
     */
    map(callback, toElementFn, thisArg) {
      const newStack = new _Stack([], { toElementFn });
      let index = 0;
      for (const el of this) {
        newStack.push(callback.call(thisArg, el, index, this));
        index++;
      }
      return newStack;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Custom iterator for the Stack class.
     * @returns An iterator object.
     */
    *_getIterator() {
      for (let i = 0; i < this.elements.length; i++) {
        yield this.elements[i];
      }
    }
  };

  // src/data-structures/queue/queue.ts
  var Queue = class _Queue extends IterableElementBase {
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_elements", []);
      __publicField(this, "_offset", 0);
      if (elements) {
        for (const el of elements) {
          if (this.toElementFn)
            this.push(this.toElementFn(el));
          else
            this.push(el);
        }
      }
    }
    /**
     * The elements function returns the elements of this set.
     * @return An array of the elements in the stack
     */
    get elements() {
      return this._elements;
    }
    /**
     * The offset function returns the offset of the current page.
     * @return The value of the protected variable _offset
     */
    get offset() {
      return this._offset;
    }
    /**
     * The size function returns the number of elements in an array.
     * @returns {number} The size of the array, which is the difference between the length of the array and the offset.
     */
    get size() {
      return this.elements.length - this.offset;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `first` function returns the first element of the array `_elements` if it exists, otherwise it returns `undefined`.
     * @returns The `get first()` method returns the first element of the data structure, represented by the `_elements` array at
     * the `_offset` index. If the data structure is empty (size is 0), it returns `undefined`.
     */
    get first() {
      return this.size > 0 ? this.elements[this.offset] : void 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `last` function returns the last element in an array-like data structure, or undefined if the structure is empty.
     * @returns The method `get last()` returns the last element of the `_elements` array if the array is not empty. If the
     * array is empty, it returns `undefined`.
     */
    get last() {
      return this.size > 0 ? this.elements[this.elements.length - 1] : void 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function "fromArray" creates a new Queue object from an array of elements.Creates a queue from an existing array.
     * @public
     * @static
     * @param {E[]} elements - The "elements" parameter is an array of elements of type E.
     * @returns The method is returning a new instance of the Queue class, initialized with the elements from the input
     * array.
     */
    static fromArray(elements) {
      return new _Queue(elements);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The push function adds an element to the end of the queue and returns the updated queue.Adds an element at the back of the queue.
     * @param {E} element - The `element` parameter represents the element that you want to add to the queue.
     * @returns The `add` method is returning a `Queue<E>` object.
     */
    push(element) {
      this.elements.push(element);
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `shift` function removes and returns the first element in the queue, and adjusts the internal data structure if
     * necessary to optimize performance.
     * @returns The function `shift()` returns either the first element in the queue or `undefined` if the queue is empty.
     */
    shift() {
      if (this.size === 0)
        return void 0;
      const first = this.first;
      this._offset += 1;
      if (this.offset * 2 < this.elements.length)
        return first;
      this._elements = this.elements.slice(this.offset);
      this._offset = 0;
      return first;
    }
    /**
     * The delete function removes an element from the list.
     * @param element: E Specify the element to be deleted
     * @return A boolean value indicating whether the element was successfully deleted or not
     */
    delete(element) {
      const index = this.elements.indexOf(element);
      return this.deleteAt(index);
    }
    /**
     * The deleteAt function deletes the element at a given index.
     * @param index: number Determine the index of the element to be deleted
     * @return A boolean value
     */
    deleteAt(index) {
      const spliced = this.elements.splice(index, 1);
      return spliced.length === 1;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * @param index
     */
    at(index) {
      return this.elements[index + this._offset];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if a data structure is empty by comparing its size to zero.
     * @returns {boolean} A boolean value indicating whether the size of the object is 0 or not.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(n)
     *
     * The toArray() function returns an array of elements from the current offset to the end of the _elements array.
     * @returns An array of type E is being returned.
     */
    toArray() {
      return this.elements.slice(this.offset);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear function resets the elements array and offset to their initial values.
     */
    clear() {
      this._elements = [];
      this._offset = 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * where n is the number of elements in the queue. It creates a shallow copy of the internal array. the space required is proportional to the number of elements in the queue.
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone()` function returns a new Queue object with the same elements as the original Queue.
     * @returns The `clone()` method is returning a new instance of the `Queue` class.
     */
    clone() {
      return new _Queue(this.elements.slice(this.offset), { toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new `Queue` object containing elements from the original `Queue`
     * that satisfy a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * the current element being iterated over, the index of the current element, and the queue itself.
     * It should return a boolean value indicating whether the element should be included in the filtered
     * queue or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `filter` method is returning a new `Queue` object that contains the elements that
     * satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
      const newDeque = new _Queue([], { toElementFn: this.toElementFn });
      let index = 0;
      for (const el of this) {
        if (predicate.call(thisArg, el, index, this)) {
          newDeque.push(el);
        }
        index++;
      }
      return newDeque;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    map(callback, toElementFn, thisArg) {
      const newDeque = new _Queue([], { toElementFn });
      let index = 0;
      for (const el of this) {
        newDeque.push(callback.call(thisArg, el, index, this));
        index++;
      }
      return newDeque;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function `_getIterator` returns an iterable iterator for the elements in the class.
     */
    *_getIterator() {
      for (const item of this.elements.slice(this.offset)) {
        yield item;
      }
    }
  };
  var LinkedListQueue = class _LinkedListQueue extends SinglyLinkedList {
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     * The `clone` function returns a new instance of the `LinkedListQueue` class with the same values as
     * the current instance.
     * @returns The `clone()` method is returning a new instance of `LinkedListQueue` with the same
     * values as the original `LinkedListQueue`.
     */
    clone() {
      return new _LinkedListQueue(this, { toElementFn: this.toElementFn });
    }
  };

  // src/data-structures/queue/deque.ts
  var Deque = class _Deque extends IterableElementBase {
    /**
     * The constructor initializes a Deque object with optional iterable of elements and options.
     * @param elements - An iterable object (such as an array or a Set) that contains the initial
     * elements to be added to the deque. It can also be an object with a `length` or `size` property
     * that represents the number of elements in the iterable object. If no elements are provided, an
     * empty deque
     * @param {DequeOptions} [options] - The `options` parameter is an optional object that can contain
     * configuration options for the deque. In this code, it is used to set the `bucketSize` option,
     * which determines the size of each bucket in the deque. If the `bucketSize` option is not provided
     * or is not a number
     */
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_bucketSize", 1 << 12);
      __publicField(this, "_bucketFirst", 0);
      __publicField(this, "_firstInBucket", 0);
      __publicField(this, "_bucketLast", 0);
      __publicField(this, "_lastInBucket", 0);
      __publicField(this, "_bucketCount", 0);
      __publicField(this, "_buckets", []);
      __publicField(this, "_size", 0);
      if (options) {
        const { bucketSize } = options;
        if (typeof bucketSize === "number")
          this._bucketSize = bucketSize;
      }
      let _size;
      if ("length" in elements) {
        if (elements.length instanceof Function)
          _size = elements.length();
        else
          _size = elements.length;
      } else {
        if (elements.size instanceof Function)
          _size = elements.size();
        else
          _size = elements.size;
      }
      this._bucketCount = calcMinUnitsRequired(_size, this._bucketSize) || 1;
      for (let i = 0; i < this._bucketCount; ++i) {
        this._buckets.push(new Array(this._bucketSize));
      }
      const needBucketNum = calcMinUnitsRequired(_size, this._bucketSize);
      this._bucketFirst = this._bucketLast = (this._bucketCount >> 1) - (needBucketNum >> 1);
      this._firstInBucket = this._lastInBucket = this._bucketSize - _size % this._bucketSize >> 1;
      for (const el of elements) {
        if (this.toElementFn) {
          this.push(this.toElementFn(el));
        } else {
          this.push(el);
        }
      }
    }
    /**
     * The bucketSize function returns the size of the bucket.
     *
     * @return The size of the bucket
     */
    get bucketSize() {
      return this._bucketSize;
    }
    /**
     * The function returns the value of the protected variable `_bucketFirst`.
     * @returns The value of the `_bucketFirst` property.
     */
    get bucketFirst() {
      return this._bucketFirst;
    }
    /**
     * The function returns the value of the protected variable _firstInBucket.
     * @returns The method is returning the value of the variable `_firstInBucket`, which is of type
     * `number`.
     */
    get firstInBucket() {
      return this._firstInBucket;
    }
    /**
     * The function returns the value of the protected variable `_bucketLast`.
     * @returns The value of the `_bucketLast` property, which is a number.
     */
    get bucketLast() {
      return this._bucketLast;
    }
    /**
     * The function returns the value of the protected variable _lastInBucket.
     * @returns The method is returning the value of the variable `_lastInBucket`, which is of type
     * `number`.
     */
    get lastInBucket() {
      return this._lastInBucket;
    }
    /**
     * The function returns the number of buckets.
     * @returns The number of buckets.
     */
    get bucketCount() {
      return this._bucketCount;
    }
    /**
     * The buckets function returns the buckets property of the object.
     * @return The buckets property
     */
    get buckets() {
      return this._buckets;
    }
    /**
     * The size function returns the number of items in the stack.
     * @return The number of values in the set
     */
    get size() {
      return this._size;
    }
    /**
     * The function returns the first element in a collection if it exists, otherwise it returns
     * undefined.
     * @returns The first element of the collection, of type E, is being returned.
     */
    get first() {
      if (this.size === 0)
        return;
      return this._buckets[this._bucketFirst][this._firstInBucket];
    }
    /**
     * The last function returns the last element in the queue.
     * @return The last element in the array
     */
    get last() {
      if (this.size === 0)
        return;
      return this._buckets[this._bucketLast][this._lastInBucket];
    }
    /**
     * Time Complexity - Amortized O(1) (possible reallocation)
     * Space Complexity - O(n) (due to potential resizing).
     */
    /**
     * Time Complexity - Amortized O(1) (possible reallocation),
     * Space Complexity - O(n) (due to potential resizing).
     *
     * The push function adds an element to a data structure and reallocates memory if necessary.
     * @param {E} element - The `element` parameter represents the value that you want to add to the data
     * structure.
     * @returns The size of the data structure after the element has been pushed.
     */
    push(element) {
      if (this.size) {
        if (this._lastInBucket < this._bucketSize - 1) {
          this._lastInBucket += 1;
        } else if (this._bucketLast < this._bucketCount - 1) {
          this._bucketLast += 1;
          this._lastInBucket = 0;
        } else {
          this._bucketLast = 0;
          this._lastInBucket = 0;
        }
        if (this._bucketLast === this._bucketFirst && this._lastInBucket === this._firstInBucket)
          this._reallocate();
      }
      this._size += 1;
      this._buckets[this._bucketLast][this._lastInBucket] = element;
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `pop()` function removes and returns the last element from a data structure, updating the
     * internal state variables accordingly.
     * @returns The element that was removed from the data structure is being returned.
     */
    pop() {
      if (this.size === 0)
        return;
      const element = this._buckets[this._bucketLast][this._lastInBucket];
      if (this.size !== 1) {
        if (this._lastInBucket > 0) {
          this._lastInBucket -= 1;
        } else if (this._bucketLast > 0) {
          this._bucketLast -= 1;
          this._lastInBucket = this._bucketSize - 1;
        } else {
          this._bucketLast = this._bucketCount - 1;
          this._lastInBucket = this._bucketSize - 1;
        }
      }
      this._size -= 1;
      return element;
    }
    /**
     * Time Complexity: Amortized O(1)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: Amortized O(1)
     * Space Complexity: O(n)
     *
     * The `unshift` function adds an element to the beginning of an array-like data structure and
     * returns the new size of the structure.
     * @param {E} element - The `element` parameter represents the element that you want to add to the
     * beginning of the data structure.
     * @returns The size of the data structure after the element has been added.
     */
    unshift(element) {
      if (this.size) {
        if (this._firstInBucket > 0) {
          this._firstInBucket -= 1;
        } else if (this._bucketFirst > 0) {
          this._bucketFirst -= 1;
          this._firstInBucket = this._bucketSize - 1;
        } else {
          this._bucketFirst = this._bucketCount - 1;
          this._firstInBucket = this._bucketSize - 1;
        }
        if (this._bucketFirst === this._bucketLast && this._firstInBucket === this._lastInBucket)
          this._reallocate();
      }
      this._size += 1;
      this._buckets[this._bucketFirst][this._firstInBucket] = element;
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `shift()` function removes and returns the first element from a data structure, updating the
     * internal state variables accordingly.
     * @returns The element that is being removed from the beginning of the data structure is being
     * returned.
     */
    shift() {
      if (this.size === 0)
        return;
      const element = this._buckets[this._bucketFirst][this._firstInBucket];
      if (this.size !== 1) {
        if (this._firstInBucket < this._bucketSize - 1) {
          this._firstInBucket += 1;
        } else if (this._bucketFirst < this._bucketCount - 1) {
          this._bucketFirst += 1;
          this._firstInBucket = 0;
        } else {
          this._bucketFirst = 0;
          this._firstInBucket = 0;
        }
      }
      this._size -= 1;
      return element;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if the size of an object is equal to zero and returns a boolean value.
     * @returns A boolean value indicating whether the size of the object is 0 or not.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear() function resets the state of the object by initializing all variables to their default
     * values.
     */
    clear() {
      this._buckets = [new Array(this._bucketSize)];
      this._bucketCount = 1;
      this._bucketFirst = this._bucketLast = this._size = 0;
      this._firstInBucket = this._lastInBucket = this._bucketSize >> 1;
    }
    /**
     * The below function is a generator that yields elements from a collection one by one.
     */
    *begin() {
      let index = 0;
      while (index < this.size) {
        yield this.at(index);
        index++;
      }
    }
    /**
     * The function `reverseBegin()` is a generator that yields elements in reverse order starting from
     * the last element.
     */
    *reverseBegin() {
      let index = this.size - 1;
      while (index >= 0) {
        yield this.at(index);
        index--;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `at` function retrieves an element at a specified position in an array-like data structure.
     * @param {number} pos - The `pos` parameter represents the position of the element that you want to
     * retrieve from the data structure. It is of type `number` and should be a valid index within the
     * range of the data structure.
     * @returns The element at the specified position in the data structure is being returned.
     */
    at(pos) {
      rangeCheck(pos, 0, this.size - 1);
      const { bucketIndex, indexInBucket } = this._getBucketAndPosition(pos);
      return this._buckets[bucketIndex][indexInBucket];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `setAt` function sets an element at a specific position in an array-like data structure.
     * @param {number} pos - The `pos` parameter represents the position at which the element needs to be
     * set. It is of type `number`.
     * @param {E} element - The `element` parameter is the value that you want to set at the specified
     * position in the data structure.
     */
    setAt(pos, element) {
      rangeCheck(pos, 0, this.size - 1);
      const { bucketIndex, indexInBucket } = this._getBucketAndPosition(pos);
      this._buckets[bucketIndex][indexInBucket] = element;
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `addAt` function inserts one or more elements at a specified position in an array-like data
     * structure.
     * @param {number} pos - The `pos` parameter represents the position at which the element(s) should
     * be inserted. It is of type `number`.
     * @param {E} element - The `element` parameter represents the element that you want to insert into
     * the array at the specified position.
     * @param [num=1] - The `num` parameter represents the number of times the `element` should be
     * inserted at the specified position (`pos`). By default, it is set to 1, meaning that the `element`
     * will be inserted once. However, you can provide a different value for `num` if you want
     * @returns The size of the array after the insertion is being returned.
     */
    addAt(pos, element, num = 1) {
      const length = this.size;
      rangeCheck(pos, 0, length);
      if (pos === 0) {
        while (num--)
          this.unshift(element);
      } else if (pos === this.size) {
        while (num--)
          this.push(element);
      } else {
        const arr = [];
        for (let i = pos; i < this.size; ++i) {
          arr.push(this.at(i));
        }
        this.cut(pos - 1, true);
        for (let i = 0; i < num; ++i)
          this.push(element);
        for (let i = 0; i < arr.length; ++i)
          this.push(arr[i]);
      }
      return true;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `cut` function updates the state of the object based on the given position and returns the
     * updated size.
     * @param {number} pos - The `pos` parameter represents the position at which the string should be
     * cut. It is a number that indicates the index of the character where the cut should be made.
     * @param {boolean} isCutSelf - If true, the original deque will not be cut, and return a new deque
     * @returns The method is returning the updated size of the data structure.
     */
    cut(pos, isCutSelf = false) {
      if (isCutSelf) {
        if (pos < 0) {
          this.clear();
          return this;
        }
        const { bucketIndex, indexInBucket } = this._getBucketAndPosition(pos);
        this._bucketLast = bucketIndex;
        this._lastInBucket = indexInBucket;
        this._size = pos + 1;
        return this;
      } else {
        const newDeque = new _Deque([], { bucketSize: this._bucketSize });
        for (let i = 0; i <= pos; i++) {
          newDeque.push(this.at(i));
        }
        return newDeque;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1) or O(n)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1) or O(n)
     *
     * The `cutRest` function cuts the elements from a specified position in a deque and returns a new
     * deque with the cut elements.
     * @param {number} pos - The `pos` parameter represents the position from which to cut the Deque. It
     * is a number that indicates the index of the element in the Deque where the cut should start.
     * @param [isCutSelf=false] - isCutSelf is a boolean parameter that determines whether the original
     * Deque should be modified or a new Deque should be created. If isCutSelf is true, the original
     * Deque will be modified by cutting off elements starting from the specified position. If isCutSelf
     * is false, a new De
     * @returns The function `cutRest` returns either the modified original deque (`this`) or a new deque
     * (`newDeque`) depending on the value of the `isCutSelf` parameter.
     */
    cutRest(pos, isCutSelf = false) {
      if (isCutSelf) {
        if (pos < 0) {
          this.clear();
          return this;
        }
        const { bucketIndex, indexInBucket } = this._getBucketAndPosition(pos);
        this._bucketFirst = bucketIndex;
        this._firstInBucket = indexInBucket;
        this._size = this._size - pos;
        return this;
      } else {
        const newDeque = new _Deque([], { bucketSize: this._bucketSize });
        for (let i = pos; i < this.size; i++) {
          newDeque.push(this.at(i));
        }
        return newDeque;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1) or O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1) or O(n)
     *
     * The `deleteAt` function removes an element at a specified position in an array-like data
     * structure.
     * @param {number} pos - The `pos` parameter in the `deleteAt` function represents the position at
     * which an element needs to be deleted from the data structure. It is of type `number` and indicates
     * the index of the element to be deleted.
     * @returns The size of the data structure after the deletion operation is performed.
     */
    deleteAt(pos) {
      rangeCheck(pos, 0, this.size - 1);
      if (pos === 0)
        this.shift();
      else if (pos === this.size - 1)
        this.pop();
      else {
        const length = this.size - 1;
        let { bucketIndex: curBucket, indexInBucket: curPointer } = this._getBucketAndPosition(pos);
        for (let i = pos; i < length; ++i) {
          const { bucketIndex: nextBucket, indexInBucket: nextPointer } = this._getBucketAndPosition(pos + 1);
          this._buckets[curBucket][curPointer] = this._buckets[nextBucket][nextPointer];
          curBucket = nextBucket;
          curPointer = nextPointer;
        }
        this.pop();
      }
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes all occurrences of a specified element from an array-like data
     * structure.
     * @param {E} element - The `element` parameter represents the element that you want to delete from
     * the data structure.
     * @returns The size of the data structure after the element has been deleted.
     */
    delete(element) {
      const size = this.size;
      if (size === 0)
        return false;
      let i = 0;
      let index = 0;
      while (i < size) {
        const oldElement = this.at(i);
        if (oldElement !== element) {
          this.setAt(index, oldElement);
          index += 1;
        }
        i += 1;
      }
      this.cut(index - 1, true);
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The reverse() function reverses the order of the buckets and the elements within each bucket in a
     * data structure.
     * @returns The reverse() method is returning the object itself (this) after performing the reverse
     * operation on the buckets and updating the relevant properties.
     */
    reverse() {
      this._buckets.reverse().forEach(function(bucket) {
        bucket.reverse();
      });
      const { _bucketFirst, _bucketLast, _firstInBucket, _lastInBucket } = this;
      this._bucketFirst = this._bucketCount - _bucketLast - 1;
      this._bucketLast = this._bucketCount - _bucketFirst - 1;
      this._firstInBucket = this._bucketSize - _lastInBucket - 1;
      this._lastInBucket = this._bucketSize - _firstInBucket - 1;
      return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `unique()` function removes duplicate elements from an array-like data structure and returns
     * the number of unique elements.
     * @returns The size of the modified array is being returned.
     */
    unique() {
      if (this.size <= 1) {
        return this;
      }
      let index = 1;
      let prev = this.at(0);
      for (let i = 1; i < this.size; ++i) {
        const cur = this.at(i);
        if (cur !== prev) {
          prev = cur;
          this.setAt(index++, cur);
        }
      }
      this.cut(index - 1, true);
      return this;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `sort` function sorts the elements in a data structure using a provided comparator function.
     * @param [comparator] - The `comparator` parameter is a function that takes in two elements `x` and
     * `y` of type `E` and returns a number. The comparator function is used to determine the order of
     * the elements in the sorted array.
     * @returns Deque<E>
     */
    sort(comparator) {
      const arr = [];
      for (let i = 0; i < this.size; ++i) {
        arr.push(this.at(i));
      }
      arr.sort(comparator);
      for (let i = 0; i < this.size; ++i) {
        this.setAt(i, arr[i]);
      }
      return this;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `shrinkToFit` function reorganizes the elements in an array-like data structure to minimize
     * memory usage.
     * @returns Nothing is being returned. The function is using the `return` statement to exit early if
     * `this.size` is 0, but it does not return any value.
     */
    shrinkToFit() {
      if (this.size === 0)
        return;
      const newBuckets = [];
      if (this._bucketFirst === this._bucketLast)
        return;
      else if (this._bucketFirst < this._bucketLast) {
        for (let i = this._bucketFirst; i <= this._bucketLast; ++i) {
          newBuckets.push(this._buckets[i]);
        }
      } else {
        for (let i = this._bucketFirst; i < this._bucketCount; ++i) {
          newBuckets.push(this._buckets[i]);
        }
        for (let i = 0; i <= this._bucketLast; ++i) {
          newBuckets.push(this._buckets[i]);
        }
      }
      this._bucketFirst = 0;
      this._bucketLast = newBuckets.length - 1;
      this._buckets = newBuckets;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function "indexOf" returns the index of the first occurrence of a given element in an array,
     * or -1 if the element is not found.
     * @param {E} element - The "element" parameter represents the element that you want to find the
     * index of in the data structure.
     * @returns The indexOf function returns the index of the first occurrence of the specified element
     * in the data structure. If the element is not found, it returns -1.
     */
    indexOf(element) {
      for (let i = 0; i < this.size; ++i) {
        if (this.at(i) === element) {
          return i;
        }
      }
      return -1;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `toArray` function converts the elements of a data structure into an array.
     * @returns The `toArray()` method is returning an array of elements of type `E`.
     */
    toArray() {
      return [...this];
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone()` function returns a new instance of the `Deque` class with the same elements and
     * bucket size as the original instance.
     * @returns The `clone()` method is returning a new instance of the `Deque` class with the same
     * elements as the original deque (`this`) and the same bucket size.
     */
    clone() {
      return new _Deque(this, { bucketSize: this.bucketSize, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new deque containing elements from the original deque that satisfy
     * a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * the current element being iterated over, the index of the current element, and the deque itself.
     * It should return a boolean value indicating whether the element should be included in the filtered
     * deque or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `predicate` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `predicate` function. If `thisArg` is
     * @returns The `filter` method is returning a new `Deque` object that contains the elements that
     * satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
      const newDeque = new _Deque([], { bucketSize: this._bucketSize, toElementFn: this.toElementFn });
      let index = 0;
      for (const el of this) {
        if (predicate.call(thisArg, el, index, this)) {
          newDeque.push(el);
        }
        index++;
      }
      return newDeque;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * The `map` function takes a callback function and applies it to each element in the deque,
     * returning a new deque with the results.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * deque. It takes three arguments: the current element, the index of the element, and the deque
     * itself. It should return a value of type EM.
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * transform the raw element (`RM`) into a new element (`EM`) before adding it to the new deque. If
     * provided, this function will be called for each raw element in the original deque.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new Deque object with elements of type EM and raw elements of type RM.
     */
    map(callback, toElementFn, thisArg) {
      const newDeque = new _Deque([], { bucketSize: this._bucketSize, toElementFn });
      let index = 0;
      for (const el of this) {
        newDeque.push(callback.call(thisArg, el, index, this));
        index++;
      }
      return newDeque;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The above function is an implementation of the iterator protocol in TypeScript, allowing the
     * object to be iterated over using a for...of loop.
     */
    *_getIterator() {
      for (let i = 0; i < this.size; ++i) {
        yield this.at(i);
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `_reallocate` function reallocates the buckets in an array, adding new buckets if needed.
     * @param {number} [needBucketNum] - The `needBucketNum` parameter is an optional number that
     * specifies the number of new buckets needed. If not provided, it will default to half of the
     * current bucket count (`this._bucketCount >> 1`) or 1 if the current bucket count is less than 2.
     */
    _reallocate(needBucketNum) {
      const newBuckets = [];
      const addBucketNum = needBucketNum || this._bucketCount >> 1 || 1;
      for (let i = 0; i < addBucketNum; ++i) {
        newBuckets[i] = new Array(this._bucketSize);
      }
      for (let i = this._bucketFirst; i < this._bucketCount; ++i) {
        newBuckets[newBuckets.length] = this._buckets[i];
      }
      for (let i = 0; i < this._bucketLast; ++i) {
        newBuckets[newBuckets.length] = this._buckets[i];
      }
      newBuckets[newBuckets.length] = [...this._buckets[this._bucketLast]];
      this._bucketFirst = addBucketNum;
      this._bucketLast = newBuckets.length - 1;
      for (let i = 0; i < addBucketNum; ++i) {
        newBuckets[newBuckets.length] = new Array(this._bucketSize);
      }
      this._buckets = newBuckets;
      this._bucketCount = newBuckets.length;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function calculates the bucket index and index within the bucket based on the given position.
     * @param {number} pos - The `pos` parameter represents the position within the data structure. It is
     * a number that indicates the index or position of an element within the structure.
     * @returns an object with two properties: "bucketIndex" and "indexInBucket".
     */
    _getBucketAndPosition(pos) {
      let bucketIndex;
      let indexInBucket;
      const overallIndex = this._firstInBucket + pos;
      bucketIndex = this._bucketFirst + Math.floor(overallIndex / this._bucketSize);
      if (bucketIndex >= this._bucketCount) {
        bucketIndex -= this._bucketCount;
      }
      indexInBucket = (overallIndex + 1) % this._bucketSize - 1;
      if (indexInBucket < 0) {
        indexInBucket = this._bucketSize - 1;
      }
      return { bucketIndex, indexInBucket };
    }
  };

  // src/data-structures/heap/heap.ts
  var Heap = class _Heap extends IterableElementBase {
    /**
     * The constructor initializes a heap data structure with optional elements and options.
     * @param elements - The `elements` parameter is an iterable object that contains the initial
     * elements to be added to the heap.
     * It is an optional parameter, and if not provided, the heap will
     * be initialized as empty.
     * @param [options] - The `options` parameter is an optional object that can contain additional
     * configuration options for the heap.
     * In this case, it is used to specify a custom comparator
     * function for comparing elements in the heap.
     * The comparator function is used to determine the
     * order of elements in the heap.
     */
    constructor(elements = [], options) {
      super(options);
      __publicField(this, "_elements", []);
      __publicField(this, "_DEFAULT_COMPARATOR", (a, b) => {
        if (typeof a === "object" || typeof b === "object") {
          throw TypeError(
            `When comparing object types, a custom comparator must be defined in the constructor's options parameter.`
          );
        }
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        return 0;
      });
      __publicField(this, "_comparator", this._DEFAULT_COMPARATOR);
      if (options) {
        const { comparator } = options;
        if (comparator)
          this._comparator = comparator;
      }
      if (elements) {
        for (const el of elements) {
          if (this.toElementFn)
            this.add(this.toElementFn(el));
          else
            this.add(el);
        }
      }
    }
    /**
     * The function returns an array of elements.
     * @returns The element array is being returned.
     */
    get elements() {
      return this._elements;
    }
    /**
     * Get the size (number of elements) of the heap.
     */
    get size() {
      return this.elements.length;
    }
    /**
     * Get the last element in the heap, which is not necessarily a leaf node.
     * @returns The last element or undefined if the heap is empty.
     */
    get leaf() {
      var _a;
      return (_a = this.elements[this.size - 1]) != null ? _a : void 0;
    }
    /**
     * Static method that creates a binary heap from an array of elements and a comparison function.
     * @returns A new Heap instance.
     * @param elements
     * @param options
     */
    static heapify(elements, options) {
      return new _Heap(elements, options);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element - The element to be inserted.
     */
    add(element) {
      this._elements.push(element);
      return this._bubbleUp(this.elements.length - 1);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    poll() {
      if (this.elements.length === 0)
        return;
      const value = this.elements[0];
      const last = this.elements.pop();
      if (this.elements.length) {
        this.elements[0] = last;
        this._sinkDown(0, this.elements.length >> 1);
      }
      return value;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Peek at the top element of the heap without removing it.
     * @returns The top element or undefined if the heap is empty.
     */
    peek() {
      return this.elements[0];
    }
    /**
     * Check if the heap is empty.
     * @returns True if the heap is empty, otherwise false.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Reset the elements of the heap. Make the elements empty.
     */
    clear() {
      this._elements = [];
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Clear and add elements of the heap
     * @param elements
     */
    refill(elements) {
      this._elements = elements;
      return this.fix();
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * Use a comparison function to check whether a binary heap contains a specific element.
     * @param element - the element to check.
     * @returns Returns true if the specified element is contained; otherwise, returns false.
     */
    has(element) {
      return this.elements.includes(element);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `delete` function removes an element from an array-like data structure, maintaining the order
     * and structure of the remaining elements.
     * @param {E} element - The `element` parameter represents the element that you want to delete from
     * the array `this.elements`.
     * @returns The `delete` function is returning a boolean value. It returns `true` if the element was
     * successfully deleted from the array, and `false` if the element was not found in the array.
     */
    delete(element) {
      const index = this.elements.indexOf(element);
      if (index < 0)
        return false;
      if (index === 0) {
        this.poll();
      } else if (index === this.elements.length - 1) {
        this.elements.pop();
      } else {
        this.elements.splice(index, 1, this.elements.pop());
        this._bubbleUp(index);
        this._sinkDown(index, this.elements.length >> 1);
      }
      return true;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * Depth-first search (DFS) method, different traversal orders can be selected
     * @param order - Traverse order parameter: 'IN' (in-order), 'PRE' (pre-order) or 'POST' (post-order).
     * @returns An array containing elements traversed in the specified order.
     */
    dfs(order = "PRE") {
      const result = [];
      const _dfs = (index) => {
        const left = 2 * index + 1, right = left + 1;
        if (index < this.size) {
          if (order === "IN") {
            _dfs(left);
            result.push(this.elements[index]);
            _dfs(right);
          } else if (order === "PRE") {
            result.push(this.elements[index]);
            _dfs(left);
            _dfs(right);
          } else if (order === "POST") {
            _dfs(left);
            _dfs(right);
            result.push(this.elements[index]);
          }
        }
      };
      _dfs(0);
      return result;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Convert the heap to an array.
     * @returns An array containing the elements of the heap.
     */
    toArray() {
      return [...this.elements];
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * Clone the heap, creating a new heap with the same elements.
     * @returns A new Heap instance containing the same elements.
     */
    clone() {
      return new _Heap(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * Sort the elements in the heap and return them as an array.
     * @returns An array containing the elements sorted in ascending order.
     */
    sort() {
      const visitedNode = [];
      const cloned = new _Heap(this, { comparator: this.comparator });
      while (cloned.size !== 0) {
        const top = cloned.poll();
        if (top !== void 0)
          visitedNode.push(top);
      }
      return visitedNode;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * Fix the entire heap to maintain heap properties.
     */
    fix() {
      const results = [];
      for (let i = Math.floor(this.size / 2); i >= 0; i--)
        results.push(this._sinkDown(i, this.elements.length >> 1));
      return results;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new Heap object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `Heap` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredList = new _Heap([], { toElementFn: this.toElementFn, comparator: this.comparator });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredList.add(current);
        }
        index++;
      }
      return filteredList;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `Heap` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedHeap = new _Heap([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedHeap.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedHeap;
    }
    /**
     * The function returns the value of the _comparator property.
     * @returns The `_comparator` property is being returned.
     */
    get comparator() {
      return this._comparator;
    }
    /**
     * The function `_getIterator` returns an iterable iterator for the elements in the class.
     */
    *_getIterator() {
      for (const element of this.elements) {
        yield element;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Float operation to maintain heap properties after adding an element.
     * @param index - The index of the newly added element.
     */
    _bubbleUp(index) {
      const element = this.elements[index];
      while (index > 0) {
        const parent = index - 1 >> 1;
        const parentItem = this.elements[parent];
        if (this.comparator(parentItem, element) <= 0)
          break;
        this.elements[index] = parentItem;
        index = parent;
      }
      this.elements[index] = element;
      return true;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Sinking operation to maintain heap properties after removing the top element.
     * @param index - The index from which to start sinking.
     * @param halfLength
     */
    _sinkDown(index, halfLength) {
      const element = this.elements[index];
      while (index < halfLength) {
        let left = index << 1 | 1;
        const right = left + 1;
        let minItem = this.elements[left];
        if (right < this.elements.length && this.comparator(minItem, this.elements[right]) > 0) {
          left = right;
          minItem = this.elements[right];
        }
        if (this.comparator(minItem, element) >= 0)
          break;
        this.elements[index] = minItem;
        index = left;
      }
      this.elements[index] = element;
      return true;
    }
  };
  var FibonacciHeapNode = class {
    /**
     * The constructor function initializes an object with an element and a degree, and sets the marked
     * property to false.
     * @param {E} element - The "element" parameter represents the value or data that will be stored in
     * the node of a data structure. It can be any type of data, such as a number, string, object, or
     * even another data structure.
     * @param [degree=0] - The degree parameter represents the degree of the element in a data structure
     * called a Fibonacci heap. The degree of a node is the number of children it has. By default, the
     * degree is set to 0 when a new node is created.
     */
    constructor(element, degree = 0) {
      __publicField(this, "element");
      __publicField(this, "degree");
      __publicField(this, "left");
      __publicField(this, "right");
      __publicField(this, "child");
      __publicField(this, "parent");
      __publicField(this, "marked");
      this.element = element;
      this.degree = degree;
      this.marked = false;
    }
  };
  var FibonacciHeap = class {
    /**
     * The constructor function initializes a FibonacciHeap object with an optional comparator function.
     * @param [comparator] - The `comparator` parameter is an optional argument that represents a
     * function used to compare elements in the FibonacciHeap. If a comparator function is provided, it
     * will be used to determine the order of elements in the heap. If no comparator function is
     * provided, a default comparator function will be used.
     */
    constructor(comparator) {
      __publicField(this, "_root");
      __publicField(this, "_size", 0);
      __publicField(this, "_min");
      __publicField(this, "_comparator");
      this.clear();
      this._comparator = comparator || this._defaultComparator;
      if (typeof this.comparator !== "function") {
        throw new Error("FibonacciHeap constructor: given comparator should be a function.");
      }
    }
    /**
     * The function returns the root node of a Fibonacci heap.
     * @returns The method is returning either a FibonacciHeapNode object or undefined.
     */
    get root() {
      return this._root;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
      return this._size;
    }
    /**
     * The function returns the minimum node in a Fibonacci heap.
     * @returns The method is returning the minimum node of the Fibonacci heap, which is of type
     * `FibonacciHeapNode<E>`. If there is no minimum node, it will return `undefined`.
     */
    get min() {
      return this._min;
    }
    /**
     * The function returns the comparator used for comparing elements.
     * @returns The `_comparator` property of the object.
     */
    get comparator() {
      return this._comparator;
    }
    /**
     * Get the size (number of elements) of the heap.
     * @returns {number} The size of the heap.  Returns 0 if the heap is empty. Returns -1 if the heap is invalid.
     */
    clear() {
      this._root = void 0;
      this._min = void 0;
      this._size = 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element
     * @returns {FibonacciHeap<E>} FibonacciHeap<E> - The heap itself.
     */
    add(element) {
      return this.push(element);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Insert an element into the heap and maintain the heap properties.
     * @param element
     * @returns {FibonacciHeap<E>} FibonacciHeap<E> - The heap itself.
     */
    push(element) {
      const node = this.createNode(element);
      node.left = node;
      node.right = node;
      this.mergeWithRoot(node);
      if (!this.min || this.comparator(node.element, this.min.element) <= 0) {
        this._min = node;
      }
      this._size++;
      return this;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Peek at the top element of the heap without removing it.
     * @returns The top element or undefined if the heap is empty.
     * @protected
     */
    peek() {
      return this.min ? this.min.element : void 0;
    }
    /**
     * Time Complexity: O(n), where n is the number of elements in the linked list.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n), where n is the number of elements in the linked list.
     * Space Complexity: O(1)
     *
     * Get the size (number of elements) of the heap.
     * @param {FibonacciHeapNode<E>} head - The head of the linked list.
     * @protected
     * @returns FibonacciHeapNode<E>[] - An array containing the elements of the linked list.
     */
    consumeLinkedList(head) {
      const elements = [];
      if (!head)
        return elements;
      let node = head;
      let flag = false;
      while (true) {
        if (node === head && flag)
          break;
        else if (node === head)
          flag = true;
        if (node) {
          elements.push(node);
          node = node.right;
        }
      }
      return elements;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * @param parent
     * @param node
     */
    mergeWithChild(parent, node) {
      if (!parent.child) {
        parent.child = node;
      } else {
        node.right = parent.child.right;
        node.left = parent.child;
        parent.child.right.left = node;
        parent.child.right = node;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    poll() {
      return this.pop();
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @returns The top element or undefined if the heap is empty.
     */
    pop() {
      if (this.size === 0)
        return void 0;
      const z = this.min;
      if (z.child) {
        const elements = this.consumeLinkedList(z.child);
        for (const node of elements) {
          this.mergeWithRoot(node);
          node.parent = void 0;
        }
      }
      this.removeFromRoot(z);
      if (z === z.right) {
        this._min = void 0;
        this._root = void 0;
      } else {
        this._min = z.right;
        this._consolidate();
      }
      this._size--;
      return z.element;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * merge two heaps. The heap that is merged will be cleared. The heap that is merged into will remain.
     * @param heapToMerge
     */
    merge(heapToMerge) {
      if (heapToMerge.size === 0) {
        return;
      }
      if (this.root && heapToMerge.root) {
        const thisRoot = this.root;
        const otherRoot = heapToMerge.root;
        const thisRootRight = thisRoot.right;
        const otherRootLeft = otherRoot.left;
        thisRoot.right = otherRoot;
        otherRoot.left = thisRoot;
        thisRootRight.left = otherRootLeft;
        otherRootLeft.right = thisRootRight;
      }
      if (!this.min || heapToMerge.min && this.comparator(heapToMerge.min.element, this.min.element) < 0) {
        this._min = heapToMerge.min;
      }
      this._size += heapToMerge.size;
      heapToMerge.clear();
    }
    /**
     * Create a new node.
     * @param element
     * @protected
     */
    createNode(element) {
      return new FibonacciHeapNode(element);
    }
    /**
     * Default comparator function used by the heap.
     * @param {E} a
     * @param {E} b
     * @protected
     */
    _defaultComparator(a, b) {
      if (a < b)
        return -1;
      if (a > b)
        return 1;
      return 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Merge the given node with the root list.
     * @param node - The node to be merged.
     */
    mergeWithRoot(node) {
      if (!this.root) {
        this._root = node;
      } else {
        node.right = this.root.right;
        node.left = this.root;
        this.root.right.left = node;
        this.root.right = node;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @param node - The node to be removed.
     * @protected
     */
    removeFromRoot(node) {
      if (this.root === node)
        this._root = node.right;
      if (node.left)
        node.left.right = node.right;
      if (node.right)
        node.right.left = node.left;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @param y
     * @param x
     * @protected
     */
    _link(y, x) {
      this.removeFromRoot(y);
      y.left = y;
      y.right = y;
      this.mergeWithChild(x, y);
      x.degree++;
      y.parent = x;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * Remove and return the top element (the smallest or largest element) from the heap.
     * @protected
     */
    _consolidate() {
      const A = new Array(this.size);
      const elements = this.consumeLinkedList(this.root);
      let x, y, d, t;
      for (const node of elements) {
        x = node;
        d = x.degree;
        while (A[d]) {
          y = A[d];
          if (this.comparator(x.element, y.element) > 0) {
            t = x;
            x = y;
            y = t;
          }
          this._link(y, x);
          A[d] = void 0;
          d++;
        }
        A[d] = x;
      }
      for (let i = 0; i < this.size; i++) {
        if (A[i] && this.comparator(A[i].element, this.min.element) <= 0) {
          this._min = A[i];
        }
      }
    }
  };

  // src/data-structures/heap/max-heap.ts
  var MaxHeap = class _MaxHeap extends Heap {
    constructor(elements = [], options) {
      super(elements, __spreadValues({
        comparator: (a, b) => {
          if (typeof a === "object" || typeof b === "object") {
            throw TypeError(
              `When comparing object types, a custom comparator must be defined in the constructor's options parameter.`
            );
          }
          if (a < b)
            return 1;
          if (a > b)
            return -1;
          return 0;
        }
      }, options));
    }
    /**
     * The `clone` function returns a new instance of the `MaxHeap` class with the same properties as the
     * current instance.
     * @returns The `clone()` method is returning a new instance of the `MaxHeap` class with the same
     * properties as the current instance.
     */
    clone() {
      return new _MaxHeap(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new MaxHeap object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `MaxHeap` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredList = new _MaxHeap([], { toElementFn: this.toElementFn, comparator: this.comparator });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredList.add(current);
        }
        index++;
      }
      return filteredList;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `MaxHeap` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedHeap = new _MaxHeap([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedHeap.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedHeap;
    }
  };

  // src/data-structures/heap/min-heap.ts
  var MinHeap = class _MinHeap extends Heap {
    constructor(elements = [], options) {
      super(elements, options);
    }
    /**
     * The `clone` function returns a new instance of the `MinHeap` class with the same comparator and
     * toElementFn as the original instance.
     * @returns The `clone()` method is returning a new instance of the `MinHeap` class with the same
     * properties as the current instance.
     */
    clone() {
      return new _MinHeap(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new MinHeap object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `MinHeap` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredList = new _MinHeap([], { toElementFn: this.toElementFn, comparator: this.comparator });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredList.add(current);
        }
        index++;
      }
      return filteredList;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `MinHeap` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedHeap = new _MinHeap([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedHeap.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedHeap;
    }
  };

  // src/data-structures/graph/abstract-graph.ts
  var AbstractVertex = class {
    /**
     * The function is a protected constructor that takes an key and an optional value as parameters.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is
     * used to uniquely identify the vertex object.
     * @param {V} [value] - The parameter "value" is an optional parameter of type V. It is used to assign a value to the
     * vertex. If no value is provided, it will be set to undefined.
     */
    constructor(key, value) {
      __publicField(this, "key");
      __publicField(this, "value");
      this.key = key;
      this.value = value;
    }
  };
  var AbstractEdge = class {
    /**
     * The above function is a protected constructor that initializes the weight, value, and hash code properties of an
     * object.
     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the object. If
     * a value is provided, it will be assigned to the `_weight` property. If no value is provided, the default value of 1
     * will be assigned.
     * @param {VO} [value] - The `value` parameter is of type `VO`, which means it can be any type. It is an optional parameter,
     * meaning it can be omitted when creating an instance of the class.
     */
    constructor(weight, value) {
      __publicField(this, "value");
      __publicField(this, "weight");
      __publicField(this, "_hashCode");
      this.weight = weight !== void 0 ? weight : 1;
      this.value = value;
      this._hashCode = uuidV4();
    }
    get hashCode() {
      return this._hashCode;
    }
    /**
     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.
     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.
     */
  };
  var AbstractGraph = class extends IterableEntryBase {
    constructor() {
      super();
      __publicField(this, "_vertexMap", /* @__PURE__ */ new Map());
    }
    get vertexMap() {
      return this._vertexMap;
    }
    set vertexMap(v) {
      this._vertexMap = v;
    }
    get size() {
      return this._vertexMap.size;
    }
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function "getVertex" returns the vertex with the specified ID or undefined if it doesn't exist.
     * @param {VertexKey} vertexKey - The `vertexKey` parameter is the identifier of the vertex that you want to retrieve from
     * the `_vertexMap` map.
     * @returns The method `getVertex` returns the vertex with the specified `vertexKey` if it exists in the `_vertexMap`
     * map. If the vertex does not exist, it returns `undefined`.
     */
    getVertex(vertexKey) {
      return this._vertexMap.get(vertexKey) || void 0;
    }
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map lookup.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function checks if a vertex exists in a graph.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns a boolean value.
     */
    hasVertex(vertexOrKey) {
      return this._vertexMap.has(this._getVertexKey(vertexOrKey));
    }
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    addVertex(keyOrVertex, value) {
      if (keyOrVertex instanceof AbstractVertex) {
        return this._addVertex(keyOrVertex);
      } else {
        const newVertex = this.createVertex(keyOrVertex, value);
        return this._addVertex(newVertex);
      }
    }
    isVertexKey(potentialKey) {
      const potentialKeyType = typeof potentialKey;
      return potentialKeyType === "string" || potentialKeyType === "number";
    }
    /**
     * Time Complexity: O(K), where K is the number of vertexMap to be removed.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(K), where K is the number of vertexMap to be removed.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function removes all vertexMap from a graph and returns a boolean indicating if any vertexMap were removed.
     * @param {VO[] | VertexKey[]} vertexMap - The `vertexMap` parameter can be either an array of vertexMap (`VO[]`) or an array
     * of vertex IDs (`VertexKey[]`).
     * @returns a boolean value. It returns true if at least one vertex was successfully removed, and false if no vertexMap
     * were removed.
     */
    removeManyVertices(vertexMap) {
      const removed = [];
      for (const v of vertexMap) {
        removed.push(this.deleteVertex(v));
      }
      return removed.length > 0;
    }
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     */
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     *
     * The function checks if there is an edge between two vertexMap and returns a boolean value indicating the result.
     * @param {VertexKey | VO} v1 - The parameter v1 can be either a VertexKey or a VO. A VertexKey represents the unique
     * identifier of a vertex in a graph, while VO represents the type of the vertex object itself.
     * @param {VertexKey | VO} v2 - The parameter `v2` represents the second vertex in the edge. It can be either a
     * `VertexKey` or a `VO` type, which represents the type of the vertex.
     * @returns A boolean value is being returned.
     */
    hasEdge(v1, v2) {
      const edge = this.getEdge(v1, v2);
      return !!edge;
    }
    /**
     * Time Complexity: O(1) - Depends on the implementation in the concrete class.
     * Space Complexity: O(1) - Depends on the implementation in the concrete class.
     */
    addEdge(srcOrEdge, dest, weight, value) {
      if (srcOrEdge instanceof AbstractEdge) {
        return this._addEdge(srcOrEdge);
      } else {
        if (dest instanceof AbstractVertex || typeof dest === "string" || typeof dest === "number") {
          if (!(this.hasVertex(srcOrEdge) && this.hasVertex(dest)))
            return false;
          if (srcOrEdge instanceof AbstractVertex)
            srcOrEdge = srcOrEdge.key;
          if (dest instanceof AbstractVertex)
            dest = dest.key;
          const newEdge = this.createEdge(srcOrEdge, dest, weight, value);
          return this._addEdge(newEdge);
        } else {
          throw new Error("dest must be a Vertex or vertex key while srcOrEdge is an Edge");
        }
      }
    }
    /**
     * Time Complexity: O(1) - Constant time for Map and Edge operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map and Edge operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The function sets the weight of an edge between two vertexMap in a graph.
     * @param {VertexKey | VO} srcOrKey - The `srcOrKey` parameter can be either a `VertexKey` or a `VO` object. It represents
     * the source vertex of the edge.
     * @param {VertexKey | VO} destOrKey - The `destOrKey` parameter represents the destination vertex of the edge. It can be
     * either a `VertexKey` or a vertex object `VO`.
     * @param {number} weight - The weight parameter represents the weight of the edge between the source vertex (srcOrKey)
     * and the destination vertex (destOrKey).
     * @returns a boolean value. If the edge exists between the source and destination vertexMap, the function will update
     * the weight of the edge and return true. If the edge does not exist, the function will return false.
     */
    setEdgeWeight(srcOrKey, destOrKey, weight) {
      const edge = this.getEdge(srcOrKey, destOrKey);
      if (edge) {
        edge.weight = weight;
        return true;
      } else {
        return false;
      }
    }
    /**
     * Time Complexity: O(P), where P is the number of paths found (in the worst case, exploring all paths).
     * Space Complexity: O(P) - Linear space, where P is the number of paths found.
     */
    /**
     * Time Complexity: O(P), where P is the number of paths found (in the worst case, exploring all paths).
     * Space Complexity: O(P) - Linear space, where P is the number of paths found.
     *
     * The function `getAllPathsBetween` finds all paths between two vertexMap in a graph using depth-first search.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents either a vertex object (`VO`) or a vertex ID (`VertexKey`).
     * It is the starting vertex for finding paths.
     * @param {VO | VertexKey} v2 - The parameter `v2` represents either a vertex object (`VO`) or a vertex ID (`VertexKey`).
     * @param limit - The count of limitation of result array.
     * @returns The function `getAllPathsBetween` returns an array of arrays of vertexMap (`VO[][]`).
     */
    getAllPathsBetween(v1, v2, limit = 1e3) {
      const paths = [];
      const vertex1 = this._getVertex(v1);
      const vertex2 = this._getVertex(v2);
      if (!(vertex1 && vertex2)) {
        return [];
      }
      const stack = [];
      stack.push({ vertex: vertex1, path: [vertex1] });
      while (stack.length > 0) {
        const { vertex, path } = stack.pop();
        if (vertex === vertex2) {
          paths.push(path);
          if (paths.length >= limit)
            return paths;
        }
        const neighbors = this.getNeighbors(vertex);
        for (const neighbor of neighbors) {
          if (!path.includes(neighbor)) {
            const newPath = [...path, neighbor];
            stack.push({ vertex: neighbor, path: newPath });
          }
        }
      }
      return paths;
    }
    /**
     * Time Complexity: O(L), where L is the length of the path.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(L), where L is the length of the path.
     * Space Complexity: O(1) - Constant space.
     *
     * The function calculates the sum of weights along a given path.
     * @param {VO[]} path - An array of vertexMap (VO) representing a path in a graph.
     * @returns The function `getPathSumWeight` returns the sum of the weights of the edgeMap in the given path.
     */
    getPathSumWeight(path) {
      var _a;
      let sum = 0;
      for (let i = 0; i < path.length; i++) {
        sum += ((_a = this.getEdge(path[i], path[i + 1])) == null ? void 0 : _a.weight) || 0;
      }
      return sum;
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     *
     * The function `getMinCostBetween` calculates the minimum cost between two vertexMap in a graph, either based on edge
     * weights or using a breadth-first search algorithm.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents the starting vertex or its ID.
     * @param {VO | VertexKey} v2 - The parameter `v2` represents the destination vertex or its ID. It is the vertex to which
     * you want to find the minimum cost or weight from the source vertex `v1`.
     * @param {boolean} [isWeight] - isWeight is an optional parameter that indicates whether the graph edgeMap have weights.
     * If isWeight is set to true, the function will calculate the minimum cost between v1 and v2 based on the weights of
     * the edgeMap. If isWeight is set to false or not provided, the function will calculate the
     * @returns The function `getMinCostBetween` returns a number representing the minimum cost between two vertexMap (`v1`
     * and `v2`). If the `isWeight` parameter is `true`, it calculates the minimum weight among all paths between the
     * vertexMap. If `isWeight` is `false` or not provided, it uses a breadth-first search (BFS) algorithm to calculate the
     * minimum number of
     */
    getMinCostBetween(v1, v2, isWeight) {
      if (isWeight === void 0)
        isWeight = false;
      if (isWeight) {
        const allPaths = this.getAllPathsBetween(v1, v2);
        let min = Infinity;
        for (const path of allPaths) {
          min = Math.min(this.getPathSumWeight(path), min);
        }
        return min;
      } else {
        const vertex2 = this._getVertex(v2);
        const vertex1 = this._getVertex(v1);
        if (!(vertex1 && vertex2)) {
          return void 0;
        }
        const visited = /* @__PURE__ */ new Map();
        const queue = new Queue([vertex1]);
        visited.set(vertex1, true);
        let cost = 0;
        while (queue.size > 0) {
          for (let i = 0; i < queue.size; i++) {
            const cur = queue.shift();
            if (cur === vertex2) {
              return cost;
            }
            if (cur !== void 0) {
              const neighbors = this.getNeighbors(cur);
              for (const neighbor of neighbors) {
                if (!visited.has(neighbor)) {
                  visited.set(neighbor, true);
                  queue.push(neighbor);
                }
              }
            }
          }
          cost++;
        }
        return void 0;
      }
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm or DFS).
     *
     * The function `getMinPathBetween` returns the minimum path between two vertexMap in a graph, either based on weight or
     * using a breadth-first search algorithm.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents the starting vertex of the path. It can be either a vertex
     * object (`VO`) or a vertex ID (`VertexKey`).
     * @param {VO | VertexKey} v2 - VO | VertexKey - The second vertex or vertex ID between which we want to find the minimum
     * path.
     * @param {boolean} [isWeight] - A boolean flag indicating whether to consider the weight of edgeMap in finding the
     * minimum path. If set to true, the function will use Dijkstra's algorithm to find the minimum weighted path. If set
     * to false, the function will use breadth-first search (BFS) to find the minimum path.
     * @param isDFS - If set to true, it enforces the use of getAllPathsBetween to first obtain all possible paths,
     * followed by iterative computation of the shortest path. This approach may result in exponential time complexity,
     * so the default method is to use the Dijkstra algorithm to obtain the shortest weighted path.
     * @returns The function `getMinPathBetween` returns an array of vertexMap (`VO[]`) representing the minimum path between
     * two vertexMap (`v1` and `v2`). If there is no path between the vertexMap, it returns `undefined`.
     */
    getMinPathBetween(v1, v2, isWeight, isDFS = false) {
      var _a, _b;
      if (isWeight === void 0)
        isWeight = false;
      if (isWeight) {
        if (isDFS) {
          const allPaths = this.getAllPathsBetween(v1, v2, 1e4);
          let min = Infinity;
          let minIndex = -1;
          let index = 0;
          for (const path of allPaths) {
            const pathSumWeight = this.getPathSumWeight(path);
            if (pathSumWeight < min) {
              min = pathSumWeight;
              minIndex = index;
            }
            index++;
          }
          return allPaths[minIndex] || void 0;
        } else {
          return (_b = (_a = this.dijkstra(v1, v2, true, true)) == null ? void 0 : _a.minPath) != null ? _b : [];
        }
      } else {
        let minPath = [];
        const vertex1 = this._getVertex(v1);
        const vertex2 = this._getVertex(v2);
        if (!(vertex1 && vertex2))
          return [];
        const dfs = (cur, dest, visiting, path) => {
          visiting.add(cur);
          if (cur === dest) {
            minPath = [vertex1, ...path];
            return;
          }
          const neighbors = this.getNeighbors(cur);
          for (const neighbor of neighbors) {
            if (!visiting.has(neighbor)) {
              path.push(neighbor);
              dfs(neighbor, dest, visiting, path);
              path.pop();
            }
          }
          visiting.delete(cur);
        };
        dfs(vertex1, vertex2, /* @__PURE__ */ new Set(), []);
        return minPath;
      }
    }
    /**
     *  Dijkstra algorithm time: O(VE) space: O(VO + EO)
     */
    /**
     * Time Complexity: O(V^2 + E) - Quadratic time in the worst case (no heap optimization).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     */
    /**
     * Time Complexity: O(V^2 + E) - Quadratic time in the worst case (no heap optimization).
     * Space Complexity: O(V + E) - Depends on the implementation (Dijkstra's algorithm).
     *
     * The function `dijkstraWithoutHeap` implements Dijkstra's algorithm to find the shortest path between two vertexMap in
     * a graph without using a heap data structure.
     * @param {VO | VertexKey} src - The source vertex from which to start the Dijkstra's algorithm. It can be either a
     * vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} [dest] - The `dest` parameter in the `dijkstraWithoutHeap` function is an optional
     * parameter that specifies the destination vertex for the Dijkstra algorithm. It can be either a vertex object or its
     * identifier. If no destination is provided, the value is set to `undefined`.
     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum
     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If
     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance
     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate
     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the
     * shortest paths from the source vertex to all other vertexMap in the graph. If `genPaths
     * @returns The function `dijkstraWithoutHeap` returns an object of type `DijkstraResult<VO>`.
     */
    dijkstraWithoutHeap(src, dest = void 0, getMinDist = false, genPaths = false) {
      let minDist = Infinity;
      let minDest = void 0;
      let minPath = [];
      const paths = [];
      const vertexMap = this._vertexMap;
      const distMap = /* @__PURE__ */ new Map();
      const seen = /* @__PURE__ */ new Set();
      const preMap = /* @__PURE__ */ new Map();
      const srcVertex = this._getVertex(src);
      const destVertex = dest ? this._getVertex(dest) : void 0;
      if (!srcVertex) {
        return void 0;
      }
      for (const vertex of vertexMap) {
        const vertexOrKey = vertex[1];
        if (vertexOrKey instanceof AbstractVertex)
          distMap.set(vertexOrKey, Infinity);
      }
      distMap.set(srcVertex, 0);
      preMap.set(srcVertex, void 0);
      const getMinOfNoSeen = () => {
        let min = Infinity;
        let minV = void 0;
        for (const [key, value] of distMap) {
          if (!seen.has(key)) {
            if (value < min) {
              min = value;
              minV = key;
            }
          }
        }
        return minV;
      };
      const getPaths = (minV) => {
        for (const vertex of vertexMap) {
          const vertexOrKey = vertex[1];
          if (vertexOrKey instanceof AbstractVertex) {
            const path = [vertexOrKey];
            let parent = preMap.get(vertexOrKey);
            while (parent) {
              path.push(parent);
              parent = preMap.get(parent);
            }
            const reversed = path.reverse();
            if (vertex[1] === minV)
              minPath = reversed;
            paths.push(reversed);
          }
        }
      };
      for (let i = 1; i < vertexMap.size; i++) {
        const cur = getMinOfNoSeen();
        if (cur) {
          seen.add(cur);
          if (destVertex && destVertex === cur) {
            if (getMinDist) {
              minDist = distMap.get(destVertex) || Infinity;
            }
            if (genPaths) {
              getPaths(destVertex);
            }
            return { distMap, preMap, seen, paths, minDist, minPath };
          }
          const neighbors = this.getNeighbors(cur);
          for (const neighbor of neighbors) {
            if (!seen.has(neighbor)) {
              const edge = this.getEdge(cur, neighbor);
              if (edge) {
                const curFromMap = distMap.get(cur);
                const neighborFromMap = distMap.get(neighbor);
                if (curFromMap !== void 0 && neighborFromMap !== void 0) {
                  if (edge.weight + curFromMap < neighborFromMap) {
                    distMap.set(neighbor, edge.weight + curFromMap);
                    preMap.set(neighbor, cur);
                  }
                }
              }
            }
          }
        }
      }
      getMinDist && distMap.forEach((d, v) => {
        if (v !== srcVertex) {
          if (d < minDist) {
            minDist = d;
            if (genPaths)
              minDest = v;
          }
        }
      });
      genPaths && getPaths(minDest);
      return { distMap, preMap, seen, paths, minDist, minPath };
    }
    /**
     *  Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     *
     * Dijkstra's algorithm only solves the single-source shortest path problem, while the Bellman-Ford algorithm and Floyd-Warshall algorithm can address shortest paths between all pairs of nodes.
     * Dijkstra's algorithm is suitable for graphs with non-negative edge weights, whereas the Bellman-Ford algorithm and Floyd-Warshall algorithm can handle negative-weight edgeMap.
     * The time complexity of Dijkstra's algorithm and the Bellman-Ford algorithm depends on the size of the graph, while the time complexity of the Floyd-Warshall algorithm is O(VO^3), where VO is the number of nodes. For dense graphs, Floyd-Warshall might become slower.
     *
     */
    /**
     * Time Complexity: O((V + E) * log(V)) - Depends on the implementation (using a binary heap).
     * Space Complexity: O(V + E) - Depends on the implementation (using a binary heap).
     */
    /**
     * Time Complexity: O((V + E) * log(V)) - Depends on the implementation (using a binary heap).
     * Space Complexity: O(V + E) - Depends on the implementation (using a binary heap).
     *
     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.
     * The `dijkstra` function implements Dijkstra's algorithm to find the shortest path between a source vertex and an
     * optional destination vertex, and optionally returns the minimum distance, the paths, and other information.
     * @param {VO | VertexKey} src - The `src` parameter represents the source vertex from which the Dijkstra algorithm will
     * start. It can be either a vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} [dest] - The `dest` parameter is the destination vertex or vertex ID. It specifies the
     * vertex to which the shortest path is calculated from the source vertex. If no destination is provided, the algorithm
     * will calculate the shortest paths to all other vertexMap from the source vertex.
     * @param {boolean} [getMinDist] - The `getMinDist` parameter is a boolean flag that determines whether the minimum
     * distance from the source vertex to the destination vertex should be calculated and returned in the result. If
     * `getMinDist` is set to `true`, the `minDist` property in the result will contain the minimum distance
     * @param {boolean} [genPaths] - The `genPaths` parameter is a boolean flag that determines whether or not to generate
     * paths in the Dijkstra algorithm. If `genPaths` is set to `true`, the algorithm will calculate and return the
     * shortest paths from the source vertex to all other vertexMap in the graph. If `genPaths
     * @returns The function `dijkstra` returns an object of type `DijkstraResult<VO>`.
     */
    dijkstra(src, dest = void 0, getMinDist = false, genPaths = false) {
      var _a;
      let minDist = Infinity;
      let minDest = void 0;
      let minPath = [];
      const paths = [];
      const vertexMap = this._vertexMap;
      const distMap = /* @__PURE__ */ new Map();
      const seen = /* @__PURE__ */ new Set();
      const preMap = /* @__PURE__ */ new Map();
      const srcVertex = this._getVertex(src);
      const destVertex = dest ? this._getVertex(dest) : void 0;
      if (!srcVertex)
        return void 0;
      for (const vertex of vertexMap) {
        const vertexOrKey = vertex[1];
        if (vertexOrKey instanceof AbstractVertex)
          distMap.set(vertexOrKey, Infinity);
      }
      const heap = new Heap([], { comparator: (a, b) => a.key - b.key });
      heap.add({ key: 0, value: srcVertex });
      distMap.set(srcVertex, 0);
      preMap.set(srcVertex, void 0);
      const getPaths = (minV) => {
        for (const vertex of vertexMap) {
          const vertexOrKey = vertex[1];
          if (vertexOrKey instanceof AbstractVertex) {
            const path = [vertexOrKey];
            let parent = preMap.get(vertexOrKey);
            while (parent) {
              path.push(parent);
              parent = preMap.get(parent);
            }
            const reversed = path.reverse();
            if (vertex[1] === minV)
              minPath = reversed;
            paths.push(reversed);
          }
        }
      };
      while (heap.size > 0) {
        const curHeapNode = heap.poll();
        const dist = curHeapNode == null ? void 0 : curHeapNode.key;
        const cur = curHeapNode == null ? void 0 : curHeapNode.value;
        if (dist !== void 0) {
          if (cur) {
            seen.add(cur);
            if (destVertex && destVertex === cur) {
              if (getMinDist) {
                minDist = distMap.get(destVertex) || Infinity;
              }
              if (genPaths) {
                getPaths(destVertex);
              }
              return { distMap, preMap, seen, paths, minDist, minPath };
            }
            const neighbors = this.getNeighbors(cur);
            for (const neighbor of neighbors) {
              if (!seen.has(neighbor)) {
                const weight = (_a = this.getEdge(cur, neighbor)) == null ? void 0 : _a.weight;
                if (typeof weight === "number") {
                  const distSrcToNeighbor = distMap.get(neighbor);
                  if (distSrcToNeighbor) {
                    if (dist + weight < distSrcToNeighbor) {
                      heap.add({ key: dist + weight, value: neighbor });
                      preMap.set(neighbor, cur);
                      distMap.set(neighbor, dist + weight);
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (getMinDist) {
        distMap.forEach((d, v) => {
          if (v !== srcVertex) {
            if (d < minDist) {
              minDist = d;
              if (genPaths)
                minDest = v;
            }
          }
        });
      }
      if (genPaths) {
        getPaths(minDest);
      }
      return { distMap, preMap, seen, paths, minDist, minPath };
    }
    /**
     * Time Complexity: O(V * E) - Quadratic time in the worst case (Bellman-Ford algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Bellman-Ford algorithm).
     * one to rest pairs
     */
    /**
     * Time Complexity: O(V * E) - Quadratic time in the worst case (Bellman-Ford algorithm).
     * Space Complexity: O(V + E) - Depends on the implementation (Bellman-Ford algorithm).
     *
     * one to rest pairs
     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edgeMap for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edgeMap, the Bellman-Ford algorithm is more flexible in some scenarios.
     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to
     * all other vertexMap in a graph, and optionally detects negative cycles and generates the minimum path.
     * @param {VO | VertexKey} src - The `src` parameter is the source vertex from which the Bellman-Ford algorithm will
     * start calculating the shortest paths. It can be either a vertex object or a vertex ID.
     * @param {boolean} [scanNegativeCycle] - A boolean flag indicating whether to scan for negative cycles in the graph.
     * @param {boolean} [getMin] - The `getMin` parameter is a boolean flag that determines whether the algorithm should
     * calculate the minimum distance from the source vertex to all other vertexMap in the graph. If `getMin` is set to
     * `true`, the algorithm will find the minimum distance and update the `min` variable with the minimum
     * @param {boolean} [genPath] - A boolean flag indicating whether to generate paths for all vertexMap from the source
     * vertex.
     * @returns The function `bellmanFord` returns an object with the following properties:
     */
    bellmanFord(src, scanNegativeCycle, getMin, genPath) {
      if (getMin === void 0)
        getMin = false;
      if (genPath === void 0)
        genPath = false;
      const srcVertex = this._getVertex(src);
      const paths = [];
      const distMap = /* @__PURE__ */ new Map();
      const preMap = /* @__PURE__ */ new Map();
      let min = Infinity;
      let minPath = [];
      let hasNegativeCycle;
      if (scanNegativeCycle)
        hasNegativeCycle = false;
      if (!srcVertex)
        return { hasNegativeCycle, distMap, preMap, paths, min, minPath };
      const vertexMap = this._vertexMap;
      const numOfVertices = vertexMap.size;
      const edgeMap = this.edgeSet();
      const numOfEdges = edgeMap.length;
      this._vertexMap.forEach((vertex) => {
        distMap.set(vertex, Infinity);
      });
      distMap.set(srcVertex, 0);
      for (let i = 1; i < numOfVertices; ++i) {
        for (let j = 0; j < numOfEdges; ++j) {
          const ends = this.getEndsOfEdge(edgeMap[j]);
          if (ends) {
            const [s, d] = ends;
            const weight = edgeMap[j].weight;
            const sWeight = distMap.get(s);
            const dWeight = distMap.get(d);
            if (sWeight !== void 0 && dWeight !== void 0) {
              if (distMap.get(s) !== Infinity && sWeight + weight < dWeight) {
                distMap.set(d, sWeight + weight);
                genPath && preMap.set(d, s);
              }
            }
          }
        }
      }
      let minDest = void 0;
      if (getMin) {
        distMap.forEach((d, v) => {
          if (v !== srcVertex) {
            if (d < min) {
              min = d;
              if (genPath)
                minDest = v;
            }
          }
        });
      }
      if (genPath) {
        for (const vertex of vertexMap) {
          const vertexOrKey = vertex[1];
          if (vertexOrKey instanceof AbstractVertex) {
            const path = [vertexOrKey];
            let parent = preMap.get(vertexOrKey);
            while (parent !== void 0) {
              path.push(parent);
              parent = preMap.get(parent);
            }
            const reversed = path.reverse();
            if (vertex[1] === minDest)
              minPath = reversed;
            paths.push(reversed);
          }
        }
      }
      for (let j = 0; j < numOfEdges; ++j) {
        const ends = this.getEndsOfEdge(edgeMap[j]);
        if (ends) {
          const [s] = ends;
          const weight = edgeMap[j].weight;
          const sWeight = distMap.get(s);
          if (sWeight) {
            if (sWeight !== Infinity && sWeight + weight < sWeight)
              hasNegativeCycle = true;
          }
        }
      }
      return { hasNegativeCycle, distMap, preMap, paths, min, minPath };
    }
    /**
     * Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     */
    /**
     * Dijkstra algorithm time: O(logVE) space: O(VO + EO)
     * Dijkstra's algorithm is used to find the shortest paths from a source node to all other nodes in a graph. Its basic idea is to repeatedly choose the node closest to the source node and update the distances of other nodes using this node as an intermediary. Dijkstra's algorithm requires that the edge weights in the graph are non-negative.
     */
    /**
     * BellmanFord time:O(VE) space:O(VO)
     * one to rest pairs
     * The Bellman-Ford algorithm is also used to find the shortest paths from a source node to all other nodes in a graph. Unlike Dijkstra's algorithm, it can handle edge weights that are negative. Its basic idea involves iterative relaxation of all edgeMap for several rounds to gradually approximate the shortest paths. Due to its ability to handle negative-weight edgeMap, the Bellman-Ford algorithm is more flexible in some scenarios.
     * The `bellmanFord` function implements the Bellman-Ford algorithm to find the shortest path from a source vertex to
     */
    /**
     * Time Complexity: O(V^3) - Cubic time (Floyd-Warshall algorithm).
     * Space Complexity: O(V^2) - Quadratic space (Floyd-Warshall algorithm).
     * Not support graph with negative weight cycle
     * all pairs
     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edgeMap, and it can simultaneously compute shortest paths between any two nodes.
     */
    /**
     * Time Complexity: O(V^3) - Cubic time (Floyd-Warshall algorithm).
     * Space Complexity: O(V^2) - Quadratic space (Floyd-Warshall algorithm).
     *
     * Not support graph with negative weight cycle
     * all pairs
     * The Floyd-Warshall algorithm is used to find the shortest paths between all pairs of nodes in a graph. It employs dynamic programming to compute the shortest paths from any node to any other node. The Floyd-Warshall algorithm's advantage lies in its ability to handle graphs with negative-weight edgeMap, and it can simultaneously compute shortest paths between any two nodes.
     * The function implements the Floyd-Warshall algorithm to find the shortest path between all pairs of vertexMap in a
     * graph.
     * @returns The function `floydWarshall()` returns an object with two properties: `costs` and `predecessor`. The `costs`
     * property is a 2D array of numbers representing the shortest path costs between vertexMap in a graph. The
     * `predecessor` property is a 2D array of vertexMap (or `undefined`) representing the predecessor vertexMap in the shortest
     * path between vertexMap in the
     */
    floydWarshall() {
      var _a;
      const idAndVertices = [...this._vertexMap];
      const n = idAndVertices.length;
      const costs = [];
      const predecessor = [];
      for (let i = 0; i < n; i++) {
        costs[i] = [];
        predecessor[i] = [];
        for (let j = 0; j < n; j++) {
          predecessor[i][j] = void 0;
        }
      }
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          costs[i][j] = ((_a = this.getEdge(idAndVertices[i][1], idAndVertices[j][1])) == null ? void 0 : _a.weight) || Infinity;
        }
      }
      for (let k = 0; k < n; k++) {
        for (let i = 0; i < n; i++) {
          for (let j = 0; j < n; j++) {
            if (costs[i][j] > costs[i][k] + costs[k][j]) {
              costs[i][j] = costs[i][k] + costs[k][j];
              predecessor[i][j] = idAndVertices[k][1];
            }
          }
        }
      }
      return { costs, predecessor };
    }
    /**
     * O(V+E+C)
     * O(V+C)
     */
    getCycles(isInclude2Cycle = false) {
      const cycles = [];
      const visited = /* @__PURE__ */ new Set();
      const dfs = (vertex, currentPath, visited2) => {
        if (visited2.has(vertex)) {
          if ((!isInclude2Cycle && currentPath.length > 2 || isInclude2Cycle && currentPath.length >= 2) && currentPath[0] === vertex.key) {
            cycles.push([...currentPath]);
          }
          return;
        }
        visited2.add(vertex);
        currentPath.push(vertex.key);
        for (const neighbor of this.getNeighbors(vertex)) {
          neighbor && dfs(neighbor, currentPath, visited2);
        }
        visited2.delete(vertex);
        currentPath.pop();
      };
      for (const vertex of this.vertexMap.values()) {
        dfs(vertex, [], visited);
      }
      const uniqueCycles = /* @__PURE__ */ new Map();
      for (const cycle of cycles) {
        const sorted = [...cycle].sort().toString();
        if (uniqueCycles.has(sorted))
          continue;
        else {
          uniqueCycles.set(sorted, cycle);
        }
      }
      return [...uniqueCycles].map((cycleString) => cycleString[1]);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function iterates over key-value pairs in a data structure and returns an array of
     * pairs that satisfy a given predicate.
     * @param predicate - The `predicate` parameter is a callback function that takes four arguments:
     * `value`, `key`, `index`, and `this`. It is used to determine whether an element should be included
     * in the filtered array. The callback function should return `true` if the element should be
     * included, and `
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. It is used when you want to bind a
     * specific object as the context for the `predicate` function. If `thisArg` is provided, it will be
     * @returns The `filter` method returns an array of key-value pairs `[VertexKey, V | undefined][]`
     * that satisfy the given predicate function.
     */
    filter(predicate, thisArg) {
      const filtered = [];
      let index = 0;
      for (const [key, value] of this) {
        if (predicate.call(thisArg, value, key, index, this)) {
          filtered.push([key, value]);
        }
        index++;
      }
      return filtered;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function iterates over the elements of a collection and applies a callback function to
     * each element, returning an array of the results.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * map. It takes four arguments:
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. If `thisArg` is provided, it will be
     * used as the `this` value when calling the callback function. If `thisArg` is not provided, `
     * @returns The `map` function is returning an array of type `T[]`.
     */
    map(callback, thisArg) {
      const mapped = [];
      let index = 0;
      for (const [key, value] of this) {
        mapped.push(callback.call(thisArg, value, key, index, this));
        index++;
      }
      return mapped;
    }
    *_getIterator() {
      for (const vertex of this._vertexMap.values()) {
        yield [vertex.key, vertex.value];
      }
    }
    _addVertex(newVertex) {
      if (this.hasVertex(newVertex)) {
        return false;
      }
      this._vertexMap.set(newVertex.key, newVertex);
      return true;
    }
    _getVertex(vertexOrKey) {
      const vertexKey = this._getVertexKey(vertexOrKey);
      return this._vertexMap.get(vertexKey) || void 0;
    }
    _getVertexKey(vertexOrKey) {
      return vertexOrKey instanceof AbstractVertex ? vertexOrKey.key : vertexOrKey;
    }
  };

  // src/data-structures/graph/directed-graph.ts
  var DirectedVertex = class extends AbstractVertex {
    /**
     * The constructor function initializes a vertex with an optional value.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is
     * used to uniquely identify the vertex within a graph or data structure.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It is used to initialize the value of the
     * vertex. If no value is provided, the vertex will be initialized with a default value.
     */
    constructor(key, value) {
      super(key, value);
    }
  };
  var DirectedEdge = class extends AbstractEdge {
    /**
     * The constructor function initializes the source and destination vertexMap of an edge, along with an optional weight
     * and value.
     * @param {VertexKey} src - The `src` parameter is the source vertex ID. It represents the starting point of an edge in
     * a graph.
     * @param {VertexKey} dest - The `dest` parameter represents the destination vertex of an edge. It is of type
     * `VertexKey`, which is likely a unique identifier for a vertex in a graph.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.
     * @param {E} [value] - The `value` parameter is an optional parameter of type `E`. It represents the value associated with
     * the edge.
     */
    constructor(src, dest, weight, value) {
      super(weight, value);
      __publicField(this, "src");
      __publicField(this, "dest");
      this.src = src;
      this.dest = dest;
    }
  };
  var DirectedGraph = class _DirectedGraph extends AbstractGraph {
    /**
     * The constructor function initializes an instance of a class.
     */
    constructor() {
      super();
      __publicField(this, "_outEdgeMap", /* @__PURE__ */ new Map());
      __publicField(this, "_inEdgeMap", /* @__PURE__ */ new Map());
    }
    get outEdgeMap() {
      return this._outEdgeMap;
    }
    set outEdgeMap(v) {
      this._outEdgeMap = v;
    }
    get inEdgeMap() {
      return this._inEdgeMap;
    }
    set inEdgeMap(v) {
      this._inEdgeMap = v;
    }
    /**
     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.
     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.
     */
    /**
     * The function creates a new vertex with an optional value and returns it.
     * @param {VertexKey} key - The `key` parameter is the unique identifier for the vertex. It is of type `VertexKey`, which
     * could be a number or a string depending on how you want to identify your vertexMap.
     * @param [value] - The 'value' parameter is an optional value that can be assigned to the vertex. If a value is provided,
     * it will be assigned to the 'value' property of the vertex. If no value is provided, the 'value' property will be
     * assigned the same value as the 'key' parameter
     * @returns a new instance of a DirectedVertex object, casted as type VO.
     */
    createVertex(key, value) {
      return new DirectedVertex(key, value);
    }
    /**
     * In TypeScript, a subclass inherits the interface implementation of its parent class, without needing to implement the same interface again in the subclass. This behavior differs from Java's approach. In Java, if a parent class implements an interface, the subclass needs to explicitly implement the same interface, even if the parent class has already implemented it.
     * This means that using abstract methods in the parent class cannot constrain the grandchild classes. Defining methods within an interface also cannot constrain the descendant classes. When inheriting from this class, developers need to be aware that this method needs to be overridden.
     */
    /**
     * The function creates a directed edge between two vertexMap with an optional weight and value.
     * @param {VertexKey} src - The source vertex ID of the edge. It represents the starting point of the edge.
     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for the edge.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge. If no
     * weight is provided, it defaults to 1.
     * @param [value] - The 'value' parameter is an optional value that can be assigned to the edge. It can be of any type and
     * is used to store additional information or data associated with the edge.
     * @returns a new instance of a DirectedEdge object, casted as type EO.
     */
    createEdge(src, dest, weight, value) {
      return new DirectedEdge(src, dest, weight != null ? weight : 1, value);
    }
    /**
     * Time Complexity: O(|V|) where |V| is the number of vertexMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|V|) where |V| is the number of vertexMap
     * Space Complexity: O(1)
     *
     * The `getEdge` function retrieves an edge between two vertexMap based on their source and destination IDs.
     * @param {VO | VertexKey | undefined} srcOrKey - The source vertex or its ID. It can be either a vertex object or a vertex ID.
     * @param {VO | VertexKey | undefined} destOrKey - The `destOrKey` parameter in the `getEdge` function represents the
     * destination vertex of the edge. It can be either a vertex object (`VO`), a vertex ID (`VertexKey`), or `undefined` if the
     * destination is not specified.
     * @returns the first edge found between the source and destination vertexMap, or undefined if no such edge is found.
     */
    getEdge(srcOrKey, destOrKey) {
      let edgeMap = [];
      if (srcOrKey !== void 0 && destOrKey !== void 0) {
        const src = this._getVertex(srcOrKey);
        const dest = this._getVertex(destOrKey);
        if (src && dest) {
          const srcOutEdges = this._outEdgeMap.get(src);
          if (srcOutEdges) {
            edgeMap = srcOutEdges.filter((edge) => edge.dest === dest.key);
          }
        }
      }
      return edgeMap[0] || void 0;
    }
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function removes an edge between two vertexMap in a graph and returns the removed edge.
     * @param {VO | VertexKey} srcOrKey - The source vertex or its ID.
     * @param {VO | VertexKey} destOrKey - The `destOrKey` parameter represents the destination vertex or its ID.
     * @returns the removed edge (EO) if it exists, or undefined if either the source or destination vertex does not exist.
     */
    deleteEdgeSrcToDest(srcOrKey, destOrKey) {
      const src = this._getVertex(srcOrKey);
      const dest = this._getVertex(destOrKey);
      let removed = void 0;
      if (!src || !dest) {
        return void 0;
      }
      const srcOutEdges = this._outEdgeMap.get(src);
      if (srcOutEdges) {
        arrayRemove(srcOutEdges, (edge) => edge.dest === dest.key);
      }
      const destInEdges = this._inEdgeMap.get(dest);
      if (destInEdges) {
        removed = arrayRemove(destInEdges, (edge) => edge.src === src.key)[0] || void 0;
      }
      return removed;
    }
    /**
     * Time Complexity: O(E) where E is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(E) where E is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The `deleteEdge` function removes an edge from a graph and returns the removed edge.
     * @param {EO | VertexKey} edgeOrSrcVertexKey - The `edge` parameter can be either an `EO` object (edge object) or
     * a `VertexKey` (key of a vertex).
     * @param {VertexKey} [destVertexKey] - The `destVertexKey` parameter is an optional parameter that
     * represents the key of the destination vertex of the edge. It is used to specify the destination
     * vertex when the `edge` parameter is a vertex key. If `destVertexKey` is not provided, the function
     * assumes that the `edge`
     * @returns the removed edge (EO) or undefined if no edge was removed.
     */
    deleteEdge(edgeOrSrcVertexKey, destVertexKey) {
      let removed = void 0;
      let src, dest;
      if (this.isVertexKey(edgeOrSrcVertexKey)) {
        if (this.isVertexKey(destVertexKey)) {
          src = this._getVertex(edgeOrSrcVertexKey);
          dest = this._getVertex(destVertexKey);
        } else {
          return;
        }
      } else {
        src = this._getVertex(edgeOrSrcVertexKey.src);
        dest = this._getVertex(edgeOrSrcVertexKey.dest);
      }
      if (src && dest) {
        const srcOutEdges = this._outEdgeMap.get(src);
        if (srcOutEdges && srcOutEdges.length > 0) {
          arrayRemove(srcOutEdges, (edge) => edge.src === src.key && edge.dest === (dest == null ? void 0 : dest.key));
        }
        const destInEdges = this._inEdgeMap.get(dest);
        if (destInEdges && destInEdges.length > 0) {
          removed = arrayRemove(destInEdges, (edge) => edge.src === src.key && edge.dest === dest.key)[0];
        }
      }
      return removed;
    }
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The `deleteVertex` function removes a vertex from a graph by its ID or by the vertex object itself.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method is returning a boolean value.
     */
    deleteVertex(vertexOrKey) {
      let vertexKey;
      let vertex;
      if (this.isVertexKey(vertexOrKey)) {
        vertex = this.getVertex(vertexOrKey);
        vertexKey = vertexOrKey;
      } else {
        vertex = vertexOrKey;
        vertexKey = this._getVertexKey(vertexOrKey);
      }
      if (vertex) {
        const neighbors = this.getNeighbors(vertex);
        for (const neighbor of neighbors) {
          this._inEdgeMap.delete(neighbor);
        }
        this._outEdgeMap.delete(vertex);
        this._inEdgeMap.delete(vertex);
      }
      return this._vertexMap.delete(vertexKey);
    }
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function removes edgeMap between two vertexMap and returns the removed edgeMap.
     * @param {VertexKey | VO} v1 - The parameter `v1` can be either a `VertexKey` or a `VO`. A `VertexKey` represents the
     * unique identifier of a vertex in a graph, while `VO` represents the actual vertex object.
     * @param {VertexKey | VO} v2 - The parameter `v2` represents either a `VertexKey` or a `VO` object. It is used to specify
     * the second vertex in the edge that needs to be removed.
     * @returns an array of removed edgeMap (EO[]).
     */
    deleteEdgesBetween(v1, v2) {
      const removed = [];
      if (v1 && v2) {
        const v1ToV2 = this.deleteEdgeSrcToDest(v1, v2);
        const v2ToV1 = this.deleteEdgeSrcToDest(v2, v1);
        v1ToV2 && removed.push(v1ToV2);
        v2ToV1 && removed.push(v2ToV1);
      }
      return removed;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `incomingEdgesOf` returns an array of incoming edgeMap for a given vertex or vertex ID.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method `incomingEdgesOf` returns an array of edgeMap (`EO[]`).
     */
    incomingEdgesOf(vertexOrKey) {
      const target = this._getVertex(vertexOrKey);
      if (target) {
        return this.inEdgeMap.get(target) || [];
      }
      return [];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `outgoingEdgesOf` returns an array of outgoing edgeMap from a given vertex or vertex ID.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can accept either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method `outgoingEdgesOf` returns an array of edgeMap (`EO[]`).
     */
    outgoingEdgesOf(vertexOrKey) {
      const target = this._getVertex(vertexOrKey);
      if (target) {
        return this._outEdgeMap.get(target) || [];
      }
      return [];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "degreeOf" returns the total degree of a vertex, which is the sum of its out-degree and in-degree.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The sum of the out-degree and in-degree of the specified vertex or vertex ID.
     */
    degreeOf(vertexOrKey) {
      return this.outDegreeOf(vertexOrKey) + this.inDegreeOf(vertexOrKey);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "inDegreeOf" returns the number of incoming edgeMap for a given vertex.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The number of incoming edgeMap of the specified vertex or vertex ID.
     */
    inDegreeOf(vertexOrKey) {
      return this.incomingEdgesOf(vertexOrKey).length;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `outDegreeOf` returns the number of outgoing edgeMap from a given vertex.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The number of outgoing edgeMap from the specified vertex or vertex ID.
     */
    outDegreeOf(vertexOrKey) {
      return this.outgoingEdgesOf(vertexOrKey).length;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "edgesOf" returns an array of both outgoing and incoming edgeMap of a given vertex or vertex ID.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The function `edgesOf` returns an array of edgeMap.
     */
    edgesOf(vertexOrKey) {
      return [...this.outgoingEdgesOf(vertexOrKey), ...this.incomingEdgesOf(vertexOrKey)];
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEdgeSrc" returns the source vertex of an edge, or undefined if the edge does not exist.
     * @param {EO} e - The parameter "e" is of type EO, which represents an edge in a graph.
     * @returns either a vertex object (VO) or undefined.
     */
    getEdgeSrc(e) {
      return this._getVertex(e.src);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEdgeDest" returns the destination vertex of an edge.
     * @param {EO} e - The parameter "e" is of type "EO", which represents an edge in a graph.
     * @returns either a vertex object of type VO or undefined.
     */
    getEdgeDest(e) {
      return this._getVertex(e.dest);
    }
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function `getDestinations` returns an array of destination vertexMap connected to a given vertex.
     * @param {VO | VertexKey | undefined} vertex - The `vertex` parameter represents the starting vertex from which we want to
     * find the destinations. It can be either a `VO` object, a `VertexKey` value, or `undefined`.
     * @returns an array of vertexMap (VO[]).
     */
    getDestinations(vertex) {
      if (vertex === void 0) {
        return [];
      }
      const destinations = [];
      const outgoingEdges = this.outgoingEdgesOf(vertex);
      for (const outEdge of outgoingEdges) {
        const child = this.getEdgeDest(outEdge);
        if (child) {
          destinations.push(child);
        }
      }
      return destinations;
    }
    /**
     * Time Complexity: O(|V| + |E|) where |V| is the number of vertexMap and |E| is the number of edgeMap
     * Space Complexity: O(|V|)
     */
    /**
     * Time Complexity: O(|V| + |E|) where |V| is the number of vertexMap and |E| is the number of edgeMap
     * Space Complexity: O(|V|)
     *
     * The `topologicalSort` function performs a topological sort on a graph and returns an array of vertexMap or vertex IDs
     * in the sorted order, or undefined if the graph contains a cycle.
     * @param {'vertex' | 'key'} [propertyName] - The `propertyName` parameter is an optional parameter that specifies the
     * property to use for sorting the vertexMap. It can have two possible values: 'vertex' or 'key'. If 'vertex' is
     * specified, the vertexMap themselves will be used for sorting. If 'key' is specified, the ids of
     * @returns an array of vertexMap or vertex IDs in topological order. If there is a cycle in the graph, it returns undefined.
     */
    topologicalSort(propertyName) {
      propertyName = propertyName != null ? propertyName : "key";
      const statusMap = /* @__PURE__ */ new Map();
      for (const entry of this.vertexMap) {
        statusMap.set(entry[1], 0);
      }
      let sorted = [];
      let hasCycle = false;
      const dfs = (cur) => {
        statusMap.set(cur, 1);
        const children = this.getDestinations(cur);
        for (const child of children) {
          const childStatus = statusMap.get(child);
          if (childStatus === 0) {
            dfs(child);
          } else if (childStatus === 1) {
            hasCycle = true;
          }
        }
        statusMap.set(cur, 2);
        sorted.push(cur);
      };
      for (const entry of this.vertexMap) {
        if (statusMap.get(entry[1]) === 0) {
          dfs(entry[1]);
        }
      }
      if (hasCycle)
        return void 0;
      if (propertyName === "key")
        sorted = sorted.map((vertex) => vertex instanceof DirectedVertex ? vertex.key : vertex);
      return sorted.reverse();
    }
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(|E|)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(|E|)
     *
     * The `edgeSet` function returns an array of all the edgeMap in the graph.
     * @returns The `edgeSet()` method returns an array of edgeMap (`EO[]`).
     */
    edgeSet() {
      let edgeMap = [];
      this._outEdgeMap.forEach((outEdges) => {
        edgeMap = [...edgeMap, ...outEdges];
      });
      return edgeMap;
    }
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|) where |E| is the number of edgeMap
     * Space Complexity: O(1)
     *
     * The function `getNeighbors` returns an array of neighboring vertexMap of a given vertex or vertex ID in a graph.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns an array of vertexMap (VO[]).
     */
    getNeighbors(vertexOrKey) {
      const neighbors = [];
      const vertex = this._getVertex(vertexOrKey);
      if (vertex) {
        const outEdges = this.outgoingEdgesOf(vertex);
        for (const outEdge of outEdges) {
          const neighbor = this._getVertex(outEdge.dest);
          if (neighbor) {
            neighbors.push(neighbor);
          }
        }
      }
      return neighbors;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEndsOfEdge" returns the source and destination vertexMap of an edge if it exists in the graph,
     * otherwise it returns undefined.
     * @param {EO} edge - The parameter `edge` is of type `EO`, which represents an edge in a graph.
     * @returns The function `getEndsOfEdge` returns an array containing two vertexMap `[VO, VO]` if the edge exists in the
     * graph. If the edge does not exist, it returns `undefined`.
     */
    getEndsOfEdge(edge) {
      if (!this.hasEdge(edge.src, edge.dest)) {
        return void 0;
      }
      const v1 = this._getVertex(edge.src);
      const v2 = this._getVertex(edge.dest);
      if (v1 && v2) {
        return [v1, v2];
      } else {
        return void 0;
      }
    }
    /**
     * The isEmpty function checks if the graph is empty.
     *
     * @return A boolean value
     */
    isEmpty() {
      return this.vertexMap.size === 0 && this.inEdgeMap.size === 0 && this.outEdgeMap.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear function resets the vertex map, in-edge map, and out-edge map.
     */
    clear() {
      this._vertexMap = /* @__PURE__ */ new Map();
      this._inEdgeMap = /* @__PURE__ */ new Map();
      this._outEdgeMap = /* @__PURE__ */ new Map();
    }
    /**
     * The clone function creates a new DirectedGraph object with the same vertices and edges as the original.
     *
     * @return A new instance of the directedgraph class
     */
    clone() {
      const cloned = new _DirectedGraph();
      cloned.vertexMap = new Map(this.vertexMap);
      cloned.inEdgeMap = new Map(this.inEdgeMap);
      cloned.outEdgeMap = new Map(this.outEdgeMap);
      return cloned;
    }
    /**
     *  Time Complexity: O(V + E)
     *  Space Complexity: O(V)
     *  Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     *  Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.
     */
    /**
     *  Time Complexity: O(V + E)
     *  Space Complexity: O(V)
     *  Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     *  Tarjan can find the SSC(strongly connected components), articulation points, and bridges of directed graphs.
     *
     * The function `tarjan` implements the Tarjan's algorithm to find strongly connected components in a
     * graph.
     * @returns The function `tarjan()` returns an object with three properties: `dfnMap`, `lowMap`, and
     * `SCCs`.
     */
    tarjan() {
      const dfnMap = /* @__PURE__ */ new Map();
      const lowMap = /* @__PURE__ */ new Map();
      const SCCs = /* @__PURE__ */ new Map();
      let time = 0;
      const stack = [];
      const inStack = /* @__PURE__ */ new Set();
      const dfs = (vertex) => {
        dfnMap.set(vertex, time);
        lowMap.set(vertex, time);
        time++;
        stack.push(vertex);
        inStack.add(vertex);
        const neighbors = this.getNeighbors(vertex);
        for (const neighbor of neighbors) {
          if (!dfnMap.has(neighbor)) {
            dfs(neighbor);
            lowMap.set(vertex, Math.min(lowMap.get(vertex), lowMap.get(neighbor)));
          } else if (inStack.has(neighbor)) {
            lowMap.set(vertex, Math.min(lowMap.get(vertex), dfnMap.get(neighbor)));
          }
        }
        if (dfnMap.get(vertex) === lowMap.get(vertex)) {
          const SCC = [];
          let poppedVertex;
          do {
            poppedVertex = stack.pop();
            inStack.delete(poppedVertex);
            SCC.push(poppedVertex);
          } while (poppedVertex !== vertex);
          SCCs.set(SCCs.size, SCC);
        }
      };
      for (const vertex of this.vertexMap.values()) {
        if (!dfnMap.has(vertex)) {
          dfs(vertex);
        }
      }
      return { dfnMap, lowMap, SCCs };
    }
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Tarjan's algorithm).
     * Space Complexity: O(V) - Depends on the implementation (Tarjan's algorithm).
     */
    /**
     * Time Complexity: O(V + E) - Depends on the implementation (Tarjan's algorithm).
     * Space Complexity: O(V) - Depends on the implementation (Tarjan's algorithm).
     *
     * The function returns a map that associates each vertex object with its corresponding depth-first
     * number.
     * @returns A Map object with keys of type VO and values of type number.
     */
    getDFNMap() {
      return this.tarjan().dfnMap;
    }
    /**
     * The function returns a Map object that contains the low values of each vertex in a Tarjan
     * algorithm.
     * @returns The method `getLowMap()` is returning a `Map` object with keys of type `VO` and values of
     * type `number`.
     */
    getLowMap() {
      return this.tarjan().lowMap;
    }
    /**
     * The function "getSCCs" returns a map of strongly connected components (SCCs) using the Tarjan
     * algorithm.
     * @returns a map where the keys are numbers and the values are arrays of VO objects.
     */
    getSCCs() {
      return this.tarjan().SCCs;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_addEdge` adds an edge to a graph if the source and destination vertexMap exist.
     * @param {EO} edge - The parameter `edge` is of type `EO`, which represents an edge in a graph. It is the edge that
     * needs to be added to the graph.
     * @returns a boolean value. It returns true if the edge was successfully added to the graph, and false if either the
     * source or destination vertex does not exist in the graph.
     */
    _addEdge(edge) {
      if (!(this.hasVertex(edge.src) && this.hasVertex(edge.dest))) {
        return false;
      }
      const srcVertex = this._getVertex(edge.src);
      const destVertex = this._getVertex(edge.dest);
      if (srcVertex && destVertex) {
        const srcOutEdges = this._outEdgeMap.get(srcVertex);
        if (srcOutEdges) {
          srcOutEdges.push(edge);
        } else {
          this._outEdgeMap.set(srcVertex, [edge]);
        }
        const destInEdges = this._inEdgeMap.get(destVertex);
        if (destInEdges) {
          destInEdges.push(edge);
        } else {
          this._inEdgeMap.set(destVertex, [edge]);
        }
        return true;
      } else {
        return false;
      }
    }
  };

  // src/data-structures/graph/undirected-graph.ts
  var UndirectedVertex = class extends AbstractVertex {
    /**
     * The constructor function initializes a vertex with an optional value.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex. It is
     * used to uniquely identify the vertex within a graph or network.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It is used to initialize the value of the
     * vertex. If no value is provided, the vertex will be initialized with a default value.
     */
    constructor(key, value) {
      super(key, value);
    }
  };
  var UndirectedEdge = class extends AbstractEdge {
    /**
     * The constructor function creates an instance of a class with two vertex IDs, an optional weight, and an optional
     * value.
     * @param {VertexKey} v1 - The first vertex ID of the edge.
     * @param {VertexKey} v2 - The parameter `v2` is a `VertexKey`, which represents the identifier of the second vertex in a
     * graph edge.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.
     * @param {E} [value] - The "value" parameter is an optional parameter of type E. It is used to store a value associated
     * with the edge.
     */
    constructor(v1, v2, weight, value) {
      super(weight, value);
      __publicField(this, "endpoints");
      this.endpoints = [v1, v2];
    }
  };
  var UndirectedGraph = class _UndirectedGraph extends AbstractGraph {
    /**
     * The constructor initializes a new Map object to store edgeMap.
     */
    constructor() {
      super();
      __publicField(this, "_edgeMap");
      this._edgeMap = /* @__PURE__ */ new Map();
    }
    get edgeMap() {
      return this._edgeMap;
    }
    set edgeMap(v) {
      this._edgeMap = v;
    }
    /**
     * The function creates a new vertex with an optional value and returns it.
     * @param {VertexKey} key - The `key` parameter is the unique identifier for the vertex. It is used to distinguish one
     * vertex from another in the graph.
     * @param [value] - The `value` parameter is an optional value that can be assigned to the vertex. If a value is provided,
     * it will be used as the value of the vertex. If no value is provided, the `key` parameter will be used as the value of
     * the vertex.
     * @returns The method is returning a new instance of the `UndirectedVertex` class, casted as type `VO`.
     */
    createVertex(key, value) {
      return new UndirectedVertex(key, value != null ? value : key);
    }
    /**
     * The function creates an undirected edge between two vertexMap with an optional weight and value.
     * @param {VertexKey} v1 - The parameter `v1` represents the first vertex of the edge.
     * @param {VertexKey} v2 - The parameter `v2` represents the second vertex of the edge.
     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the edge. If
     * no weight is provided, it defaults to 1.
     * @param [value] - The `value` parameter is an optional value that can be assigned to the edge. It can be of any type and
     * is used to store additional information or data associated with the edge.
     * @returns a new instance of the `UndirectedEdge` class, which is casted as type `EO`.
     */
    createEdge(v1, v2, weight, value) {
      return new UndirectedEdge(v1, v2, weight != null ? weight : 1, value);
    }
    /**
     * Time Complexity: O(|E|), where |E| is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|), where |E| is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     *
     * The function `getEdge` returns the first edge that connects two endpoints, or undefined if no such edge exists.
     * @param {VO | VertexKey | undefined} v1 - The parameter `v1` represents a vertex or vertex ID. It can be of type `VO` (vertex
     * object), `undefined`, or `VertexKey` (a string or number representing the ID of a vertex).
     * @param {VO | VertexKey | undefined} v2 - The parameter `v2` represents a vertex or vertex ID. It can be of type `VO` (vertex
     * object), `undefined`, or `VertexKey` (vertex ID).
     * @returns an edge (EO) or undefined.
     */
    getEdge(v1, v2) {
      var _a;
      let edgeMap = [];
      if (v1 !== void 0 && v2 !== void 0) {
        const vertex1 = this._getVertex(v1);
        const vertex2 = this._getVertex(v2);
        if (vertex1 && vertex2) {
          edgeMap = (_a = this._edgeMap.get(vertex1)) == null ? void 0 : _a.filter((e) => e.endpoints.includes(vertex2.key));
        }
      }
      return edgeMap ? edgeMap[0] || void 0 : void 0;
    }
    /**
     * Time Complexity: O(|E|), where |E| is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(|E|), where |E| is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     *
     * The function removes an edge between two vertexMap in a graph and returns the removed edge.
     * @param {VO | VertexKey} v1 - The parameter `v1` represents either a vertex object (`VO`) or a vertex ID (`VertexKey`).
     * @param {VO | VertexKey} v2 - VO | VertexKey - This parameter can be either a vertex object (VO) or a vertex ID
     * (VertexKey). It represents the second vertex of the edge that needs to be removed.
     * @returns the removed edge (EO) if it exists, or undefined if either of the endpoints (VO) does not exist.
     */
    deleteEdgeBetween(v1, v2) {
      const vertex1 = this._getVertex(v1);
      const vertex2 = this._getVertex(v2);
      if (!vertex1 || !vertex2) {
        return void 0;
      }
      const v1Edges = this._edgeMap.get(vertex1);
      let removed = void 0;
      if (v1Edges) {
        removed = arrayRemove(v1Edges, (e) => e.endpoints.includes(vertex2.key))[0] || void 0;
      }
      const v2Edges = this._edgeMap.get(vertex2);
      if (v2Edges) {
        arrayRemove(v2Edges, (e) => e.endpoints.includes(vertex1.key));
      }
      return removed;
    }
    /**
     * Time Complexity: O(E), where E is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(E), where E is the number of edgeMap incident to the given vertex.
     * Space Complexity: O(1)
     *
     * The function `deleteEdge` deletes an edge between two endpoints in a graph.
     * @param {EO | VertexKey} edgeOrOneSideVertexKey - The parameter `edgeOrOneSideVertexKey` can be
     * either an edge object or a vertex key.
     * @param {VertexKey} [otherSideVertexKey] - The parameter `otherSideVertexKey` is an optional
     * parameter that represents the key of the vertex on the other side of the edge. It is used when the
     * `edgeOrOneSideVertexKey` parameter is a vertex key, and it specifies the key of the vertex on the
     * other side of the
     * @returns The `deleteEdge` function returns either the deleted edge object (EO) or `undefined`.
     */
    deleteEdge(edgeOrOneSideVertexKey, otherSideVertexKey) {
      let oneSide, otherSide;
      if (this.isVertexKey(edgeOrOneSideVertexKey)) {
        if (this.isVertexKey(otherSideVertexKey)) {
          oneSide = this._getVertex(edgeOrOneSideVertexKey);
          otherSide = this._getVertex(otherSideVertexKey);
        } else {
          return;
        }
      } else {
        oneSide = this._getVertex(edgeOrOneSideVertexKey.endpoints[0]);
        otherSide = this._getVertex(edgeOrOneSideVertexKey.endpoints[1]);
      }
      if (oneSide && otherSide) {
        return this.deleteEdgeBetween(oneSide, otherSide);
      } else {
        return;
      }
    }
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     */
    /**
     * Time Complexity: O(1) - Constant time for Map operations.
     * Space Complexity: O(1) - Constant space, as it creates only a few variables.
     *
     * The `deleteVertex` function removes a vertex from a graph by its ID or by the vertex object itself.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns The method is returning a boolean value.
     */
    deleteVertex(vertexOrKey) {
      let vertexKey;
      let vertex;
      if (this.isVertexKey(vertexOrKey)) {
        vertex = this.getVertex(vertexOrKey);
        vertexKey = vertexOrKey;
      } else {
        vertex = vertexOrKey;
        vertexKey = this._getVertexKey(vertexOrKey);
      }
      const neighbors = this.getNeighbors(vertexOrKey);
      if (vertex) {
        neighbors.forEach((neighbor) => {
          const neighborEdges = this._edgeMap.get(neighbor);
          if (neighborEdges) {
            const restEdges = neighborEdges.filter((edge) => {
              return !edge.endpoints.includes(vertexKey);
            });
            this._edgeMap.set(neighbor, restEdges);
          }
        });
        this._edgeMap.delete(vertex);
      }
      return this._vertexMap.delete(vertexKey);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `degreeOf` returns the degree of a vertex in a graph, which is the number of edgeMap connected to that
     * vertex.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`.
     * @returns The function `degreeOf` returns the degree of a vertex in a graph. The degree of a vertex is the number of
     * edgeMap connected to that vertex.
     */
    degreeOf(vertexOrKey) {
      var _a;
      const vertex = this._getVertex(vertexOrKey);
      if (vertex) {
        return ((_a = this._edgeMap.get(vertex)) == null ? void 0 : _a.length) || 0;
      } else {
        return 0;
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function returns the edgeMap of a given vertex or vertex ID.
     * @param {VertexKey | VO} vertexOrKey - The parameter `vertexOrKey` can be either a `VertexKey` or a `VO`. A `VertexKey` is a
     * unique identifier for a vertex in a graph, while `VO` represents the type of the vertex.
     * @returns an array of edgeMap.
     */
    edgesOf(vertexOrKey) {
      const vertex = this._getVertex(vertexOrKey);
      if (vertex) {
        return this._edgeMap.get(vertex) || [];
      } else {
        return [];
      }
    }
    /**
     * Time Complexity: O(|V| + |E|), where |V| is the number of vertexMap and |E| is the number of edgeMap.
     * Space Complexity: O(|E|)
     */
    /**
     * Time Complexity: O(|V| + |E|), where |V| is the number of vertexMap and |E| is the number of edgeMap.
     * Space Complexity: O(|E|)
     *
     * The function "edgeSet" returns an array of unique edgeMap from a set of edgeMap.
     * @returns The method `edgeSet()` returns an array of type `EO[]`.
     */
    edgeSet() {
      const edgeSet = /* @__PURE__ */ new Set();
      this._edgeMap.forEach((edgeMap) => {
        edgeMap.forEach((edge) => {
          edgeSet.add(edge);
        });
      });
      return [...edgeSet];
    }
    /**
     * Time Complexity: O(|V| + |E|), where |V| is the number of vertexMap and |E| is the number of edgeMap.
     * Space Complexity: O(|E|)
     */
    /**
     * Time Complexity: O(|V| + |E|), where |V| is the number of vertexMap and |E| is the number of edgeMap.
     * Space Complexity: O(|E|)
     *
     * The function "getNeighbors" returns an array of neighboring endpoints for a given vertex or vertex ID.
     * @param {VO | VertexKey} vertexOrKey - The parameter `vertexOrKey` can be either a vertex object (`VO`) or a vertex ID
     * (`VertexKey`).
     * @returns an array of vertexMap (VO[]).
     */
    getNeighbors(vertexOrKey) {
      const neighbors = [];
      const vertex = this._getVertex(vertexOrKey);
      if (vertex) {
        const neighborEdges = this.edgesOf(vertex);
        for (const edge of neighborEdges) {
          const neighbor = this._getVertex(edge.endpoints.filter((e) => e !== vertex.key)[0]);
          if (neighbor) {
            neighbors.push(neighbor);
          }
        }
      }
      return neighbors;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function "getEndsOfEdge" returns the endpoints at the ends of an edge if the edge exists in the graph, otherwise
     * it returns undefined.
     * @param {EO} edge - The parameter "edge" is of type EO, which represents an edge in a graph.
     * @returns The function `getEndsOfEdge` returns an array containing two endpoints `[VO, VO]` if the edge exists in the
     * graph. If the edge does not exist, it returns `undefined`.
     */
    getEndsOfEdge(edge) {
      if (!this.hasEdge(edge.endpoints[0], edge.endpoints[1])) {
        return void 0;
      }
      const v1 = this._getVertex(edge.endpoints[0]);
      const v2 = this._getVertex(edge.endpoints[1]);
      if (v1 && v2) {
        return [v1, v2];
      } else {
        return void 0;
      }
    }
    /**
     * The isEmpty function checks if the graph is empty.
     * @return True if the graph is empty and false otherwise
     */
    isEmpty() {
      return this.vertexMap.size === 0 && this.edgeMap.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear function resets the vertex and edge maps to empty maps.
     */
    clear() {
      this._vertexMap = /* @__PURE__ */ new Map();
      this._edgeMap = /* @__PURE__ */ new Map();
    }
    /**
     * The clone function creates a new UndirectedGraph object and copies the
     * vertexMap and edgeMap from this graph to the new one. This is done by
     * assigning each of these properties to their respective counterparts in the
     * cloned graph. The clone function returns a reference to this newly created,
     * cloned UndirectedGraph object.
     *
     * @return A new instance of the undirectedgraph class
     */
    clone() {
      const cloned = new _UndirectedGraph();
      cloned.vertexMap = new Map(this.vertexMap);
      cloned.edgeMap = new Map(this.edgeMap);
      return cloned;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     *  Time Complexity: O(V + E)
     *  Space Complexity: O(V)
     *   Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     *  1. Tarjan can find the articulation points and bridges(critical edgeMap) of undirected graphs in linear time
     *
     * The function `tarjan` implements the Tarjan's algorithm to find bridges and cut vertices in a
     * graph.
     * @returns The function `tarjan()` returns an object with the following properties:
     */
    tarjan() {
      const dfnMap = /* @__PURE__ */ new Map();
      const lowMap = /* @__PURE__ */ new Map();
      const bridges = [];
      const cutVertices = [];
      let time = 0;
      const dfs = (vertex, parent) => {
        dfnMap.set(vertex, time);
        lowMap.set(vertex, time);
        time++;
        const neighbors = this.getNeighbors(vertex);
        let childCount = 0;
        for (const neighbor of neighbors) {
          if (!dfnMap.has(neighbor)) {
            childCount++;
            dfs(neighbor, vertex);
            lowMap.set(vertex, Math.min(lowMap.get(vertex), lowMap.get(neighbor)));
            if (lowMap.get(neighbor) > dfnMap.get(vertex)) {
              const edge = this.getEdge(vertex, neighbor);
              if (edge) {
                bridges.push(edge);
              }
            }
            if (parent !== void 0 && lowMap.get(neighbor) >= dfnMap.get(vertex)) {
              cutVertices.push(vertex);
            }
          } else if (neighbor !== parent) {
            lowMap.set(vertex, Math.min(lowMap.get(vertex), dfnMap.get(neighbor)));
          }
        }
        if (parent === void 0 && childCount > 1) {
          cutVertices.push(vertex);
        }
      };
      for (const vertex of this.vertexMap.values()) {
        if (!dfnMap.has(vertex)) {
          dfs(vertex, void 0);
        }
      }
      return {
        dfnMap,
        lowMap,
        bridges,
        cutVertices
      };
    }
    /**
     *  Time Complexity: O(V + E)
     *  Space Complexity: O(V)
     *  Tarjan is an algorithm based on dfs,which is used to solve the connectivity problem of graphs.
     *  1. Tarjan can find the articulation points and bridges(critical edgeMap) of undirected graphs in linear time
     */
    /**
     * The function "getBridges" returns an array of bridges in a graph using the Tarjan's algorithm.
     * @returns The function `getBridges()` is returning the bridges found using the Tarjan's algorithm.
     */
    getBridges() {
      return this.tarjan().bridges;
    }
    /**
     * The function "getCutVertices" returns an array of cut vertices using the Tarjan's algorithm.
     * @returns the cut vertices found using the Tarjan's algorithm.
     */
    getCutVertices() {
      return this.tarjan().cutVertices;
    }
    /**
     * The function returns the dfnMap property of the result of the tarjan() function.
     * @returns the `dfnMap` property of the result of calling the `tarjan()` function.
     */
    getDFNMap() {
      return this.tarjan().dfnMap;
    }
    /**
     * The function returns the lowMap property of the result of the tarjan() function.
     * @returns the lowMap property of the result of calling the tarjan() function.
     */
    getLowMap() {
      return this.tarjan().lowMap;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function adds an edge to the graph by updating the adjacency list with the vertexMap of the edge.
     * @param {EO} edge - The parameter "edge" is of type EO, which represents an edge in a graph.
     * @returns a boolean value.
     */
    _addEdge(edge) {
      for (const end of edge.endpoints) {
        const endVertex = this._getVertex(end);
        if (endVertex === void 0)
          return false;
        if (endVertex) {
          const edgeMap = this._edgeMap.get(endVertex);
          if (edgeMap) {
            edgeMap.push(edge);
          } else {
            this._edgeMap.set(endVertex, [edge]);
          }
        }
      }
      return true;
    }
  };

  // src/data-structures/graph/map-graph.ts
  var MapVertex = class extends DirectedVertex {
    /**
     * The constructor function initializes an object with an key, latitude, longitude, and an optional value.
     * @param {VertexKey} key - The `key` parameter is of type `VertexKey` and represents the identifier of the vertex.
     * @param {number} lat - The "lat" parameter represents the latitude of a vertex. Latitude is a geographic coordinate
     * that specifies the north-south position of a point on the Earth's surface. It is measured in degrees, with positive
     * values representing points north of the equator and negative values representing points south of the equator.
     * @param {number} long - The "long" parameter represents the longitude of a location. Longitude is a geographic
     * coordinate that specifies the east-west position of a point on the Earth's surface. It is measured in degrees, with
     * values ranging from -180 to 180.
     * @param {V} [value] - The "value" parameter is an optional value of type V. It is not required to be provided when
     * creating an instance of the class.
     */
    constructor(key, value, lat, long) {
      super(key, value);
      __publicField(this, "lat");
      __publicField(this, "long");
      this.lat = lat;
      this.long = long;
    }
  };
  var MapEdge = class extends DirectedEdge {
    /**
     * The constructor function initializes a new instance of a class with the given source, destination, weight, and
     * value.
     * @param {VertexKey} src - The `src` parameter is the source vertex ID. It represents the starting point of an edge in
     * a graph.
     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for an edge.
     * @param {number} [weight] - The weight parameter is an optional number that represents the weight of the edge.
     * @param {E} [value] - The "value" parameter is an optional parameter of type E. It is used to store additional
     * information or data associated with the edge.
     */
    constructor(src, dest, weight, value) {
      super(src, dest, weight, value);
    }
  };
  var MapGraph = class _MapGraph extends DirectedGraph {
    /**
     * The constructor function initializes the originCoord and bottomRight properties of a MapGraphCoordinate object.
     * @param {MapGraphCoordinate} originCoord - The `originCoord` parameter is a `MapGraphCoordinate` object that represents the
     * starting point or reference point of the map graph. It defines the coordinates of the top-left corner of the map
     * graph.
     * @param {MapGraphCoordinate} [bottomRight] - The `bottomRight` parameter is an optional parameter of type
     * `MapGraphCoordinate`. It represents the bottom right coordinate of a map graph. If this parameter is not provided,
     * it will default to `undefined`.
     */
    constructor(originCoord, bottomRight) {
      super();
      __publicField(this, "_originCoord", [0, 0]);
      __publicField(this, "_bottomRight");
      this._originCoord = originCoord;
      this._bottomRight = bottomRight;
    }
    get originCoord() {
      return this._originCoord;
    }
    get bottomRight() {
      return this._bottomRight;
    }
    /**
     * The function creates a new vertex with the given key, value, latitude, and longitude.
     * @param {VertexKey} key - The key parameter is the unique identifier for the vertex. It is of type VertexKey, which could
     * be a string or a number depending on how you define it in your code.
     * @param [value] - The `value` parameter is an optional value that can be assigned to the `value` property of the vertex. It
     * is of type `V`, which means it should be of the same type as the `value` property of the vertex class `VO`.
     * @param {number} lat - The `lat` parameter represents the latitude of the vertex. It is a number that specifies the
     * position of the vertex on the Earth's surface in the north-south direction.
     * @param {number} long - The `long` parameter represents the longitude coordinate of the vertex.
     * @returns The method is returning a new instance of the `MapVertex` class, casted as type `VO`.
     */
    createVertex(key, value, lat = this.originCoord[0], long = this.originCoord[1]) {
      return new MapVertex(key, value, lat, long);
    }
    /**
     * The function creates a new instance of a MapEdge with the given source, destination, weight, and value.
     * @param {VertexKey} src - The source vertex ID of the edge. It represents the starting point of the edge.
     * @param {VertexKey} dest - The `dest` parameter is the identifier of the destination vertex for the edge being
     * created.
     * @param {number} [weight] - The `weight` parameter is an optional number that represents the weight of the edge. It
     * is used to assign a numerical value to the edge, which can be used in algorithms such as shortest path algorithms.
     * If the weight is not provided, it can be set to a default value or left undefined.
     * @param [value] - The `value` parameter is an optional value that can be assigned to the edge. It can be of any type,
     * depending on the specific implementation of the `MapEdge` class.
     * @returns a new instance of the `MapEdge` class, cast as type `EO`.
     */
    createEdge(src, dest, weight, value) {
      return new MapEdge(src, dest, weight, value);
    }
    /**
     * The override function is used to override the default behavior of a function.
     * In this case, we are overriding the clone() function from Graph&lt;V, E&gt;.
     * The clone() function returns a new graph that is an exact copy of the original graph.
     *
     * @return A mapgraph&lt;v, e, vo, eo&gt;
     */
    clone() {
      const cloned = new _MapGraph(this.originCoord, this.bottomRight);
      cloned.vertexMap = new Map(this.vertexMap);
      cloned.inEdgeMap = new Map(this.inEdgeMap);
      cloned.outEdgeMap = new Map(this.outEdgeMap);
      return cloned;
    }
  };

  // src/data-structures/binary-tree/binary-tree.ts
  var BinaryTreeNode = class {
    /**
     * The constructor function initializes an object with a key and an optional value.
     * @param {K} key - The "key" parameter is of type K, which represents the type of the key for the
     * constructor. It is used to set the key property of the object being created.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It represents the
     * value associated with the key in the constructor.
     */
    constructor(key, value) {
      __publicField(this, "key");
      __publicField(this, "value");
      __publicField(this, "parent");
      __publicField(this, "_left");
      __publicField(this, "_right");
      this.key = key;
      this.value = value;
    }
    /**
     * The function returns the value of the `_left` property, which can be of type `NODE`, `null`, or
     * `undefined`.
     * @returns The left node of the current node is being returned. It can be either a NODE object,
     * null, or undefined.
     */
    get left() {
      return this._left;
    }
    /**
     * The function sets the left child of a node and updates its parent reference.
     * @param {NODE | null | undefined} v - The parameter `v` can be of type `NODE`, `null`, or
     * `undefined`.
     */
    set left(v) {
      if (v) {
        v.parent = this;
      }
      this._left = v;
    }
    /**
     * The function returns the right node of a binary tree or null if it doesn't exist.
     * @returns The method is returning the value of the `_right` property, which can be a `NODE` object,
     * `null`, or `undefined`.
     */
    get right() {
      return this._right;
    }
    /**
     * The function sets the right child of a node and updates its parent.
     * @param {NODE | null | undefined} v - The parameter `v` can be of type `NODE`, `null`, or
     * `undefined`.
     */
    set right(v) {
      if (v) {
        v.parent = this;
      }
      this._right = v;
    }
    /**
     * Get the position of the node within its family.
     * @returns {FamilyPosition} - The family position of the node.
     */
    get familyPosition() {
      const that = this;
      if (!this.parent) {
        return this.left || this.right ? "ROOT" : "ISOLATED";
      }
      if (this.parent.left === that) {
        return this.left || this.right ? "ROOT_LEFT" : "LEFT";
      } else if (this.parent.right === that) {
        return this.left || this.right ? "ROOT_RIGHT" : "RIGHT";
      }
      return "MAL_NODE";
    }
  };
  var BinaryTree = class _BinaryTree extends IterableEntryBase {
    /**
     * The constructor function initializes a binary tree object with optional keysOrNodesOrEntriesOrRawElements and options.
     * @param [keysOrNodesOrEntriesOrRawElements] - Optional iterable of KeyOrNodeOrEntry objects. These objects represent the
     * nodes to be added to the binary tree.
     * @param [options] - The `options` parameter is an optional object that can contain additional
     * configuration options for the binary tree. In this case, it is of type
     * `Partial<BinaryTreeOptions>`, which means that not all properties of `BinaryTreeOptions` are
     * required.
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super();
      __publicField(this, "iterationType", "ITERATIVE");
      __publicField(this, "_root");
      __publicField(this, "_size", 0);
      __publicField(this, "_NIL", new BinaryTreeNode(NaN));
      __publicField(this, "_toEntryFn");
      __publicField(this, "_DEFAULT_CALLBACK", (node) => node ? node.key : void 0);
      if (options) {
        const { iterationType, toEntryFn } = options;
        if (iterationType)
          this.iterationType = iterationType;
        if (typeof toEntryFn === "function")
          this._toEntryFn = toEntryFn;
        else if (toEntryFn)
          throw TypeError("toEntryFn must be a function type");
      }
      if (keysOrNodesOrEntriesOrRawElements)
        this.addMany(keysOrNodesOrEntriesOrRawElements);
    }
    /**
     * The function returns the root node, which can be of type NODE, null, or undefined.
     * @returns The method is returning the value of the `_root` property, which can be of type `NODE`,
     * `null`, or `undefined`.
     */
    get root() {
      return this._root;
    }
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size() {
      return this._size;
    }
    /**
     * The function returns the value of the _NIL property.
     * @returns The method is returning the value of the `_NIL` property.
     */
    get NIL() {
      return this._NIL;
    }
    /**
     * The function returns the value of the _toEntryFn property.
     * @returns The function being returned is `this._toEntryFn`.
     */
    get toEntryFn() {
      return this._toEntryFn;
    }
    /**
     * Creates a new instance of BinaryTreeNode with the given key and value.
     * @param {K} key - The key for the new node.
     * @param {V} value - The value for the new node.
     * @returns {NODE} - The newly created BinaryTreeNode.
     */
    createNode(key, value) {
      return new BinaryTreeNode(key, value);
    }
    /**
     * The function creates a binary tree with the given options.
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the `BinaryTree` class. It is of type `Partial<BinaryTreeOptions>`, which means that
     * you can provide only a subset of the properties defined in the `BinaryTreeOptions` interface.
     * @returns a new instance of a binary tree.
     */
    createTree(options) {
      return new _BinaryTree([], __spreadValues({ iterationType: this.iterationType }, options));
    }
    /**
     * The function `keyValueOrEntryOrRawElementToNode` converts a key-value pair, entry, or raw element
     * into a node object.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that can be passed to the
     * `keyValueOrEntryOrRawElementToNode` function. It represents the value associated with a key in a
     * key-value pair. If provided, it will be used to create a node with the specified key and value.
     * @returns The function `keyValueOrEntryOrRawElementToNode` returns either a `NODE` object, `null`,
     * or `undefined`.
     */
    keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value) {
      if (keyOrNodeOrEntryOrRawElement === void 0)
        return;
      if (keyOrNodeOrEntryOrRawElement === null)
        return null;
      if (this.isNode(keyOrNodeOrEntryOrRawElement))
        return keyOrNodeOrEntryOrRawElement;
      if (this.toEntryFn) {
        const [key, entryValue] = this.toEntryFn(keyOrNodeOrEntryOrRawElement);
        if (key)
          return this.createNode(key, entryValue != null ? entryValue : value);
        else
          return;
      }
      if (this.isEntry(keyOrNodeOrEntryOrRawElement)) {
        const [key, value2] = keyOrNodeOrEntryOrRawElement;
        if (key === void 0)
          return;
        else if (key === null)
          return null;
        else
          return this.createNode(key, value2);
      }
      if (this.isKey(keyOrNodeOrEntryOrRawElement))
        return this.createNode(keyOrNodeOrEntryOrRawElement, value);
      return;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `ensureNode` function checks if the input is a valid node and returns it, or converts it to a
     * node if it is a key or entry.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept a value of type `R`, `KeyOrNodeOrEntry<K, V, NODE>`, or
     * a raw element.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when searching for a node. It has a
     * default value of `'ITERATIVE'`.
     * @returns The function `ensureNode` returns either a `NODE` object, `null`, or `undefined`.
     */
    ensureNode(keyOrNodeOrEntryOrRawElement, iterationType = "ITERATIVE") {
      if (keyOrNodeOrEntryOrRawElement === null)
        return null;
      if (keyOrNodeOrEntryOrRawElement === void 0)
        return;
      if (keyOrNodeOrEntryOrRawElement === this.NIL)
        return;
      if (this.isNode(keyOrNodeOrEntryOrRawElement))
        return keyOrNodeOrEntryOrRawElement;
      if (this.toEntryFn) {
        const [key] = this.toEntryFn(keyOrNodeOrEntryOrRawElement);
        if (key)
          return this.getNodeByKey(key);
      }
      if (this.isEntry(keyOrNodeOrEntryOrRawElement)) {
        const key = keyOrNodeOrEntryOrRawElement[0];
        if (key === null)
          return null;
        if (key === void 0)
          return;
        return this.getNodeByKey(key, iterationType);
      }
      if (this.isKey(keyOrNodeOrEntryOrRawElement))
        return this.getNodeByKey(keyOrNodeOrEntryOrRawElement, iterationType);
      return;
    }
    /**
     * The function checks if the input is an instance of the BinaryTreeNode class.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `BinaryTreeNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof BinaryTreeNode;
    }
    /**
     * The function checks if a given node is a valid node in a binary search tree.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isRealNode(node) {
      if (node === this.NIL || node === null || node === void 0)
        return false;
      return this.isNode(node);
    }
    /**
     * The function checks if a given node is a real node or null.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isNodeOrNull(node) {
      return this.isRealNode(node) || node === null;
    }
    /**
     * The function checks if a given node is equal to the NIL value.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isNIL(node) {
      return node === this.NIL;
    }
    /**
     * The function checks if the input is an array with two elements, indicating it is a binary tree
     * node entry.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isEntry(keyOrNodeOrEntryOrRawElement) {
      return Array.isArray(keyOrNodeOrEntryOrRawElement) && keyOrNodeOrEntryOrRawElement.length === 2;
    }
    /**
     * The function checks if a given value is a valid key by evaluating its type and value.
     * @param {any} key - The `key` parameter can be of any type. It is the value that we want to check
     * if it is a valid key.
     * @param [isCheckValueOf=true] - The `isCheckValueOf` parameter is a boolean flag that determines
     * whether the function should check the valueOf() method of an object when the key is of type
     * 'object'. If `isCheckValueOf` is true, the function will recursively call itself with the value
     * returned by key.valueOf().
     * @returns a boolean value.
     */
    isKey(key, isCheckValueOf = true) {
      if (key === null)
        return true;
      const keyType = typeof key;
      if (keyType === "string" || keyType === "bigint" || keyType === "boolean")
        return true;
      if (keyType === "number")
        return !isNaN(key);
      if (keyType === "symbol" || keyType === "undefined")
        return false;
      if (keyType === "function")
        return this.isKey(key());
      if (keyType === "object") {
        if (typeof key.toString === "function")
          return true;
        if (isCheckValueOf && typeof key.valueOf === "function") {
          this.isKey(key.valueOf(), false);
        }
        return false;
      }
      return false;
    }
    /**
     * Time Complexity O(n)
     * Space Complexity O(1)
     */
    /**
     * Time Complexity O(n)
     * Space Complexity O(1)
     *
     * The `add` function is used to insert a new node into a binary tree, checking for duplicate keys
     * and finding the appropriate insertion position.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The
     * `keyOrNodeOrEntryOrRawElement` parameter can accept a value of type `R`, which represents the key,
     * node, entry, or raw element to be added to the tree. It can also accept a value of type
     * `KeyOrNodeOrEntry<K, V, NODE>
     * @param {V} [value] - The `value` parameter is an optional value that can be associated with the
     * key being added to the tree. It represents the value that will be stored in the tree for the given
     * key.
     * @returns a boolean value. It returns `true` if the insertion is successful, and `false` if the
     * insertion position cannot be found or if there are duplicate keys.
     */
    add(keyOrNodeOrEntryOrRawElement, value) {
      const newNode = this.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value);
      if (newNode === void 0)
        return false;
      if (!this.root) {
        this._root = newNode;
        this._size = 1;
        return true;
      }
      const queue = new Queue([this.root]);
      let potentialParent;
      while (queue.size > 0) {
        const cur = queue.shift();
        if (!cur)
          continue;
        if (newNode !== null && cur.key === newNode.key) {
          this._replaceNode(cur, newNode);
          return true;
        }
        if (potentialParent === void 0 && (cur.left === void 0 || cur.right === void 0)) {
          potentialParent = cur;
        }
        if (cur.left !== null) {
          cur.left && queue.push(cur.left);
        }
        if (cur.right !== null) {
          cur.right && queue.push(cur.right);
        }
      }
      if (potentialParent) {
        if (potentialParent.left === void 0) {
          potentialParent.left = newNode;
        } else if (potentialParent.right === void 0) {
          potentialParent.right = newNode;
        }
        this._size++;
        return true;
      }
      return false;
    }
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     * Comments: The time complexity for adding a node depends on the depth of the tree. In the best case (when the tree is empty), it's O(1). In the worst case (when the tree is a degenerate tree), it's O(n). The space complexity is constant.
     */
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     *
     * The `addMany` function takes in an iterable of keys or nodes or entries or raw elements, and an
     * optional iterable of values, and adds each key or node or entry with its corresponding value to a
     * data structure, returning an array of booleans indicating whether each insertion was successful.
     * @param keysOrNodesOrEntriesOrRawElements - An iterable containing keys, nodes, entries, or raw
     * elements. These elements will be added to the data structure.
     * @param [values] - An optional iterable of values that correspond to the keys or nodes or entries
     * in the `keysOrNodesOrEntriesOrRawElements` parameter.
     * @returns The function `addMany` returns an array of booleans indicating whether each element was
     * successfully added to the data structure.
     */
    addMany(keysOrNodesOrEntriesOrRawElements, values) {
      const inserted = [];
      let valuesIterator;
      if (values) {
        valuesIterator = values[Symbol.iterator]();
      }
      for (const keyOrNodeOrEntryOrRawElement of keysOrNodesOrEntriesOrRawElements) {
        let value = void 0;
        if (valuesIterator) {
          const valueResult = valuesIterator.next();
          if (!valueResult.done) {
            value = valueResult.value;
          }
        }
        inserted.push(this.add(keyOrNodeOrEntryOrRawElement, value));
      }
      return inserted;
    }
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     * "n" is the number of nodes in the tree, and "k" is the number of keys to be inserted.
     */
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     *
     * The `refill` function clears the current data and adds new data to the collection.
     * @param keysOrNodesOrEntriesOrRawElements - An iterable collection of keys, nodes, entries, or raw
     * elements. These can be of any type (R) or a specific type (KeyOrNodeOrEntry<K, V, NODE>).
     * @param [values] - The `values` parameter is an optional iterable of values that will be associated
     * with the keys or nodes being added. If provided, the values will be assigned to the corresponding
     * keys or nodes. If not provided, the values will be set to `undefined`.
     */
    refill(keysOrNodesOrEntriesOrRawElements, values) {
      this.clear();
      this.addMany(keysOrNodesOrEntriesOrRawElements, values);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The above function is a TypeScript implementation of deleting a node from a binary tree, returning
     * the deleted node and the node that needs to be balanced.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * used to identify the node that needs to be deleted from the binary tree. It can be of any type
     * that is returned by the callback function.
     * @param {C} callback - The `callback` parameter is a function that is used to determine the
     * identifier of the node to be deleted. It is of type `C`, which extends the `BTNCallback<NODE>`
     * interface. The `BTNCallback<NODE>` interface represents a callback function that takes a node of
     * type `NODE
     * @returns an array of `BinaryTreeDeleteResult<NODE>`.
     */
    delete(identifier, callback = this._DEFAULT_CALLBACK) {
      const deletedResult = [];
      if (!this.root)
        return deletedResult;
      callback = this._ensureCallback(identifier, callback);
      const curr = this.getNode(identifier, callback);
      if (!curr)
        return deletedResult;
      const parent = curr == null ? void 0 : curr.parent;
      let needBalanced;
      let orgCurrent = curr;
      if (!curr.left && !curr.right && !parent) {
        this._setRoot(void 0);
      } else if (curr.left) {
        const leftSubTreeRightMost = this.getRightMost(curr.left);
        if (leftSubTreeRightMost) {
          const parentOfLeftSubTreeMax = leftSubTreeRightMost.parent;
          orgCurrent = this._swapProperties(curr, leftSubTreeRightMost);
          if (parentOfLeftSubTreeMax) {
            if (parentOfLeftSubTreeMax.right === leftSubTreeRightMost)
              parentOfLeftSubTreeMax.right = leftSubTreeRightMost.left;
            else
              parentOfLeftSubTreeMax.left = leftSubTreeRightMost.left;
            needBalanced = parentOfLeftSubTreeMax;
          }
        }
      } else if (parent) {
        const { familyPosition: fp } = curr;
        if (fp === "LEFT" || fp === "ROOT_LEFT") {
          parent.left = curr.right;
        } else if (fp === "RIGHT" || fp === "ROOT_RIGHT") {
          parent.right = curr.right;
        }
        needBalanced = parent;
      } else {
        this._setRoot(curr.right);
        curr.right = void 0;
      }
      this._size = this.size - 1;
      deletedResult.push({ deleted: orgCurrent, needBalanced });
      return deletedResult;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(k + log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(k + log n)
     *
     * The function `getNodes` returns an array of nodes that match a given identifier, using either a
     * recursive or iterative approach.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * that is used to identify the nodes. It can be of any type and is used to match against the result
     * of the callback function for each node.
     * @param {C} callback - The `callback` parameter is a function that takes a node as input and
     * returns a value. This value is used to identify the nodes that match the given identifier. The
     * `callback` function is optional and defaults to a default callback function
     * (`this._DEFAULT_CALLBACK`) if not provided.
     * @param [onlyOne=false] - A boolean value indicating whether to return only one node that matches
     * the identifier or all nodes that match the identifier. If set to true, only the first matching
     * node will be returned. If set to false, all matching nodes will be returned. The default value is
     * false.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the search. It can be either a node object, a key-value pair, or a key. If it is not
     * provided, the `root` of the data structure is used as the starting point.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be performed on the nodes of a binary tree. It can have two possible values:
     * @returns an array of NODE objects.
     */
    getNodes(identifier, callback = this._DEFAULT_CALLBACK, onlyOne = false, beginRoot = this.root, iterationType = this.iterationType) {
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return [];
      callback = this._ensureCallback(identifier, callback);
      const ans = [];
      if (iterationType === "RECURSIVE") {
        const dfs = (cur) => {
          if (callback(cur) === identifier) {
            ans.push(cur);
            if (onlyOne)
              return;
          }
          if (!this.isRealNode(cur.left) && !this.isRealNode(cur.right))
            return;
          this.isRealNode(cur.left) && dfs(cur.left);
          this.isRealNode(cur.right) && dfs(cur.right);
        };
        dfs(beginRoot);
      } else {
        const stack = [beginRoot];
        while (stack.length > 0) {
          const cur = stack.pop();
          if (this.isRealNode(cur)) {
            if (callback(cur) === identifier) {
              ans.push(cur);
              if (onlyOne)
                return ans;
            }
            this.isRealNode(cur.left) && stack.push(cur.left);
            this.isRealNode(cur.right) && stack.push(cur.right);
          }
        }
      }
      return ans;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n).
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n).
     *
     * The function `getNode` returns the first node that matches the given identifier and callback,
     * starting from the specified root node and using the specified iteration type.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * used to identify the node you want to retrieve. It can be of any type that is the return type of
     * the `C` callback function, or it can be `null` or `undefined`.
     * @param {C} callback - The `callback` parameter is a function that will be used to determine if a
     * node matches the desired criteria. It should return a value that can be used to identify the node.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for searching nodes in a tree structure. It can be either a root node, a key-value pair, or
     * a node entry. If not provided, the search will start from the root of the tree.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed when searching for nodes. It can have one of the following values:
     * @returns The method is returning a NODE object, or null, or undefined.
     */
    getNode(identifier, callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      var _a;
      return (_a = this.getNodes(identifier, callback, true, beginRoot, iterationType)[0]) != null ? _a : null;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `getNodeByKey` returns a node with a specific key value from a tree structure.
     * @param {K} key - The key parameter is the value that you want to search for in the tree. It is
     * used to find the node with the matching key value.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when searching for a node in the tree.
     * It has a default value of `'ITERATIVE'`.
     * @returns a value of type NODE, null, or undefined.
     */
    getNodeByKey(key, iterationType = "ITERATIVE") {
      return this.getNode(key, this._DEFAULT_CALLBACK, this.root, iterationType);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `get` in TypeScript overrides the base class method and returns the value associated
     * with the given identifier.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * used to identify the node in the binary tree. It can be of any type that is returned by the
     * callback function `C`. It can also be `null` or `undefined` if no identifier is provided.
     * @param {C} callback - The `callback` parameter is a function that will be used to determine if a
     * node matches the given identifier. It is optional and defaults to `this._DEFAULT_CALLBACK`.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the search in the binary tree. It can be either a root node of the tree or a key, node,
     * or entry object that exists in the tree. If no specific starting point is provided, the search
     * will begin from the root of the
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed when searching for a node in the tree. It can have one of the
     * following values:
     * @returns The method is returning the value associated with the specified identifier in the binary
     * tree.
     */
    get(identifier, callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      var _a;
      return (_a = this.getNode(identifier, callback, beginRoot, iterationType)) == null ? void 0 : _a.value;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `has` function checks if a given identifier exists in the data structure and returns a boolean
     * value.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * used to identify a specific node or entry in the data structure. It can be of any type that is
     * returned by the callback function `C`. It can also be `null` or `undefined` if no specific
     * identifier is provided.
     * @param {C} callback - The `callback` parameter is a function that will be used to determine
     * whether a node should be included in the result or not. It is of type `C`, which extends the
     * `BTNCallback<NODE>` type.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the iteration in the data structure. It can be either a root node, a key-value pair, or
     * a node entry. If not specified, it defaults to the root of the data structure.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed. It is an optional parameter with a default value of `IterationType`.
     * @returns The method is returning a boolean value.
     */
    has(identifier, callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      callback = this._ensureCallback(identifier, callback);
      return this.getNodes(identifier, callback, true, beginRoot, iterationType).length > 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Clear the binary tree, removing all nodes.
     */
    clear() {
      this._setRoot(void 0);
      this._size = 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Check if the binary tree is empty.
     * @returns {boolean} - True if the binary tree is empty, false otherwise.
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function checks if a binary tree is perfectly balanced by comparing the minimum height and the
     * height of the tree.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The parameter `beginRoot` is optional and
     * has a default value of `this.root`. It represents the starting point for checking if the tree is
     * perfectly balanced. It can be either a root node (`R`), a key or node or entry
     * (`KeyOrNodeOrEntry<K, V, NODE
     * @returns a boolean value.
     */
    isPerfectlyBalanced(beginRoot = this.root) {
      return this.getMinHeight(beginRoot) + 1 >= this.getHeight(beginRoot);
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `isBST` checks if a binary search tree is valid, either recursively or iteratively.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for checking if a binary search tree (BST) is valid. It can be either a root node
     * of the BST, a key value of a node in the BST, or an entry object containing both the key and value
     * of a node in the BST
     * @param {IterationType} iterationType - The `iterationType` parameter is used to determine the type
     * of iteration to be performed while checking if the binary search tree (BST) is valid. It can have
     * two possible values:
     * @returns a boolean value.
     */
    isBST(beginRoot = this.root, iterationType = this.iterationType) {
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return true;
      if (iterationType === "RECURSIVE") {
        const dfs = (cur, min, max) => {
          if (!this.isRealNode(cur))
            return true;
          const numKey = Number(cur.key);
          if (numKey <= min || numKey >= max)
            return false;
          return dfs(cur.left, min, numKey) && dfs(cur.right, numKey, max);
        };
        const isStandardBST = dfs(beginRoot, Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
        const isInverseBST = dfs(beginRoot, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
        return isStandardBST || isInverseBST;
      } else {
        const checkBST = (checkMax = false) => {
          const stack = [];
          let prev = checkMax ? Number.MAX_SAFE_INTEGER : Number.MIN_SAFE_INTEGER;
          let curr = beginRoot;
          while (this.isRealNode(curr) || stack.length > 0) {
            while (this.isRealNode(curr)) {
              stack.push(curr);
              curr = curr.left;
            }
            curr = stack.pop();
            const numKey = Number(curr.key);
            if (!this.isRealNode(curr) || !checkMax && prev >= numKey || checkMax && prev <= numKey)
              return false;
            prev = numKey;
            curr = curr.right;
          }
          return true;
        };
        const isStandardBST = checkBST(false), isInverseBST = checkBST(true);
        return isStandardBST || isInverseBST;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function calculates the depth of a given node or key in a tree-like data structure.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} dist - The `dist` parameter can be either a `R`
     * (representing a root node), or a `KeyOrNodeOrEntry<K, V, NODE>` (representing a key, node, or
     * entry).
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is optional and
     * represents the starting point from which to calculate the depth. It can be either a reference to a
     * node in the tree or a key-value pair or an entry object. If not provided, the default value is
     * `this.root`, which refers to the root node
     * @returns the depth of a node in a tree structure.
     */
    getDepth(dist, beginRoot = this.root) {
      let distEnsured = this.ensureNode(dist);
      const beginRootEnsured = this.ensureNode(beginRoot);
      let depth = 0;
      while (distEnsured == null ? void 0 : distEnsured.parent) {
        if (distEnsured === beginRootEnsured) {
          return depth;
        }
        depth++;
        distEnsured = distEnsured.parent;
      }
      return depth;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `getHeight` function calculates the maximum height of a binary tree using either a recursive
     * or iterative approach.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for calculating the height of a tree. It can be either a root node (`R`), a key or
     * node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or it defaults to the root of the current tree.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration used to calculate the height of the tree. It can have two possible values:
     * @returns the maximum height of the binary tree.
     */
    getHeight(beginRoot = this.root, iterationType = this.iterationType) {
      beginRoot = this.ensureNode(beginRoot);
      if (!this.isRealNode(beginRoot))
        return -1;
      if (iterationType === "RECURSIVE") {
        const _getMaxHeight = (cur) => {
          if (!this.isRealNode(cur))
            return -1;
          const leftHeight = _getMaxHeight(cur.left);
          const rightHeight = _getMaxHeight(cur.right);
          return Math.max(leftHeight, rightHeight) + 1;
        };
        return _getMaxHeight(beginRoot);
      } else {
        const stack = [{ node: beginRoot, depth: 0 }];
        let maxHeight = 0;
        while (stack.length > 0) {
          const { node, depth } = stack.pop();
          if (this.isRealNode(node.left))
            stack.push({ node: node.left, depth: depth + 1 });
          if (this.isRealNode(node.right))
            stack.push({ node: node.right, depth: depth + 1 });
          maxHeight = Math.max(maxHeight, depth);
        }
        return maxHeight;
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `getMinHeight` function calculates the minimum height of a binary tree using either a
     * recursive or iterative approach.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for calculating the minimum height of a tree. It can be either a root node (`R`), a
     * key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or it defaults to the root of the current
     * tree.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be used when calculating the minimum height of the tree. It can have two possible
     * values:
     * @returns The function `getMinHeight` returns a number, which represents the minimum height of the
     * binary tree.
     */
    getMinHeight(beginRoot = this.root, iterationType = this.iterationType) {
      var _a, _b, _c;
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return -1;
      if (iterationType === "RECURSIVE") {
        const _getMinHeight = (cur) => {
          if (!this.isRealNode(cur))
            return 0;
          if (!this.isRealNode(cur.left) && !this.isRealNode(cur.right))
            return 0;
          const leftMinHeight = _getMinHeight(cur.left);
          const rightMinHeight = _getMinHeight(cur.right);
          return Math.min(leftMinHeight, rightMinHeight) + 1;
        };
        return _getMinHeight(beginRoot);
      } else {
        const stack = [];
        let node = beginRoot, last = null;
        const depths = /* @__PURE__ */ new Map();
        while (stack.length > 0 || node) {
          if (this.isRealNode(node)) {
            stack.push(node);
            node = node.left;
          } else {
            node = stack[stack.length - 1];
            if (!this.isRealNode(node.right) || last === node.right) {
              node = stack.pop();
              if (this.isRealNode(node)) {
                const leftMinHeight = this.isRealNode(node.left) ? (_a = depths.get(node.left)) != null ? _a : -1 : -1;
                const rightMinHeight = this.isRealNode(node.right) ? (_b = depths.get(node.right)) != null ? _b : -1 : -1;
                depths.set(node, 1 + Math.min(leftMinHeight, rightMinHeight));
                last = node;
                node = null;
              }
            } else
              node = node.right;
          }
        }
        return (_c = depths.get(beginRoot)) != null ? _c : -1;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     *
     * The function `getPathToRoot` returns an array of nodes starting from a given node and traversing
     * up to the root node, with an option to reverse the order of the nodes.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginNode - The `beginNode` parameter can be either of
     * type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param [isReverse=true] - The `isReverse` parameter is a boolean flag that determines whether the
     * resulting path should be reversed or not. If `isReverse` is set to `true`, the path will be
     * reversed before returning it. If `isReverse` is set to `false` or not provided, the path will
     * @returns The function `getPathToRoot` returns an array of `NODE` objects.
     */
    getPathToRoot(beginNode, isReverse = true) {
      const result = [];
      let beginNodeEnsured = this.ensureNode(beginNode);
      if (!beginNodeEnsured)
        return result;
      while (beginNodeEnsured.parent) {
        result.push(beginNodeEnsured);
        beginNodeEnsured = beginNodeEnsured.parent;
      }
      result.push(beginNodeEnsured);
      return isReverse ? result.reverse() : result;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `getLeftMost` function returns the leftmost node in a binary tree, either using recursive or
     * iterative traversal.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for finding the leftmost node in a binary tree. It can be either a root node (`R`),
     * a key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or `null` or `undefined`.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed. It can have two possible values:
     * @returns The function `getLeftMost` returns the leftmost node in a binary tree.
     */
    getLeftMost(beginRoot = this.root, iterationType = this.iterationType) {
      if (this.isNIL(beginRoot))
        return beginRoot;
      beginRoot = this.ensureNode(beginRoot);
      if (!this.isRealNode(beginRoot))
        return beginRoot;
      if (iterationType === "RECURSIVE") {
        const dfs = (cur) => {
          if (!this.isRealNode(cur.left))
            return cur;
          return dfs(cur.left);
        };
        return dfs(beginRoot);
      } else {
        const dfs = trampoline((cur) => {
          if (!this.isRealNode(cur.left))
            return cur;
          return dfs.cont(cur.left);
        });
        return dfs(beginRoot);
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `getRightMost` function returns the rightmost node in a binary tree, either recursively or
     * iteratively.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for finding the rightmost node in a binary tree. It can be either a root node
     * (`R`), a key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or `null` or `undefined`.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed when finding the rightmost node in a binary tree. It can have two
     * possible values:
     * @returns The function `getRightMost` returns a NODE object, `null`, or `undefined`.
     */
    getRightMost(beginRoot = this.root, iterationType = this.iterationType) {
      if (this.isNIL(beginRoot))
        return beginRoot;
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return beginRoot;
      if (iterationType === "RECURSIVE") {
        const dfs = (cur) => {
          if (!this.isRealNode(cur.right))
            return cur;
          return dfs(cur.right);
        };
        return dfs(beginRoot);
      } else {
        const dfs = trampoline((cur) => {
          if (!this.isRealNode(cur.right))
            return cur;
          return dfs.cont(cur.right);
        });
        return dfs(beginRoot);
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function returns the predecessor node of a given node in a binary tree.
     * @param {NODE} node - The parameter "node" is of type "NODE", which represents a node in a binary
     * tree.
     * @returns the predecessor node of the given node.
     */
    getPredecessor(node) {
      if (this.isRealNode(node.left)) {
        let predecessor = node.left;
        while (!this.isRealNode(predecessor) || this.isRealNode(predecessor.right) && predecessor.right !== node) {
          if (this.isRealNode(predecessor)) {
            predecessor = predecessor.right;
          }
        }
        return predecessor;
      } else {
        return node;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getSuccessor` returns the next node in a binary tree given a current node.
     * @param {K | NODE | null} [x] - The parameter `x` can be of type `K`, `NODE`, or `null`.
     * @returns The function `getSuccessor` returns a `NODE` object if a successor exists, `null` if
     * there is no successor, and `undefined` if the input `x` is not a valid node.
     */
    getSuccessor(x) {
      x = this.ensureNode(x);
      if (!this.isRealNode(x))
        return void 0;
      if (this.isRealNode(x.right)) {
        return this.getLeftMost(x.right);
      }
      let y = x.parent;
      while (this.isRealNode(y) && x === y.right) {
        x = y;
        y = y.parent;
      }
      return y;
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `dfs` function performs a depth-first search traversal on a binary tree, executing a callback
     * function on each node according to a specified pattern and iteration type.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node
     * visited during the depth-first search. It takes a node as an argument and returns a value. The
     * return type of the callback function is determined by the generic type `C`.
     * @param {DFSOrderPattern} [pattern=IN] - The `pattern` parameter determines the order in which the
     * nodes are visited during the depth-first search. It can have one of the following values:
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point of the depth-first search. It can be either a node object, a key-value pair, or a key. If it
     * is a key or key-value pair, the method will find the corresponding node in the tree and start the
     * search from there.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter determines the
     * type of iteration to use during the depth-first search. It can have two possible values:
     * @param [includeNull=false] - The `includeNull` parameter is a boolean value that determines
     * whether or not to include null values in the depth-first search traversal. If `includeNull` is set
     * to `true`, null values will be included in the traversal. If `includeNull` is set to `false`, null
     * values will
     * @returns an array of the return types of the callback function.
     */
    dfs(callback = this._DEFAULT_CALLBACK, pattern = "IN", beginRoot = this.root, iterationType = "ITERATIVE", includeNull = false) {
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return [];
      const ans = [];
      if (iterationType === "RECURSIVE") {
        const dfs = (node) => {
          switch (pattern) {
            case "IN":
              if (includeNull) {
                if (this.isRealNode(node) && this.isNodeOrNull(node.left))
                  dfs(node.left);
                this.isNodeOrNull(node) && ans.push(callback(node));
                if (this.isRealNode(node) && this.isNodeOrNull(node.right))
                  dfs(node.right);
              } else {
                if (this.isRealNode(node) && this.isRealNode(node.left))
                  dfs(node.left);
                this.isRealNode(node) && ans.push(callback(node));
                if (this.isRealNode(node) && this.isRealNode(node.right))
                  dfs(node.right);
              }
              break;
            case "PRE":
              if (includeNull) {
                this.isNodeOrNull(node) && ans.push(callback(node));
                if (this.isRealNode(node) && this.isNodeOrNull(node.left))
                  dfs(node.left);
                if (this.isRealNode(node) && this.isNodeOrNull(node.right))
                  dfs(node.right);
              } else {
                this.isRealNode(node) && ans.push(callback(node));
                if (this.isRealNode(node) && this.isRealNode(node.left))
                  dfs(node.left);
                if (this.isRealNode(node) && this.isRealNode(node.right))
                  dfs(node.right);
              }
              break;
            case "POST":
              if (includeNull) {
                if (this.isRealNode(node) && this.isNodeOrNull(node.left))
                  dfs(node.left);
                if (this.isRealNode(node) && this.isNodeOrNull(node.right))
                  dfs(node.right);
                this.isNodeOrNull(node) && ans.push(callback(node));
              } else {
                if (this.isRealNode(node) && this.isRealNode(node.left))
                  dfs(node.left);
                if (this.isRealNode(node) && this.isRealNode(node.right))
                  dfs(node.right);
                this.isRealNode(node) && ans.push(callback(node));
              }
              break;
          }
        };
        dfs(beginRoot);
      } else {
        const stack = [{ opt: 0, node: beginRoot }];
        while (stack.length > 0) {
          const cur = stack.pop();
          if (cur === void 0 || this.isNIL(cur.node))
            continue;
          if (includeNull) {
            if (cur.node === void 0)
              continue;
          } else {
            if (cur.node === null || cur.node === void 0)
              continue;
          }
          if (cur.opt === 1) {
            ans.push(callback(cur.node));
          } else {
            switch (pattern) {
              case "IN":
                cur.node && stack.push({ opt: 0, node: cur.node.right });
                stack.push({ opt: 1, node: cur.node });
                cur.node && stack.push({ opt: 0, node: cur.node.left });
                break;
              case "PRE":
                cur.node && stack.push({ opt: 0, node: cur.node.right });
                cur.node && stack.push({ opt: 0, node: cur.node.left });
                stack.push({ opt: 1, node: cur.node });
                break;
              case "POST":
                stack.push({ opt: 1, node: cur.node });
                cur.node && stack.push({ opt: 0, node: cur.node.right });
                cur.node && stack.push({ opt: 0, node: cur.node.left });
                break;
              default:
                cur.node && stack.push({ opt: 0, node: cur.node.right });
                stack.push({ opt: 1, node: cur.node });
                cur.node && stack.push({ opt: 0, node: cur.node.left });
                break;
            }
          }
        }
      }
      return ans;
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `bfs` function performs a breadth-first search on a binary tree, calling a callback function
     * on each node and returning an array of the results.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node in
     * the breadth-first search traversal. It takes a single argument, which is the current node being
     * visited, and returns a value of any type.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point of the breadth-first search. It can be either a root node of a tree or a key, node,
     * or entry object. If no value is provided, the `root` property of the class is used as the default
     * starting point.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be performed. It can have two possible values:
     * @param [includeNull=false] - The `includeNull` parameter is a boolean value that determines
     * whether or not to include null values in the breadth-first search (BFS) traversal. If
     * `includeNull` is set to `true`, null values will be included in the traversal. If `includeNull` is
     * set to `false
     * @returns The function `bfs` returns an array of values that are the result of invoking the
     * `callback` function on each node in the breadth-first order traversal of the binary tree.
     */
    bfs(callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType, includeNull = false) {
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return [];
      const ans = [];
      if (iterationType === "RECURSIVE") {
        const queue = new Queue([beginRoot]);
        const dfs = (level) => {
          if (queue.size === 0)
            return;
          const current = queue.shift();
          ans.push(callback(current));
          if (includeNull) {
            if (current && this.isNodeOrNull(current.left))
              queue.push(current.left);
            if (current && this.isNodeOrNull(current.right))
              queue.push(current.right);
          } else {
            if (this.isRealNode(current.left))
              queue.push(current.left);
            if (this.isRealNode(current.right))
              queue.push(current.right);
          }
          dfs(level + 1);
        };
        dfs(0);
      } else {
        const queue = new Queue([beginRoot]);
        while (queue.size > 0) {
          const levelSize = queue.size;
          for (let i = 0; i < levelSize; i++) {
            const current = queue.shift();
            ans.push(callback(current));
            if (includeNull) {
              if (current && this.isNodeOrNull(current.left))
                queue.push(current.left);
              if (current && this.isNodeOrNull(current.right))
                queue.push(current.right);
            } else {
              if (this.isRealNode(current.left))
                queue.push(current.left);
              if (this.isRealNode(current.right))
                queue.push(current.right);
            }
          }
        }
      }
      return ans;
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `listLevels` function returns an array of arrays, where each inner array represents a level in
     * a binary tree and contains the results of applying a callback function to the nodes at that level.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node in
     * the tree. It takes a node as an argument and returns a value. The return type of the callback
     * function is determined by the generic type `C` which extends `BTNCallback<NODE | null>`.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for traversing the tree. It can be either a root node, a key-value pair, or a node
     * entry. If no value is provided, the `root` property of the class is used as the default starting
     * point.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be performed on the binary tree. It can have two possible values:
     * @param [includeNull=false] - The `includeNull` parameter is a boolean value that determines
     * whether or not to include null values in the resulting levels. If `includeNull` is set to `true`,
     * null values will be included in the levels. If `includeNull` is set to `false`, null values will
     * be excluded
     * @returns The function `listLevels` returns a two-dimensional array of type `ReturnType<C>[][]`.
     */
    listLevels(callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType, includeNull = false) {
      beginRoot = this.ensureNode(beginRoot);
      const levelsNodes = [];
      if (!beginRoot)
        return levelsNodes;
      if (iterationType === "RECURSIVE") {
        const _recursive = (node, level) => {
          if (!levelsNodes[level])
            levelsNodes[level] = [];
          levelsNodes[level].push(callback(node));
          if (includeNull) {
            if (node && this.isNodeOrNull(node.left))
              _recursive(node.left, level + 1);
            if (node && this.isNodeOrNull(node.right))
              _recursive(node.right, level + 1);
          } else {
            if (node && node.left)
              _recursive(node.left, level + 1);
            if (node && node.right)
              _recursive(node.right, level + 1);
          }
        };
        _recursive(beginRoot, 0);
      } else {
        const stack = [[beginRoot, 0]];
        while (stack.length > 0) {
          const head = stack.pop();
          const [node, level] = head;
          if (!levelsNodes[level])
            levelsNodes[level] = [];
          levelsNodes[level].push(callback(node));
          if (includeNull) {
            if (node && this.isNodeOrNull(node.right))
              stack.push([node.right, level + 1]);
            if (node && this.isNodeOrNull(node.left))
              stack.push([node.left, level + 1]);
          } else {
            if (node && node.right)
              stack.push([node.right, level + 1]);
            if (node && node.left)
              stack.push([node.left, level + 1]);
          }
        }
      }
      return levelsNodes;
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `morris` function performs a depth-first traversal on a binary tree using the Morris traversal
     * algorithm.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node in
     * the tree. It takes a single argument, which is the current node, and can return any value. The
     * return type of the `callback` function is determined by the `ReturnType<C>` type, which represents
     * the return
     * @param {DFSOrderPattern} [pattern=IN] - The `pattern` parameter in the `morris` function is used
     * to specify the order in which the nodes of a binary tree are traversed. It can take one of the
     * following values:
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the traversal. It can be either a node object, a key, or an entry object. If no value is
     * provided, the `root` of the tree is used as the starting point.
     * @returns The function `morris` returns an array of values that are the return values of the
     * callback function `callback`.
     */
    morris(callback = this._DEFAULT_CALLBACK, pattern = "IN", beginRoot = this.root) {
      beginRoot = this.ensureNode(beginRoot);
      if (beginRoot === null)
        return [];
      const ans = [];
      let cur = beginRoot;
      const _reverseEdge = (node) => {
        let pre = null;
        let next = null;
        while (node) {
          next = node.right;
          node.right = pre;
          pre = node;
          node = next;
        }
        return pre;
      };
      const _printEdge = (node) => {
        const tail = _reverseEdge(node);
        let cur2 = tail;
        while (cur2) {
          ans.push(callback(cur2));
          cur2 = cur2.right;
        }
        _reverseEdge(tail);
      };
      switch (pattern) {
        case "IN":
          while (cur) {
            if (cur.left) {
              const predecessor = this.getPredecessor(cur);
              if (!predecessor.right) {
                predecessor.right = cur;
                cur = cur.left;
                continue;
              } else {
                predecessor.right = null;
              }
            }
            ans.push(callback(cur));
            cur = cur.right;
          }
          break;
        case "PRE":
          while (cur) {
            if (cur.left) {
              const predecessor = this.getPredecessor(cur);
              if (!predecessor.right) {
                predecessor.right = cur;
                ans.push(callback(cur));
                cur = cur.left;
                continue;
              } else {
                predecessor.right = null;
              }
            } else {
              ans.push(callback(cur));
            }
            cur = cur.right;
          }
          break;
        case "POST":
          while (cur) {
            if (cur.left) {
              const predecessor = this.getPredecessor(cur);
              if (predecessor.right === null) {
                predecessor.right = cur;
                cur = cur.left;
                continue;
              } else {
                predecessor.right = null;
                _printEdge(cur.left);
              }
            }
            cur = cur.right;
          }
          _printEdge(beginRoot);
          break;
      }
      return ans;
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `clone` function creates a deep copy of a tree object.
     * @returns The `clone()` method is returning a cloned instance of the `TREE` object.
     */
    clone() {
      const cloned = this.createTree();
      this.bfs(
        (node) => {
          if (node === null)
            cloned.add(null);
          else
            cloned.add([node.key, node.value]);
        },
        this.root,
        this.iterationType,
        true
      );
      return cloned;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new tree with entries that pass a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that is used to test each
     * element in the tree. It takes three arguments: `value`, `key`, and `index`. The `value` argument
     * represents the value of the current element being processed, the `key` argument represents the key
     * of the
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. When the `predicate` function is
     * called, `thisArg` will be used as the value of `this` within the function. If `thisArg`
     * @returns The `filter` method is returning a new tree object that contains the entries that pass
     * the given predicate function.
     */
    filter(predicate, thisArg) {
      const newTree = this.createTree();
      let index = 0;
      for (const [key, value] of this) {
        if (predicate.call(thisArg, value, key, index++, this)) {
          newTree.add([key, value]);
        }
      }
      return newTree;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new tree by applying a callback function to each entry in the current
     * tree.
     * @param callback - The callback parameter is a function that will be called for each entry in the
     * tree. It takes three arguments: value, key, and index. The value argument represents the value of
     * the current entry, the key argument represents the key of the current entry, and the index
     * argument represents the index of the
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `map` method is returning a new tree object.
     */
    map(callback, thisArg) {
      const newTree = this.createTree();
      let index = 0;
      for (const [key, value] of this) {
        newTree.add([key, callback.call(thisArg, value, key, index++, this)]);
      }
      return newTree;
    }
    // // TODO Type error, need to return a TREE<NV> that is a value type only for callback function.
    // // map<NV>(callback: (entry: [K, V | undefined], tree: this) => NV) {
    // //   const newTree = this.createTree();
    // //   for (const [key, value] of this) {
    // //     newTree.add(key, callback([key, value], this));
    // //   }
    // //   return newTree;
    // // }
    //
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `print` function in TypeScript prints the binary tree structure with customizable options.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for printing the binary tree. It can be either a node of the binary tree or a key or entry
     * that exists in the binary tree. If no value is provided, the root of the binary tree will be used
     * as the starting point.
     * @param {BinaryTreePrintOptions} [options] - The `options` parameter is an optional object that
     * allows you to customize the printing behavior. It has the following properties:
     * @returns Nothing is being returned. The function has a return type of `void`, which means it does
     * not return any value.
     */
    print(beginRoot = this.root, options) {
      const opts = __spreadValues({ isShowUndefined: false, isShowNull: false, isShowRedBlackNIL: false }, options);
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return;
      if (opts.isShowUndefined)
        console.log(`U for undefined
      `);
      if (opts.isShowNull)
        console.log(`N for null
      `);
      if (opts.isShowRedBlackNIL)
        console.log(`S for Sentinel Node(NIL)
      `);
      const display = (root) => {
        const [lines, , ,] = this._displayAux(root, opts);
        for (const line of lines) {
          console.log(line);
        }
      };
      display(beginRoot);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_getIterator` is a generator function that returns an iterator for the key-value
     * pairs in a binary search tree.
     * @param node - The `node` parameter represents the current node in the binary search tree. It is
     * initially set to the root node of the tree.
     * @returns an IterableIterator<[K, V | undefined]>.
     */
    *_getIterator(node = this.root) {
      if (!node)
        return;
      if (this.iterationType === "ITERATIVE") {
        const stack = [];
        let current = node;
        while (current || stack.length > 0) {
          while (this.isRealNode(current)) {
            stack.push(current);
            current = current.left;
          }
          current = stack.pop();
          if (this.isRealNode(current)) {
            yield [current.key, current.value];
            current = current.right;
          }
        }
      } else {
        if (node.left && this.isRealNode(node)) {
          yield* __yieldStar(this[Symbol.iterator](node.left));
        }
        yield [node.key, node.value];
        if (node.right && this.isRealNode(node)) {
          yield* __yieldStar(this[Symbol.iterator](node.right));
        }
      }
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `_displayAux` function is responsible for generating the display layout of a binary tree node,
     * taking into account various options such as whether to show null, undefined, or NaN nodes.
     * @param {NODE | null | undefined} node - The `node` parameter represents a node in a binary tree.
     * It can be of type `NODE`, `null`, or `undefined`.
     * @param {BinaryTreePrintOptions} options - The `options` parameter is an object that contains the
     * following properties:
     * @returns The function `_displayAux` returns a `NodeDisplayLayout` which is an array containing the
     * following elements:
     * 1. `mergedLines`: An array of strings representing the lines of the node display.
     * 2. `totalWidth`: The total width of the node display.
     * 3. `totalHeight`: The total height of the node display.
     * 4. `middleIndex`: The index of the middle character
     */
    _displayAux(node, options) {
      const { isShowNull, isShowUndefined, isShowRedBlackNIL } = options;
      const emptyDisplayLayout = [["\u2500"], 1, 0, 0];
      if (node === null && !isShowNull) {
        return emptyDisplayLayout;
      } else if (node === void 0 && !isShowUndefined) {
        return emptyDisplayLayout;
      } else if (this.isNIL(node) && !isShowRedBlackNIL) {
        return emptyDisplayLayout;
      } else if (node !== null && node !== void 0) {
        const key = node.key, line = this.isNIL(node) ? "S" : String(key), width = line.length;
        return _buildNodeDisplay(
          line,
          width,
          this._displayAux(node.left, options),
          this._displayAux(node.right, options)
        );
      } else {
        const line = node === void 0 ? "U" : "N", width = line.length;
        return _buildNodeDisplay(line, width, [[""], 1, 0, 0], [[""], 1, 0, 0]);
      }
      function _buildNodeDisplay(line, width, left, right) {
        const [leftLines, leftWidth, leftHeight, leftMiddle] = left;
        const [rightLines, rightWidth, rightHeight, rightMiddle] = right;
        const firstLine = " ".repeat(Math.max(0, leftMiddle + 1)) + "_".repeat(Math.max(0, leftWidth - leftMiddle - 1)) + line + "_".repeat(Math.max(0, rightMiddle)) + " ".repeat(Math.max(0, rightWidth - rightMiddle));
        const secondLine = (leftHeight > 0 ? " ".repeat(leftMiddle) + "/" + " ".repeat(leftWidth - leftMiddle - 1) : " ".repeat(leftWidth)) + " ".repeat(width) + (rightHeight > 0 ? " ".repeat(rightMiddle) + "\\" + " ".repeat(rightWidth - rightMiddle - 1) : " ".repeat(rightWidth));
        const mergedLines = [firstLine, secondLine];
        for (let i = 0; i < Math.max(leftHeight, rightHeight); i++) {
          const leftLine = i < leftHeight ? leftLines[i] : " ".repeat(leftWidth);
          const rightLine = i < rightHeight ? rightLines[i] : " ".repeat(rightWidth);
          mergedLines.push(leftLine + " ".repeat(width) + rightLine);
        }
        return [
          mergedLines,
          leftWidth + width + rightWidth,
          Math.max(leftHeight, rightHeight) + 2,
          leftWidth + Math.floor(width / 2)
        ];
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_swapProperties` swaps the key-value properties between two nodes.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} srcNode - The source node that will be swapped with the
     * destination node. It can be either an instance of the class `R`, or an object of type
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} destNode - The `destNode` parameter is the node where
     * the properties will be swapped with the `srcNode`.
     * @returns either the `destNode` object with its properties swapped with the `srcNode` object's
     * properties, or `undefined` if either `srcNode` or `destNode` is falsy.
     */
    _swapProperties(srcNode, destNode) {
      srcNode = this.ensureNode(srcNode);
      destNode = this.ensureNode(destNode);
      if (srcNode && destNode) {
        const { key, value } = destNode;
        const tempNode = this.createNode(key, value);
        if (tempNode) {
          destNode.key = srcNode.key;
          destNode.value = srcNode.value;
          srcNode.key = tempNode.key;
          srcNode.value = tempNode.value;
        }
        return destNode;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces a node in a binary tree with a new node, updating the parent, left child,
     * right child, and root if necessary.
     * @param {NODE} oldNode - The oldNode parameter represents the node that needs to be replaced in the
     * tree.
     * @param {NODE} newNode - The `newNode` parameter is the node that will replace the `oldNode` in the
     * tree.
     * @returns the newNode.
     */
    _replaceNode(oldNode, newNode) {
      if (oldNode.parent) {
        if (oldNode.parent.left === oldNode) {
          oldNode.parent.left = newNode;
        } else if (oldNode.parent.right === oldNode) {
          oldNode.parent.right = newNode;
        }
      }
      newNode.left = oldNode.left;
      newNode.right = oldNode.right;
      newNode.parent = oldNode.parent;
      if (this.root === oldNode) {
        this._root = newNode;
      }
      return newNode;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function sets the root property of an object to the provided value, and also updates the
     * parent property of the new root.
     * @param {NODE | null | undefined} v - The parameter `v` is of type `NODE | null | undefined`. This
     * means that it can accept a value of type `NODE`, `null`, or `undefined`.
     */
    _setRoot(v) {
      if (v) {
        v.parent = void 0;
      }
      this._root = v;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_ensureCallback` ensures that a callback function is provided and returns it.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is of type
     * `ReturnType<C> | null | undefined`. This means it can accept a value that is the return type of
     * the generic type `C`, or it can be `null` or `undefined`.
     * @param {C} callback - The `callback` parameter is a function that takes a `node` as an argument
     * and returns a value. It is of type `C`, which is a generic type that extends the
     * `BTNCallback<NODE>` type.
     * @returns the callback parameter.
     */
    _ensureCallback(identifier, callback = this._DEFAULT_CALLBACK) {
      if ((!callback || callback === this._DEFAULT_CALLBACK) && this.isNode(identifier)) {
        callback = (node) => node;
      }
      return callback;
    }
  };

  // src/data-structures/binary-tree/bst.ts
  var BSTNode = class extends BinaryTreeNode {
    constructor(key, value) {
      super(key, value);
      __publicField(this, "parent");
      __publicField(this, "_left");
      __publicField(this, "_right");
      this.parent = void 0;
      this._left = void 0;
      this._right = void 0;
    }
    /**
     * The function returns the value of the `_left` property.
     * @returns The `_left` property of the current object is being returned.
     */
    get left() {
      return this._left;
    }
    /**
     * The function sets the left child of a node and updates the parent reference of the child.
     * @param {NODE | undefined} v - The parameter `v` is of type `NODE | undefined`. It can either be an
     * instance of the `NODE` class or `undefined`.
     */
    set left(v) {
      if (v) {
        v.parent = this;
      }
      this._left = v;
    }
    /**
     * The function returns the right node of a binary tree or undefined if there is no right node.
     * @returns The method is returning the value of the `_right` property, which is of type `NODE` or
     * `undefined`.
     */
    get right() {
      return this._right;
    }
    /**
     * The function sets the right child of a node and updates the parent reference of the child.
     * @param {NODE | undefined} v - The parameter `v` is of type `NODE | undefined`. It can either be a
     * `NODE` object or `undefined`.
     */
    set right(v) {
      if (v) {
        v.parent = this;
      }
      this._right = v;
    }
  };
  var BST = class _BST extends BinaryTree {
    /**
     * This is the constructor function for a Binary Search Tree class in TypeScript.
     * @param keysOrNodesOrEntriesOrRawElements - The `keysOrNodesOrEntriesOrRawElements` parameter is an
     * iterable that can contain either keys, nodes, entries, or raw elements. These elements will be
     * added to the binary search tree during the construction of the object.
     * @param [options] - An optional object that contains additional options for the Binary Search Tree.
     * It can include a comparator function that defines the order of the elements in the tree.
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super([], options);
      __publicField(this, "_root");
      __publicField(this, "_DEFAULT_COMPARATOR", (a, b) => {
        if (typeof a === "object" || typeof b === "object") {
          throw TypeError(
            `When comparing object types, a custom comparator must be defined in the constructor's options parameter.`
          );
        }
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        return 0;
      });
      __publicField(this, "_comparator", this._DEFAULT_COMPARATOR);
      if (options) {
        const { comparator } = options;
        if (comparator)
          this._comparator = comparator;
      }
      if (keysOrNodesOrEntriesOrRawElements)
        this.addMany(keysOrNodesOrEntriesOrRawElements);
    }
    /**
     * The function returns the root node of a tree structure.
     * @returns The `_root` property of the object, which is of type `NODE` or `undefined`.
     */
    get root() {
      return this._root;
    }
    /**
     * The function creates a new BSTNode with the given key and value and returns it.
     * @param {K} key - The key parameter is of type K, which represents the type of the key for the node
     * being created.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It represents the
     * value associated with the key in the node being created.
     * @returns The method is returning a new instance of the BSTNode class, casted as the NODE type.
     */
    createNode(key, value) {
      return new BSTNode(key, value);
    }
    /**
     * The function creates a new binary search tree with the specified options.
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the `createTree` method. It accepts a partial `BSTOptions` object, which has the
     * following properties:
     * @returns a new instance of the BST class with the provided options.
     */
    createTree(options) {
      return new _BST([], __spreadValues({
        iterationType: this.iterationType,
        comparator: this.comparator
      }, options));
    }
    /**
     * The function overrides a method and converts a key, value pair or entry or raw element to a node.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - A variable that can be of
     * type R or KeyOrNodeOrEntry<K, V, NODE>. It represents either a key, a node, an entry, or a raw
     * element.
     * @param {V} [value] - The `value` parameter is an optional value of type `V`. It represents the
     * value associated with a key in a key-value pair.
     * @returns either a NODE object or undefined.
     */
    keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value) {
      var _a;
      return (_a = super.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value)) != null ? _a : void 0;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     *
     * The function ensures the existence of a node in a data structure and returns it, or undefined if
     * it doesn't exist.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept a value of type `R`, which represents the key, node,
     * entry, or raw element that needs to be ensured in the tree.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when ensuring a node. It has a default
     * value of `'ITERATIVE'`.
     * @returns The method is returning either the node that was ensured or `undefined` if the node could
     * not be ensured.
     */
    ensureNode(keyOrNodeOrEntryOrRawElement, iterationType = "ITERATIVE") {
      var _a;
      return (_a = super.ensureNode(keyOrNodeOrEntryOrRawElement, iterationType)) != null ? _a : void 0;
    }
    /**
     * The function checks if the input is an instance of the BSTNode class.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `BSTNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof BSTNode;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `add` function in TypeScript adds a new node to a binary search tree based on the key value.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept a value of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that can be associated with the
     * key in the binary search tree. If provided, it will be stored in the node along with the key.
     * @returns a boolean value.
     */
    add(keyOrNodeOrEntryOrRawElement, value) {
      const newNode = this.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value);
      if (newNode === void 0)
        return false;
      if (this.root === void 0) {
        this._setRoot(newNode);
        this._size++;
        return true;
      }
      let current = this.root;
      while (current !== void 0) {
        if (this.comparator(current.key, newNode.key) === 0) {
          this._replaceNode(current, newNode);
          return true;
        } else if (this.comparator(current.key, newNode.key) > 0) {
          if (current.left === void 0) {
            current.left = newNode;
            this._size++;
            return true;
          }
          current = current.left;
        } else {
          if (current.right === void 0) {
            current.right = newNode;
            this._size++;
            return true;
          }
          current = current.right;
        }
      }
      return false;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(k log n)
     * Space Complexity: O(k + log n)
     *
     * The `addMany` function in TypeScript adds multiple keys or nodes to a data structure and returns
     * an array indicating whether each key or node was successfully inserted.
     * @param keysOrNodesOrEntriesOrRawElements - An iterable containing keys, nodes, entries, or raw
     * elements to be added to the data structure.
     * @param [values] - An optional iterable of values to be associated with the keys or nodes being
     * added. If provided, the values will be assigned to the corresponding keys or nodes in the same
     * order. If not provided, undefined will be assigned as the value for each key or node.
     * @param [isBalanceAdd=true] - A boolean flag indicating whether the tree should be balanced after
     * adding the elements. If set to true, the tree will be balanced using a binary search tree
     * algorithm. If set to false, the elements will be added without balancing the tree. The default
     * value is true.
     * @param {IterationType} iterationType - The `iterationType` parameter is an optional parameter that
     * specifies the type of iteration to use when adding multiple keys or nodes to the binary search
     * tree. It can have two possible values:
     * @returns The function `addMany` returns an array of booleans indicating whether each element was
     * successfully inserted into the data structure.
     */
    addMany(keysOrNodesOrEntriesOrRawElements, values, isBalanceAdd = true, iterationType = this.iterationType) {
      const inserted = [];
      let valuesIterator;
      if (values) {
        valuesIterator = values[Symbol.iterator]();
      }
      if (!isBalanceAdd) {
        for (const kve of keysOrNodesOrEntriesOrRawElements) {
          const value = valuesIterator == null ? void 0 : valuesIterator.next().value;
          const nn = this.add(kve, value);
          inserted.push(nn);
        }
        return inserted;
      }
      const realBTNExemplars = [];
      const isRealBTNExemplar = (kve) => {
        if (kve === void 0 || kve === null)
          return false;
        return !(this.isEntry(kve) && (kve[0] === void 0 || kve[0] === null));
      };
      for (const kve of keysOrNodesOrEntriesOrRawElements) {
        isRealBTNExemplar(kve) && realBTNExemplars.push(kve);
      }
      let sorted = [];
      sorted = realBTNExemplars.sort((a, b) => {
        let keyA, keyB;
        if (this.isEntry(a))
          keyA = a[0];
        else if (this.isRealNode(a))
          keyA = a.key;
        else if (this.toEntryFn) {
          keyA = this.toEntryFn(a)[0];
        } else {
          keyA = a;
        }
        if (this.isEntry(b))
          keyB = b[0];
        else if (this.isRealNode(b))
          keyB = b.key;
        else if (this.toEntryFn) {
          keyB = this.toEntryFn(b)[0];
        } else {
          keyB = b;
        }
        if (keyA !== void 0 && keyA !== null && keyB !== void 0 && keyB !== null) {
          return this.comparator(keyA, keyB);
        }
        return 0;
      });
      const _dfs = (arr) => {
        if (arr.length === 0)
          return;
        const mid = Math.floor((arr.length - 1) / 2);
        const newNode = this.add(arr[mid]);
        inserted.push(newNode);
        _dfs(arr.slice(0, mid));
        _dfs(arr.slice(mid + 1));
      };
      const _iterate = () => {
        const n = sorted.length;
        const stack = [[0, n - 1]];
        while (stack.length > 0) {
          const popped = stack.pop();
          if (popped) {
            const [l, r] = popped;
            if (l <= r) {
              const m = l + Math.floor((r - l) / 2);
              const newNode = this.add(sorted[m]);
              inserted.push(newNode);
              stack.push([m + 1, r]);
              stack.push([l, m - 1]);
            }
          }
        }
      };
      if (iterationType === "RECURSIVE") {
        _dfs(sorted);
      } else {
        _iterate();
      }
      return inserted;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(k + log n)
     *
     * The `getNodes` function in TypeScript retrieves nodes from a binary tree based on a given
     * identifier and callback function.
     * @param {ReturnType<C> | undefined} identifier - The `identifier` parameter is the value that you
     * want to search for in the binary tree. It can be of any type that is returned by the callback
     * function.
     * @param {C} callback - The `callback` parameter is a function that takes a node as input and
     * returns a value. This value is used to identify the nodes that match the given identifier. The
     * `callback` function is optional and defaults to `this._DEFAULT_CALLBACK`.
     * @param [onlyOne=false] - A boolean value indicating whether to return only the first matching node
     * or all matching nodes. If set to true, only the first matching node will be returned. If set to
     * false, all matching nodes will be returned. The default value is false.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the search in the binary tree. It can be either a node object, a key-value pair, or an
     * entry object. If it is not provided, the `root` of the binary tree is used as the starting point.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be performed. It can have two possible values:
     * @returns The method `getNodes` returns an array of `NODE` objects.
     */
    getNodes(identifier, callback = this._DEFAULT_CALLBACK, onlyOne = false, beginRoot = this.root, iterationType = this.iterationType) {
      beginRoot = this.ensureNode(beginRoot);
      if (!beginRoot)
        return [];
      callback = this._ensureCallback(identifier, callback);
      const ans = [];
      if (iterationType === "RECURSIVE") {
        const dfs = (cur) => {
          const callbackResult = callback(cur);
          if (callbackResult === identifier) {
            ans.push(cur);
            if (onlyOne)
              return;
          }
          if (!this.isRealNode(cur.left) && !this.isRealNode(cur.right))
            return;
          if (callback === this._DEFAULT_CALLBACK) {
            if (this.isRealNode(cur.left) && this.comparator(cur.key, identifier) > 0)
              dfs(cur.left);
            if (this.isRealNode(cur.right) && this.comparator(cur.key, identifier) < 0)
              dfs(cur.right);
          } else {
            this.isRealNode(cur.left) && dfs(cur.left);
            this.isRealNode(cur.right) && dfs(cur.right);
          }
        };
        dfs(beginRoot);
      } else {
        const stack = [beginRoot];
        while (stack.length > 0) {
          const cur = stack.pop();
          const callbackResult = callback(cur);
          if (callbackResult === identifier) {
            ans.push(cur);
            if (onlyOne)
              return ans;
          }
          if (callback === this._DEFAULT_CALLBACK) {
            if (this.isRealNode(cur.right) && this.comparator(cur.key, identifier) < 0)
              stack.push(cur.right);
            if (this.isRealNode(cur.left) && this.comparator(cur.key, identifier) > 0)
              stack.push(cur.left);
          } else {
            this.isRealNode(cur.right) && stack.push(cur.right);
            this.isRealNode(cur.left) && stack.push(cur.left);
          }
        }
      }
      return ans;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getNode` returns the first node that matches the given identifier and callback
     * function in a binary search tree.
     * @param {ReturnType<C> | undefined} identifier - The `identifier` parameter is the value that you
     * want to search for in the binary search tree. It can be of any type that is compatible with the
     * type returned by the callback function.
     * @param {C} callback - The `callback` parameter is a function that will be used to determine if a
     * node matches the desired criteria. It should be a function that takes a node as an argument and
     * returns a boolean value indicating whether the node matches the criteria or not. If no callback is
     * provided, the default callback will be
     * @param beginRoot - The `beginRoot` parameter is the starting point for the search in the binary
     * search tree. It can be either a key or a node. If it is a key, the search will start from the node
     * with that key. If it is a node, the search will start from that node.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed when searching for nodes in the binary search tree. It can have one
     * of the following values:
     * @returns The method is returning a NODE object or undefined.
     */
    getNode(identifier, callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      var _a;
      return (_a = this.getNodes(identifier, callback, true, beginRoot, iterationType)[0]) != null ? _a : void 0;
    }
    /**
     * Time Complexity: O(k log n)
     * Space Complexity: O(k + log n)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getNodeByKey` returns a node with a specific key from a tree data structure.
     * @param {K} key - The key parameter is the value used to search for a specific node in the tree. It
     * is typically a unique identifier or a value that can be used to determine the position of the node
     * in the tree structure.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when searching for a node in the tree.
     * It has a default value of `'ITERATIVE'`.
     * @returns The method is returning a NODE object or undefined.
     */
    getNodeByKey(key, iterationType = "ITERATIVE") {
      return this.getNode(key, this._DEFAULT_CALLBACK, this.root, iterationType);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(k + log n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The function overrides the depth-first search method and returns an array of the return types of
     * the callback function.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node
     * during the depth-first search traversal. It is an optional parameter and defaults to
     * `this._DEFAULT_CALLBACK`. The type `C` represents the type of the callback function.
     * @param {DFSOrderPattern} [pattern=IN] - The "pattern" parameter in the code snippet refers to the
     * order in which the Depth-First Search (DFS) algorithm visits the nodes in a tree or graph. It can
     * take one of the following values:
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the depth-first search traversal. It can be either a root node, a key-value pair, or a
     * node entry. If not specified, the default value is the root of the tree.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter specifies the
     * type of iteration to be used during the Depth-First Search (DFS) traversal. It can have one of the
     * following values:
     * @returns The method is returning an array of the return type of the callback function.
     */
    dfs(callback = this._DEFAULT_CALLBACK, pattern = "IN", beginRoot = this.root, iterationType = "ITERATIVE") {
      return super.dfs(callback, pattern, beginRoot, iterationType, false);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The function overrides the breadth-first search method and returns an array of the return types of
     * the callback function.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node
     * visited during the breadth-first search. It should take a single argument, which is the current
     * node being visited, and it can return a value of any type.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the breadth-first search. It can be either a root node, a key-value pair, or an entry
     * object. If no value is provided, the default value is the root of the tree.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed during the breadth-first search (BFS) traversal. It can have one of
     * the following values:
     * @returns an array of the return type of the callback function.
     */
    bfs(callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      return super.bfs(callback, beginRoot, iterationType, false);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The function overrides the listLevels method from the superclass and returns an array of arrays
     * containing the results of the callback function applied to each level of the tree.
     * @param {C} callback - The `callback` parameter is a generic type `C` that extends
     * `BTNCallback<NODE>`. It represents a callback function that will be called for each node in the
     * tree during the iteration process.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for listing the levels of the binary tree. It can be either a root node of the tree, a
     * key-value pair representing a node in the tree, or a key representing a node in the tree. If no
     * value is provided, the root of
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed on the tree. It can have one of the following values:
     * @returns The method is returning a two-dimensional array of the return type of the callback
     * function.
     */
    listLevels(callback = this._DEFAULT_CALLBACK, beginRoot = this.root, iterationType = this.iterationType) {
      return super.listLevels(callback, beginRoot, iterationType, false);
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `lesserOrGreaterTraverse` function traverses a binary tree and applies a callback function to
     * each node that meets a certain condition based on a target node and a comparison value.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node
     * that meets the condition specified by the `lesserOrGreater` parameter. It takes a single argument,
     * which is the current node being traversed, and returns a value of any type.
     * @param {CP} lesserOrGreater - The `lesserOrGreater` parameter is used to determine whether to
     * traverse nodes that are lesser, greater, or both than the `targetNode`. It accepts the values -1,
     * 0, or 1, where:
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} targetNode - The `targetNode` parameter is the node in
     * the binary tree that you want to start traversing from. It can be specified either by providing
     * the key of the node, the node itself, or an entry containing the key and value of the node. If no
     * `targetNode` is provided,
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * traversal to be performed on the binary tree. It can have two possible values:
     * @returns The function `lesserOrGreaterTraverse` returns an array of values of type
     * `ReturnType<C>`, which is the return type of the callback function passed as an argument.
     */
    lesserOrGreaterTraverse(callback = this._DEFAULT_CALLBACK, lesserOrGreater = -1, targetNode = this.root, iterationType = this.iterationType) {
      const targetNodeEnsured = this.ensureNode(targetNode);
      const ans = [];
      if (!targetNodeEnsured)
        return ans;
      if (!this.root)
        return ans;
      const targetKey = targetNodeEnsured.key;
      if (iterationType === "RECURSIVE") {
        const dfs = (cur) => {
          const compared = this.comparator(cur.key, targetKey);
          if (Math.sign(compared) === lesserOrGreater)
            ans.push(callback(cur));
          if (this.isRealNode(cur.left))
            dfs(cur.left);
          if (this.isRealNode(cur.right))
            dfs(cur.right);
        };
        dfs(this.root);
        return ans;
      } else {
        const queue = new Queue([this.root]);
        while (queue.size > 0) {
          const cur = queue.shift();
          if (this.isRealNode(cur)) {
            const compared = this.comparator(cur.key, targetKey);
            if (Math.sign(compared) === lesserOrGreater)
              ans.push(callback(cur));
            if (this.isRealNode(cur.left))
              queue.push(cur.left);
            if (this.isRealNode(cur.right))
              queue.push(cur.right);
          }
        }
        return ans;
      }
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `perfectlyBalance` function takes an optional `iterationType` parameter and returns `true` if
     * the binary search tree is perfectly balanced, otherwise it returns `false`.
     * @param {IterationType} iterationType - The `iterationType` parameter is an optional parameter that
     * specifies the type of iteration to use when building a balanced binary search tree. It has a
     * default value of `this.iterationType`, which means it will use the iteration type specified in the
     * current instance of the class.
     * @returns The function `perfectlyBalance` returns a boolean value.
     */
    perfectlyBalance(iterationType = this.iterationType) {
      const sorted = this.dfs((node) => node, "IN"), n = sorted.length;
      this.clear();
      if (sorted.length < 1)
        return false;
      if (iterationType === "RECURSIVE") {
        const buildBalanceBST = (l, r) => {
          if (l > r)
            return;
          const m = l + Math.floor((r - l) / 2);
          const midNode = sorted[m];
          this.add([midNode.key, midNode.value]);
          buildBalanceBST(l, m - 1);
          buildBalanceBST(m + 1, r);
        };
        buildBalanceBST(0, n - 1);
        return true;
      } else {
        const stack = [[0, n - 1]];
        while (stack.length > 0) {
          const popped = stack.pop();
          if (popped) {
            const [l, r] = popped;
            if (l <= r) {
              const m = l + Math.floor((r - l) / 2);
              const midNode = sorted[m];
              this.add([midNode.key, midNode.value]);
              stack.push([m + 1, r]);
              stack.push([l, m - 1]);
            }
          }
        }
        return true;
      }
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `isAVLBalanced` checks if a binary tree is AVL balanced using either a recursive or
     * iterative approach.
     * @param {IterationType} iterationType - The `iterationType` parameter is an optional parameter that
     * specifies the type of iteration to use when checking if the AVL tree is balanced. It has a default
     * value of `this.iterationType`, which means it will use the iteration type specified in the current
     * instance of the AVL tree.
     * @returns a boolean value.
     */
    isAVLBalanced(iterationType = this.iterationType) {
      var _a, _b;
      if (!this.root)
        return true;
      let balanced = true;
      if (iterationType === "RECURSIVE") {
        const _height = (cur) => {
          if (!cur)
            return 0;
          const leftHeight = _height(cur.left), rightHeight = _height(cur.right);
          if (Math.abs(leftHeight - rightHeight) > 1)
            balanced = false;
          return Math.max(leftHeight, rightHeight) + 1;
        };
        _height(this.root);
      } else {
        const stack = [];
        let node = this.root, last = void 0;
        const depths = /* @__PURE__ */ new Map();
        while (stack.length > 0 || node) {
          if (node) {
            stack.push(node);
            node = node.left;
          } else {
            node = stack[stack.length - 1];
            if (!node.right || last === node.right) {
              node = stack.pop();
              if (node) {
                const left = node.left ? (_a = depths.get(node.left)) != null ? _a : -1 : -1;
                const right = node.right ? (_b = depths.get(node.right)) != null ? _b : -1 : -1;
                if (Math.abs(left - right) > 1)
                  return false;
                depths.set(node, 1 + Math.max(left, right));
                last = node;
                node = void 0;
              }
            } else
              node = node.right;
          }
        }
      }
      return balanced;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * The function returns the value of the _comparator property.
     * @returns The `_comparator` property is being returned.
     */
    get comparator() {
      return this._comparator;
    }
    /**
     * The function sets the root of a tree-like structure and updates the parent property of the new
     * root.
     * @param {NODE | undefined} v - v is a parameter of type NODE or undefined.
     */
    _setRoot(v) {
      if (v) {
        v.parent = void 0;
      }
      this._root = v;
    }
  };

  // src/data-structures/binary-tree/binary-indexed-tree.ts
  var BinaryIndexedTree = class {
    /**
     * The constructor initializes the properties of an object, including default frequency, maximum
     * value, a freqMap data structure, the most significant bit, and the count of negative frequencies.
     * @param  - - `frequency`: The default frequency value. It is optional and has a default
     * value of 0.
     */
    constructor({ frequency = 0, max }) {
      __publicField(this, "_freq");
      __publicField(this, "_max");
      __publicField(this, "_freqMap");
      __publicField(this, "_msb");
      __publicField(this, "_negativeCount");
      this._freq = frequency;
      this._max = max;
      this._freqMap = { 0: 0 };
      this._msb = getMSB(max);
      this._negativeCount = frequency < 0 ? max : 0;
    }
    /**
     * The function returns the frequency map of numbers.
     * @returns The `_freqMap` property, which is a record with number keys and number values, is being
     * returned.
     */
    get freqMap() {
      return this._freqMap;
    }
    /**
     * The function returns the value of the _msb property.
     * @returns The `_msb` property of the object.
     */
    get msb() {
      return this._msb;
    }
    /**
     * The function returns the value of the _negativeCount property.
     * @returns The method is returning the value of the variable `_negativeCount`, which is of type
     * `number`.
     */
    get negativeCount() {
      return this._negativeCount;
    }
    /**
     * The above function returns the value of the protected variable `_freq`.
     * @returns The frequency value stored in the protected variable `_freq`.
     */
    get freq() {
      return this._freq;
    }
    /**
     * The above function returns the maximum value.
     * @returns The maximum value stored in the variable `_max`.
     */
    get max() {
      return this._max;
    }
    /**
     * The function "readSingle" reads a single number from a specified index.
     * @param {number} index - The `index` parameter is a number that represents the index of an element in a
     * collection or array.
     * @returns a number.
     */
    readSingle(index) {
      this._checkIndex(index);
      return this._readSingle(index);
    }
    /**
     * The "update" function updates the value at a given index by adding a delta and triggers a callback
     * to notify of the change.
     * @param {number} position - The `index` parameter represents the index of the element that needs to be
     * updated in the data structure.
     * @param {number} change - The "delta" parameter represents the change in value that needs to be
     * applied to the frequency at the specified index.
     */
    update(position, change) {
      this._checkIndex(position);
      const freqCur = this._readSingle(position);
      this._update(position, change);
      this._updateNegativeCount(freqCur, freqCur + change);
    }
    /**
     * The function "writeSingle" checks the index and writes a single value with a given frequency.
     * @param {number} index - The `index` parameter is a number that represents the index of an element. It
     * is used to identify the specific element that needs to be written.
     * @param {number} freq - The `freq` parameter represents the frequency value that needs to be
     * written.
     */
    writeSingle(index, freq) {
      this._checkIndex(index);
      this._writeSingle(index, freq);
    }
    /**
     * The read function takes a count parameter, checks if it is an integer, and returns the result of
     * calling the _read function with the count parameter clamped between 0 and the maximum value.
     * @param {number} count - The `count` parameter is a number that represents the number of items to
     * read.
     * @returns a number.
     */
    read(count) {
      if (!Number.isInteger(count)) {
        throw new Error("Invalid count");
      }
      return this._read(Math.max(Math.min(count, this.max), 0));
    }
    /**
     * The function returns the lower bound of a non-descending sequence that sums up to a given number.
     * @param {number} sum - The `sum` parameter is a number that represents the target sum that we want
     * to find in the sequence.
     * @returns The lowerBound function is returning a number.
     */
    lowerBound(sum) {
      if (this.negativeCount > 0) {
        throw new Error("Sequence is not non-descending");
      }
      return this._binarySearch(sum, (x, y) => x < y);
    }
    /**
     * The upperBound function returns the index of the first element in a sequence that is greater than
     * or equal to a given sum.
     * @param {number} sum - The "sum" parameter is a number that represents the target sum that we want
     * to find in the sequence.
     * @returns The upperBound function is returning a number.
     */
    upperBound(sum) {
      if (this.negativeCount > 0) {
        throw new Error("Must not be descending");
      }
      return this._binarySearch(sum, (x, y) => x <= y);
    }
    /**
     * The function calculates the prefix sum of an array using a binary indexed tree.
     * @param {number} i - The parameter "i" in the function "getPrefixSum" represents the index of the element in the
     * array for which we want to calculate the prefix sum.
     * @returns The function `getPrefixSum` returns the prefix sum of the elements in the binary indexed tree up to index
     * `i`.
     */
    getPrefixSum(i) {
      this._checkIndex(i);
      i++;
      let sum = 0;
      while (i > 0) {
        sum += this._getFrequency(i);
        i -= i & -i;
      }
      return sum;
    }
    /**
     * The function returns the value of a specific index in a freqMap data structure, or a default value if
     * the index is not found.
     * @param {number} index - The `index` parameter is a number that represents the index of a node in a
     * freqMap data structure.
     * @returns a number.
     */
    _getFrequency(index) {
      if (index in this.freqMap) {
        return this.freqMap[index];
      }
      return this.freq * (index & -index);
    }
    /**
     * The function _updateFrequency adds a delta value to the element at the specified index in the freqMap array.
     * @param {number} index - The index parameter is a number that represents the index of the freqMap
     * element that needs to be updated.
     * @param {number} delta - The `delta` parameter represents the change in value that needs to be
     * added to the freqMap at the specified `index`.
     */
    _updateFrequency(index, delta) {
      this.freqMap[index] = this._getFrequency(index) + delta;
    }
    /**
     * The function checks if the given index is valid and within the range.
     * @param {number} index - The parameter "index" is of type number and represents the index value
     * that needs to be checked.
     */
    _checkIndex(index) {
      if (!Number.isInteger(index)) {
        throw new Error("Invalid index: Index must be an integer.");
      }
      if (index < 0 || index >= this.max) {
        throw new Error("Index out of range: Index must be within the range [0, this.max).");
      }
    }
    /**
     * The function calculates the sum of elements in an array up to a given index using a binary indexed
     * freqMap.
     * @param {number} index - The `index` parameter is a number that represents the index of an element in a
     * data structure.
     * @returns a number.
     */
    _readSingle(index) {
      index = index + 1;
      let sum = this._getFrequency(index);
      const z = index - (index & -index);
      index--;
      while (index !== z) {
        sum -= this._getFrequency(index);
        index -= index & -index;
      }
      return sum;
    }
    /**
     * The function `_updateNegativeCount` updates a counter based on changes in frequency values.
     * @param {number} freqCur - The current frequency value.
     * @param {number} freqNew - The freqNew parameter represents the new frequency value.
     */
    _updateNegativeCount(freqCur, freqNew) {
      if (freqCur < 0 && freqNew >= 0) {
        this._negativeCount--;
      } else if (freqCur >= 0 && freqNew < 0) {
        this._negativeCount++;
      }
    }
    /**
     * The `_update` function updates the values in a binary indexed freqMap starting from a given index and
     * propagating the changes to its parent nodes.
     * @param {number} index - The `index` parameter is a number that represents the index of the element in
     * the data structure that needs to be updated.
     * @param {number} delta - The `delta` parameter represents the change in value that needs to be
     * applied to the elements in the data structure.
     */
    _update(index, delta) {
      index = index + 1;
      while (index <= this.max) {
        this._updateFrequency(index, delta);
        index += index & -index;
      }
    }
    /**
     * The `_writeSingle` function updates the frequency at a specific index and triggers a callback if
     * the frequency has changed.
     * @param {number} index - The `index` parameter is a number that represents the index of the element
     * being modified or accessed.
     * @param {number} freq - The `freq` parameter represents the new frequency value that needs to be
     * written to the specified index `index`.
     */
    _writeSingle(index, freq) {
      const freqCur = this._readSingle(index);
      this._update(index, freq - freqCur);
      this._updateNegativeCount(freqCur, freq);
    }
    /**
     * The `_read` function calculates the sum of values in a binary freqMap up to a given count.
     * @param {number} count - The `count` parameter is a number that represents the number of elements
     * to read from the freqMap.
     * @returns the sum of the values obtained from calling the `_getFrequency` method for each index in the
     * range from `count` to 1.
     */
    _read(count) {
      let index = count;
      let sum = 0;
      while (index) {
        sum += this._getFrequency(index);
        index -= index & -index;
      }
      return sum;
    }
    /**
     * The function `_binarySearch` performs a binary search to find the largest number that satisfies a given
     * condition.
     * @param {number} sum - The sum parameter is a number that represents the target sum value.
     * @param before - The `before` parameter is a function that takes two numbers `x` and `y` as
     * arguments and returns a boolean value. It is used to determine if `x` is less than or equal to
     * `y`. The purpose of this function is to compare two numbers and determine their order.
     * @returns the value of the variable "left".
     */
    _binarySearch(sum, before) {
      let left = 0;
      let right = this.msb << 1;
      let sumT = sum;
      while (right > left + 1) {
        const middle = left + right >> 1;
        const sumM = this._getFrequency(middle);
        if (middle <= this.max && before(sumM, sumT)) {
          sumT -= sumM;
          left = middle;
        } else {
          right = middle;
        }
      }
      return left;
    }
  };

  // src/data-structures/binary-tree/segment-tree.ts
  var SegmentTreeNode = class {
    /**
     * The constructor initializes the properties of a SegmentTreeNode object.
     * @param {number} start - The `start` parameter represents the starting index of the segment covered
     * by this node in a segment tree.
     * @param {number} end - The `end` parameter represents the end index of the segment covered by this
     * node in a segment tree.
     * @param {number} sum - The `sum` parameter represents the sum of the values in the range covered by
     * the segment tree node.
     * @param {SegmentTreeNodeVal | undefined} [value] - The `value` parameter is an optional parameter
     * of type `SegmentTreeNodeVal`. It represents the value associated with the segment tree node.
     */
    constructor(start, end, sum, value) {
      __publicField(this, "_start", 0);
      __publicField(this, "_end", 0);
      __publicField(this, "_value");
      __publicField(this, "_sum", 0);
      __publicField(this, "_left");
      __publicField(this, "_right");
      this._start = start;
      this._end = end;
      this._sum = sum;
      this._value = value || void 0;
    }
    /**
     * The function returns the value of the protected variable _start.
     * @returns The start value, which is of type number.
     */
    get start() {
      return this._start;
    }
    /**
     * The above function sets the value of the "start" property.
     * @param {number} value - The value parameter is of type number.
     */
    set start(value) {
      this._start = value;
    }
    /**
     * The function returns the value of the protected variable `_end`.
     * @returns The value of the protected property `_end`.
     */
    get end() {
      return this._end;
    }
    /**
     * The above function sets the value of the "end" property.
     * @param {number} value - The value parameter is a number that represents the new value for the end
     * property.
     */
    set end(value) {
      this._end = value;
    }
    /**
     * The function returns the value of a segment tree node.
     * @returns The value being returned is either a `SegmentTreeNodeVal` object or `undefined`.
     */
    get value() {
      return this._value;
    }
    /**
     * The function sets the value of a segment tree node.
     * @param {SegmentTreeNodeVal | undefined} value - The `value` parameter is of type
     * `SegmentTreeNodeVal` or `undefined`.
     */
    set value(value) {
      this._value = value;
    }
    /**
     * The function returns the value of the sum property.
     * @returns The method is returning the value of the variable `_sum`.
     */
    get sum() {
      return this._sum;
    }
    /**
     * The above function sets the value of the sum property.
     * @param {number} value - The parameter "value" is of type "number".
     */
    set sum(value) {
      this._sum = value;
    }
    /**
     * The function returns the left child of a segment tree node.
     * @returns The `left` property of the `SegmentTreeNode` object is being returned. It is of type
     * `SegmentTreeNode` or `undefined`.
     */
    get left() {
      return this._left;
    }
    /**
     * The function sets the value of the left property of a SegmentTreeNode object.
     * @param {SegmentTreeNode | undefined} value - The value parameter is of type SegmentTreeNode or
     * undefined.
     */
    set left(value) {
      this._left = value;
    }
    /**
     * The function returns the right child of a segment tree node.
     * @returns The `getRight()` method is returning a value of type `SegmentTreeNode` or `undefined`.
     */
    get right() {
      return this._right;
    }
    /**
     * The function sets the right child of a segment tree node.
     * @param {SegmentTreeNode | undefined} value - The `value` parameter is of type `SegmentTreeNode |
     * undefined`. This means that it can accept either a `SegmentTreeNode` object or `undefined` as its
     * value.
     */
    set right(value) {
      this._right = value;
    }
  };
  var SegmentTree = class {
    /**
     * The constructor initializes the values, start, end, and root properties of an object.
     * @param {number[]} values - An array of numbers that will be used to build a binary search tree.
     * @param {number} [start] - The `start` parameter is the index of the first element in the `values` array that should
     * be included in the range. If no value is provided for `start`, it defaults to 0, which means the range starts from
     * the beginning of the array.
     * @param {number} [end] - The "end" parameter is the index of the last element in the "values" array that should be
     * included in the range. If not provided, it defaults to the index of the last element in the "values" array.
     */
    constructor(values, start, end) {
      __publicField(this, "_values", []);
      __publicField(this, "_start", 0);
      __publicField(this, "_end");
      __publicField(this, "_root");
      start = start || 0;
      end = end || values.length - 1;
      this._values = values;
      this._start = start;
      this._end = end;
      if (values.length > 0) {
        this._root = this.build(start, end);
      } else {
        this._root = void 0;
        this._values = [];
      }
    }
    /**
     * The function returns an array of numbers.
     * @returns An array of numbers is being returned.
     */
    get values() {
      return this._values;
    }
    /**
     * The function returns the value of the protected variable _start.
     * @returns The start value, which is of type number.
     */
    get start() {
      return this._start;
    }
    /**
     * The function returns the value of the protected variable `_end`.
     * @returns The value of the protected property `_end`.
     */
    get end() {
      return this._end;
    }
    /**
     * The function returns the root node of a segment tree.
     * @returns The `root` property of the class `SegmentTreeNode` or `undefined` if it is not defined.
     */
    get root() {
      return this._root;
    }
    /**
     * The build function creates a segment tree by recursively dividing the given range into smaller segments and assigning
     * the sum of values to each segment.
     * @param {number} start - The `start` parameter represents the starting index of the segment or range for which we are
     * building the segment tree.
     * @param {number} end - The "end" parameter represents the ending index of the segment or range for which we want to
     * build a segment tree.
     * @returns a SegmentTreeNode object.
     */
    build(start, end) {
      if (start > end) {
        return new SegmentTreeNode(start, end, 0);
      }
      if (start === end)
        return new SegmentTreeNode(start, end, this._values[start]);
      const mid = start + Math.floor((end - start) / 2);
      const left = this.build(start, mid);
      const right = this.build(mid + 1, end);
      const cur = new SegmentTreeNode(start, end, left.sum + right.sum);
      cur.left = left;
      cur.right = right;
      return cur;
    }
    /**
     * The function updates the value of a node in a segment tree and recalculates the sum of its children if they exist.
     * @param {number} index - The index parameter represents the index of the node in the segment tree that needs to be
     * updated.
     * @param {number} sum - The `sum` parameter represents the new value that should be assigned to the `sum` property of
     * the `SegmentTreeNode` at the specified `index`.
     * @param {SegmentTreeNodeVal} [value] - The `value` parameter is an optional value that can be assigned to the `value`
     * property of the `SegmentTreeNode` object. It is not currently used in the code, but you can uncomment the line `//
     * cur.value = value;` and pass a value for `value` in the
     * @returns The function does not return anything.
     */
    updateNode(index, sum, value) {
      const root = this.root || void 0;
      if (!root) {
        return;
      }
      const dfs = (cur, index2, sum2, value2) => {
        if (cur.start === cur.end && cur.start === index2) {
          cur.sum = sum2;
          if (value2 !== void 0)
            cur.value = value2;
          return;
        }
        const mid = cur.start + Math.floor((cur.end - cur.start) / 2);
        if (index2 <= mid) {
          if (cur.left) {
            dfs(cur.left, index2, sum2, value2);
          }
        } else {
          if (cur.right) {
            dfs(cur.right, index2, sum2, value2);
          }
        }
        if (cur.left && cur.right) {
          cur.sum = cur.left.sum + cur.right.sum;
        }
      };
      dfs(root, index, sum, value);
    }
    /**
     * The function `querySumByRange` calculates the sum of values within a given range in a segment tree.
     * @param {number} indexA - The starting index of the range for which you want to calculate the sum.
     * @param {number} indexB - The parameter `indexB` represents the ending index of the range for which you want to
     * calculate the sum.
     * @returns The function `querySumByRange` returns a number.
     */
    querySumByRange(indexA, indexB) {
      const root = this.root || void 0;
      if (!root) {
        return 0;
      }
      if (indexA < 0 || indexB >= this.values.length || indexA > indexB) {
        return NaN;
      }
      const dfs = (cur, i, j) => {
        if (i <= cur.start && j >= cur.end) {
          return cur.sum;
        }
        const mid = cur.start + Math.floor((cur.end - cur.start) / 2);
        if (j <= mid) {
          if (cur.left) {
            return dfs(cur.left, i, j);
          } else {
            return NaN;
          }
        } else if (i > mid) {
          if (cur.right) {
            return dfs(cur.right, i, j);
          } else {
            return NaN;
          }
        } else {
          let leftSum = 0;
          let rightSum = 0;
          if (cur.left) {
            leftSum = dfs(cur.left, i, mid);
          }
          if (cur.right) {
            rightSum = dfs(cur.right, mid + 1, j);
          }
          return leftSum + rightSum;
        }
      };
      return dfs(root, indexA, indexB);
    }
  };

  // src/data-structures/binary-tree/avl-tree.ts
  var AVLTreeNode = class extends BSTNode {
    /**
     * The constructor function initializes a new instance of a class with a key and an optional value,
     * and sets the height property to 0.
     * @param {K} key - The "key" parameter is of type K, which represents the type of the key for the
     * constructor. It is used to initialize the key property of the object being created.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It represents the
     * value associated with the key in the constructor.
     */
    constructor(key, value) {
      super(key, value);
      __publicField(this, "_height");
      this._height = 0;
    }
    /**
     * The function returns the value of the height property.
     * @returns The height of the object.
     */
    get height() {
      return this._height;
    }
    /**
     * The above function sets the value of the height property.
     * @param {number} value - The value parameter is a number that represents the new height value to be
     * set.
     */
    set height(value) {
      this._height = value;
    }
  };
  var AVLTree = class _AVLTree extends BST {
    /**
     * This is a constructor function for an AVLTree class that initializes the tree with keys, nodes,
     * entries, or raw elements.
     * @param keysOrNodesOrEntriesOrRawElements - The `keysOrNodesOrEntriesOrRawElements` parameter is an
     * iterable object that can contain either keys, nodes, entries, or raw elements. These elements will
     * be used to initialize the AVLTree.
     * @param [options] - The `options` parameter is an optional object that can be used to customize the
     * behavior of the AVLTree. It can include properties such as `compareFn` (a function used to compare
     * keys), `allowDuplicates` (a boolean indicating whether duplicate keys are allowed), and
     * `nodeBuilder` (
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super([], options);
      if (keysOrNodesOrEntriesOrRawElements)
        super.addMany(keysOrNodesOrEntriesOrRawElements);
    }
    /**
     * The function creates a new AVL tree node with the given key and value.
     * @param {K} key - The key parameter is of type K, which represents the key of the node being
     * created.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It represents the
     * value associated with the key in the node being created.
     * @returns The method is returning a new instance of the AVLTreeNode class, casted as the generic
     * type NODE.
     */
    createNode(key, value) {
      return new AVLTreeNode(key, value);
    }
    /**
     * The function creates a new AVL tree with the specified options and returns it.
     * @param {AVLTreeOptions} [options] - The `options` parameter is an optional object that can be
     * passed to the `createTree` function. It is used to customize the behavior of the AVL tree that is
     * being created.
     * @returns a new AVLTree object.
     */
    createTree(options) {
      return new _AVLTree([], __spreadValues({
        iterationType: this.iterationType,
        comparator: this.comparator
      }, options));
    }
    /**
     * The function checks if the input is an instance of AVLTreeNode.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `AVLTreeNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof AVLTreeNode;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     * logarithmic time, where "n" is the number of nodes in the tree. The add method of the superclass (BST) has logarithmic time complexity. constant space, as it doesn't use additional data structures that scale with input size.
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function overrides the add method of a class and inserts a key-value pair into a data
     * structure, then balances the path.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept values of type `R`, `KeyOrNodeOrEntry<K, V, NODE>`, or
     * `RawElement`.
     * @param {V} [value] - The `value` parameter is an optional value that you want to associate with
     * the key or node being added to the data structure.
     * @returns The method is returning a boolean value.
     */
    add(keyOrNodeOrEntryOrRawElement, value) {
      if (keyOrNodeOrEntryOrRawElement === null)
        return false;
      const inserted = super.add(keyOrNodeOrEntryOrRawElement, value);
      if (inserted)
        this._balancePath(keyOrNodeOrEntryOrRawElement);
      return inserted;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function overrides the delete method of a binary tree class and performs additional operations
     * to balance the tree after deletion.
     * @param identifier - The `identifier` parameter is the value or condition used to identify the
     * node(s) to be deleted from the binary tree. It can be of any type that is compatible with the
     * binary tree's node type.
     * @param {C} callback - The `callback` parameter is a function that will be used to determine if a
     * node should be deleted or not. It is optional and has a default value of `this._DEFAULT_CALLBACK`.
     * @returns The method is returning an array of BinaryTreeDeleteResult<NODE> objects.
     */
    delete(identifier, callback = this._DEFAULT_CALLBACK) {
      const deletedResults = super.delete(identifier, callback);
      for (const { needBalanced } of deletedResults) {
        if (needBalanced) {
          this._balancePath(needBalanced);
        }
      }
      return deletedResults;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_swapProperties` function swaps the key, value, and height properties between two nodes in a
     * binary search tree.
     * @param {R | BSTNKeyOrNode<K, NODE>} srcNode - The `srcNode` parameter represents either a node
     * object (`NODE`) or a key-value pair (`R`) that is being swapped with another node.
     * @param {R | BSTNKeyOrNode<K, NODE>} destNode - The `destNode` parameter is either an instance of
     * `R` or an instance of `BSTNKeyOrNode<K, NODE>`.
     * @returns The method is returning the `destNodeEnsured` object if both `srcNodeEnsured` and
     * `destNodeEnsured` are truthy. Otherwise, it returns `undefined`.
     */
    _swapProperties(srcNode, destNode) {
      const srcNodeEnsured = this.ensureNode(srcNode);
      const destNodeEnsured = this.ensureNode(destNode);
      if (srcNodeEnsured && destNodeEnsured) {
        const { key, value, height } = destNodeEnsured;
        const tempNode = this.createNode(key, value);
        if (tempNode) {
          tempNode.height = height;
          destNodeEnsured.key = srcNodeEnsured.key;
          destNodeEnsured.value = srcNodeEnsured.value;
          destNodeEnsured.height = srcNodeEnsured.height;
          srcNodeEnsured.key = tempNode.key;
          srcNodeEnsured.value = tempNode.value;
          srcNodeEnsured.height = tempNode.height;
        }
        return destNodeEnsured;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function calculates the balance factor of a node in a binary tree.
     * @param {NODE} node - The parameter "node" is of type "NODE", which likely represents a node in a
     * binary tree data structure.
     * @returns the balance factor of a given node. The balance factor is calculated by subtracting the
     * height of the left subtree from the height of the right subtree.
     */
    _balanceFactor(node) {
      if (!node.right)
        return -node.height;
      else if (!node.left)
        return +node.height;
      else
        return node.right.height - node.left.height;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function updates the height of a node in a binary tree based on the heights of its left and
     * right children.
     * @param {NODE} node - The parameter "node" represents a node in a binary tree data structure.
     */
    _updateHeight(node) {
      if (!node.left && !node.right)
        node.height = 0;
      else if (!node.left) {
        const rightHeight = node.right ? node.right.height : 0;
        node.height = 1 + rightHeight;
      } else if (!node.right)
        node.height = 1 + node.left.height;
      else
        node.height = 1 + Math.max(node.right.height, node.left.height);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_balanceLL` function performs a left-left rotation to balance a binary search tree.
     * @param {NODE} A - A is a node in a binary tree.
     */
    _balanceLL(A) {
      const parentOfA = A.parent;
      const B = A.left;
      A.parent = B;
      if (B && B.right) {
        B.right.parent = A;
      }
      if (B)
        B.parent = parentOfA;
      if (A === this.root) {
        if (B)
          this._setRoot(B);
      } else {
        if ((parentOfA == null ? void 0 : parentOfA.left) === A) {
          parentOfA.left = B;
        } else {
          if (parentOfA)
            parentOfA.right = B;
        }
      }
      if (B) {
        A.left = B.right;
        B.right = A;
      }
      this._updateHeight(A);
      if (B)
        this._updateHeight(B);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_balanceLR` function performs a left-right rotation to balance a binary tree.
     * @param {NODE} A - A is a node in a binary tree.
     */
    _balanceLR(A) {
      const parentOfA = A.parent;
      const B = A.left;
      let C = void 0;
      if (B) {
        C = B.right;
      }
      if (A)
        A.parent = C;
      if (B)
        B.parent = C;
      if (C) {
        if (C.left) {
          C.left.parent = B;
        }
        if (C.right) {
          C.right.parent = A;
        }
        C.parent = parentOfA;
      }
      if (A === this.root) {
        if (C)
          this._setRoot(C);
      } else {
        if (parentOfA) {
          if (parentOfA.left === A) {
            parentOfA.left = C;
          } else {
            parentOfA.right = C;
          }
        }
      }
      if (C) {
        A.left = C.right;
        if (B)
          B.right = C.left;
        C.left = B;
        C.right = A;
      }
      this._updateHeight(A);
      B && this._updateHeight(B);
      C && this._updateHeight(C);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_balanceRR` performs a right-right rotation to balance a binary tree.
     * @param {NODE} A - A is a node in a binary tree.
     */
    _balanceRR(A) {
      const parentOfA = A.parent;
      const B = A.right;
      A.parent = B;
      if (B) {
        if (B.left) {
          B.left.parent = A;
        }
        B.parent = parentOfA;
      }
      if (A === this.root) {
        if (B)
          this._setRoot(B);
      } else {
        if (parentOfA) {
          if (parentOfA.left === A) {
            parentOfA.left = B;
          } else {
            parentOfA.right = B;
          }
        }
      }
      if (B) {
        A.right = B.left;
        B.left = A;
      }
      this._updateHeight(A);
      B && this._updateHeight(B);
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_balanceRL` performs a right-left rotation to balance a binary tree.
     * @param {NODE} A - A is a node in a binary tree.
     */
    _balanceRL(A) {
      const parentOfA = A.parent;
      const B = A.right;
      let C = void 0;
      if (B) {
        C = B.left;
      }
      A.parent = C;
      if (B)
        B.parent = C;
      if (C) {
        if (C.left) {
          C.left.parent = A;
        }
        if (C.right) {
          C.right.parent = B;
        }
        C.parent = parentOfA;
      }
      if (A === this.root) {
        if (C)
          this._setRoot(C);
      } else {
        if (parentOfA) {
          if (parentOfA.left === A) {
            parentOfA.left = C;
          } else {
            parentOfA.right = C;
          }
        }
      }
      if (C)
        A.right = C.left;
      if (B && C)
        B.left = C.right;
      if (C)
        C.left = A;
      if (C)
        C.right = B;
      this._updateHeight(A);
      B && this._updateHeight(B);
      C && this._updateHeight(C);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     * logarithmic time, where "n" is the number of nodes in the tree. The method traverses the path from the inserted node to the root. constant space, as it doesn't use additional data structures that scale with input size.
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `_balancePath` function is used to update the heights of nodes and perform rotation operations
     * to restore balance in an AVL tree after inserting a node.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The `node` parameter can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     */
    _balancePath(node) {
      node = this.ensureNode(node);
      const path = this.getPathToRoot(node, false);
      for (let i = 0; i < path.length; i++) {
        const A = path[i];
        this._updateHeight(A);
        switch (this._balanceFactor(A)) {
          case -2:
            if (A && A.left) {
              if (this._balanceFactor(A.left) <= 0) {
                this._balanceLL(A);
              } else {
                this._balanceLR(A);
              }
            }
            break;
          case 2:
            if (A && A.right) {
              if (this._balanceFactor(A.right) >= 0) {
                this._balanceRR(A);
              } else {
                this._balanceRL(A);
              }
            }
        }
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces an old node with a new node and sets the height of the new node to be the
     * same as the old node.
     * @param {NODE} oldNode - The `oldNode` parameter represents the node that needs to be replaced in
     * the data structure.
     * @param {NODE} newNode - The `newNode` parameter is the new node that will replace the `oldNode` in
     * the data structure.
     * @returns The method is returning the result of calling the `_replaceNode` method from the
     * superclass, with the `oldNode` and `newNode` as arguments.
     */
    _replaceNode(oldNode, newNode) {
      newNode.height = oldNode.height;
      return super._replaceNode(oldNode, newNode);
    }
  };

  // src/data-structures/binary-tree/rb-tree.ts
  var RedBlackTreeNode = class extends BSTNode {
    /**
     * The constructor function initializes a Red-Black Tree Node with a key, an optional value, and a
     * color.
     * @param {K} key - The key parameter is of type K and represents the key of the node in the
     * Red-Black Tree.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the key in the Red-Black Tree Node. It is not required and can be omitted when
     * creating a new instance of the Red-Black Tree Node.
     * @param {RBTNColor} color - The `color` parameter is used to specify the color of the Red-Black
     * Tree Node. It is an optional parameter with a default value of `'BLACK'`.
     */
    constructor(key, value, color = "BLACK") {
      super(key, value);
      __publicField(this, "_color");
      this._color = color;
    }
    /**
     * The function returns the color value of a variable.
     * @returns The color value stored in the private variable `_color`.
     */
    get color() {
      return this._color;
    }
    /**
     * The function sets the color property to the specified value.
     * @param {RBTNColor} value - The value parameter is of type RBTNColor.
     */
    set color(value) {
      this._color = value;
    }
  };
  var RedBlackTree = class _RedBlackTree extends BST {
    /**
     * This is the constructor function for a Red-Black Tree data structure in TypeScript.
     * @param keysOrNodesOrEntriesOrRawElements - The `keysOrNodesOrEntriesOrRawElements` parameter is an
     * iterable object that can contain either keys, nodes, entries, or raw elements. It is used to
     * initialize the RBTree with the provided elements.
     * @param [options] - The `options` parameter is an optional object that can be passed to the
     * constructor. It is of type `RBTreeOptions<K, V, R>`. This object can contain various options for
     * configuring the behavior of the Red-Black Tree. The specific properties and their meanings would
     * depend on the implementation
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super([], options);
      __publicField(this, "_root");
      this._root = this.NIL;
      if (keysOrNodesOrEntriesOrRawElements) {
        this.addMany(keysOrNodesOrEntriesOrRawElements);
      }
    }
    /**
     * The function returns the root node of a tree or undefined if there is no root.
     * @returns The root node of the tree structure, or undefined if there is no root node.
     */
    get root() {
      return this._root;
    }
    /**
     * The function creates a new Red-Black Tree node with the specified key, value, and color.
     * @param {K} key - The key parameter represents the key value of the node being created. It is of
     * type K, which is a generic type that can be replaced with any specific type when using the
     * function.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the key in the node. It is not required and can be omitted if you only need to
     * create a node with a key.
     * @param {RBTNColor} [color=BLACK] - The "color" parameter is used to specify the color of the node
     * in a Red-Black Tree. It can have two possible values: "RED" or "BLACK". By default, the color is
     * set to "BLACK" if not specified.
     * @returns A new instance of a RedBlackTreeNode with the specified key, value, and color is being
     * returned.
     */
    createNode(key, value, color = "BLACK") {
      return new RedBlackTreeNode(key, value, color);
    }
    /**
     * The function creates a new Red-Black Tree with the specified options.
     * @param [options] - The `options` parameter is an optional object that contains additional
     * configuration options for creating the Red-Black Tree. It has the following properties:
     * @returns a new instance of a RedBlackTree object.
     */
    createTree(options) {
      return new _RedBlackTree([], __spreadValues({
        iterationType: this.iterationType
      }, options));
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function checks if the input is an instance of the RedBlackTreeNode class.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `RedBlackTreeNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof RedBlackTreeNode;
    }
    // /**
    //  * Time Complexity: O(1)
    //  * Space Complexity: O(1)
    //  */
    //
    // /**
    //  * Time Complexity: O(1)
    //  * Space Complexity: O(1)
    //  *
    //  * The function `keyValueOrEntryOrRawElementToNode` takes a key, value, or entry and returns a node if it is
    //  * valid, otherwise it returns undefined.
    //  * @param {KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The key, value, or entry to convert.
    //  * @param {V} [value] - The value associated with the key (if `keyOrNodeOrEntryOrRawElement` is a key).
    //  * @returns {NODE | undefined} - The corresponding Red-Black Tree node, or `undefined` if conversion fails.
    //  */
    // override keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>, value?: V): NODE | undefined {
    //
    //   if (keyOrNodeOrEntryOrRawElement === null || keyOrNodeOrEntryOrRawElement === undefined) return;
    //   if (this.isNode(keyOrNodeOrEntryOrRawElement)) return keyOrNodeOrEntryOrRawElement;
    //
    //   if (this.toEntryFn) {
    //     const [key, entryValue] = this.toEntryFn(keyOrNodeOrEntryOrRawElement as R);
    //     if (key) return this.createNode(key, entryValue ?? value, 'RED');
    //   }
    //
    //   if (this.isEntry(keyOrNodeOrEntryOrRawElement)) {
    //     const [key, value] = keyOrNodeOrEntryOrRawElement;
    //     if (key === undefined || key === null) return;
    //     else return  this.createNode(key, value, 'RED');
    //   }
    //
    //   if (this.isKey(keyOrNodeOrEntryOrRawElement)) return this.createNode(keyOrNodeOrEntryOrRawElement, value, 'RED');
    //
    //   return ;
    // }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The "clear" function sets the root node of a data structure to a sentinel value and resets the
     * size counter to zero.
     */
    clear() {
      super.clear();
      this._root = this.NIL;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function adds a new node to a binary search tree and returns true if the node was successfully
     * added.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept a value of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that you want to associate with
     * the key in the data structure. It represents the value that you want to add or update in the data
     * structure.
     * @returns The method is returning a boolean value. If a new node is successfully added to the tree,
     * the method returns true. If the node already exists and its value is updated, the method also
     * returns true. If the node cannot be added or updated, the method returns false.
     */
    add(keyOrNodeOrEntryOrRawElement, value) {
      const newNode = this.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value);
      if (!this.isRealNode(newNode))
        return false;
      const insertStatus = this._insert(newNode);
      if (insertStatus === "CREATED") {
        if (this.isRealNode(this._root)) {
          this._root.color = "BLACK";
        } else {
          return false;
        }
        this._size++;
        return true;
      } else
        return insertStatus === "UPDATED";
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function overrides the delete method of a binary tree data structure, allowing for the
     * deletion of a node and maintaining the balance of the tree.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value
     * that identifies the node to be deleted from the binary tree. It can be of any type that is
     * returned by the callback function `C`. It can also be `null` or `undefined` if there is no node to
     * delete.
     * @param {C} callback - The `callback` parameter is a function that is used to determine the
     * equality of nodes in the binary tree. It is optional and has a default value of
     * `this._DEFAULT_CALLBACK`. The type of the `callback` parameter is `C`, which is a generic type
     * that extends the `BTNCallback
     * @returns an array of BinaryTreeDeleteResult<NODE> objects.
     */
    delete(identifier, callback = this._DEFAULT_CALLBACK) {
      if (identifier === null)
        return [];
      const results = [];
      callback = this._ensureCallback(identifier, callback);
      const nodeToDelete = this.isRealNode(identifier) ? identifier : this.getNode(identifier, callback);
      if (!nodeToDelete) {
        return results;
      }
      let originalColor = nodeToDelete.color;
      let replacementNode;
      if (!this.isRealNode(nodeToDelete.left)) {
        replacementNode = nodeToDelete.right;
        this._transplant(nodeToDelete, nodeToDelete.right);
      } else if (!this.isRealNode(nodeToDelete.right)) {
        replacementNode = nodeToDelete.left;
        this._transplant(nodeToDelete, nodeToDelete.left);
      } else {
        const successor = this.getLeftMost(nodeToDelete.right);
        if (successor) {
          originalColor = successor.color;
          replacementNode = successor.right;
          if (successor.parent === nodeToDelete) {
            if (this.isRealNode(replacementNode)) {
              replacementNode.parent = successor;
            }
          } else {
            this._transplant(successor, successor.right);
            successor.right = nodeToDelete.right;
            if (this.isRealNode(successor.right)) {
              successor.right.parent = successor;
            }
          }
          this._transplant(nodeToDelete, successor);
          successor.left = nodeToDelete.left;
          if (this.isRealNode(successor.left)) {
            successor.left.parent = successor;
          }
          successor.color = nodeToDelete.color;
        }
      }
      this._size--;
      if (originalColor === "BLACK") {
        this._deleteFixup(replacementNode);
      }
      results.push({ deleted: nodeToDelete, needBalanced: void 0 });
      return results;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function sets the root of a tree-like structure and updates the parent property of the new
     * root.
     * @param {NODE | undefined} v - v is a parameter of type NODE or undefined.
     */
    _setRoot(v) {
      if (v) {
        v.parent = void 0;
      }
      this._root = v;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces an old node with a new node while preserving the color of the old node.
     * @param {NODE} oldNode - The `oldNode` parameter represents the node that needs to be replaced in
     * the data structure.
     * @param {NODE} newNode - The `newNode` parameter is of type `NODE`, which represents a node in a
     * data structure.
     * @returns The method is returning the result of calling the `_replaceNode` method from the
     * superclass, with the `oldNode` and `newNode` parameters.
     */
    _replaceNode(oldNode, newNode) {
      newNode.color = oldNode.color;
      return super._replaceNode(oldNode, newNode);
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `_insert` function inserts a node into a binary search tree and performs necessary fix-ups to
     * maintain the red-black tree properties.
     * @param {NODE} node - The `node` parameter represents the node that needs to be inserted into the
     * binary search tree.
     * @returns a string value indicating the result of the insertion operation. It can return either
     * 'UPDATED' if the node with the same key already exists and was updated, or 'CREATED' if a new node
     * was created and inserted into the tree.
     */
    _insert(node) {
      var _a, _b;
      let current = this.root;
      let parent = void 0;
      while (this.isRealNode(current)) {
        parent = current;
        const compared = this.comparator(node.key, current.key);
        if (compared < 0) {
          current = (_a = current.left) != null ? _a : this.NIL;
        } else if (compared > 0) {
          current = (_b = current.right) != null ? _b : this.NIL;
        } else {
          this._replaceNode(current, node);
          return "UPDATED";
        }
      }
      node.parent = parent;
      if (!parent) {
        this._setRoot(node);
      } else if (node.key < parent.key) {
        parent.left = node;
      } else {
        parent.right = node;
      }
      node.left = this.NIL;
      node.right = this.NIL;
      node.color = "RED";
      this._insertFixup(node);
      return "CREATED";
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_transplant` is used to replace a node `u` with another node `v` in a binary tree.
     * @param {NODE} u - The parameter "u" represents a node in a binary tree.
     * @param {NODE | undefined} v - The parameter `v` is of type `NODE | undefined`, which means it can
     * either be a `NODE` object or `undefined`.
     */
    _transplant(u, v) {
      if (!u.parent) {
        this._setRoot(v);
      } else if (u === u.parent.left) {
        u.parent.left = v;
      } else {
        u.parent.right = v;
      }
      if (v) {
        v.parent = u.parent;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `_insertFixup` function is used to fix the Red-Black Tree after inserting a new node.
     * @param {NODE | undefined} z - The parameter `z` represents a node in the Red-Black Tree data
     * structure. It can either be a valid node or `undefined`.
     */
    _insertFixup(z) {
      var _a, _b, _c, _d;
      while (((_a = z == null ? void 0 : z.parent) == null ? void 0 : _a.color) === "RED") {
        if (z.parent === ((_b = z.parent.parent) == null ? void 0 : _b.left)) {
          const y = z.parent.parent.right;
          if ((y == null ? void 0 : y.color) === "RED") {
            z.parent.color = "BLACK";
            y.color = "BLACK";
            z.parent.parent.color = "RED";
            z = z.parent.parent;
          } else {
            if (z === z.parent.right) {
              z = z.parent;
              this._leftRotate(z);
            }
            if (z && this.isRealNode(z.parent) && this.isRealNode(z.parent.parent)) {
              z.parent.color = "BLACK";
              z.parent.parent.color = "RED";
              this._rightRotate(z.parent.parent);
            }
          }
        } else {
          const y = (_d = (_c = z == null ? void 0 : z.parent) == null ? void 0 : _c.parent) == null ? void 0 : _d.left;
          if ((y == null ? void 0 : y.color) === "RED") {
            z.parent.color = "BLACK";
            y.color = "BLACK";
            z.parent.parent.color = "RED";
            z = z.parent.parent;
          } else {
            if (z === z.parent.left) {
              z = z.parent;
              this._rightRotate(z);
            }
            if (z && this.isRealNode(z.parent) && this.isRealNode(z.parent.parent)) {
              z.parent.color = "BLACK";
              z.parent.parent.color = "RED";
              this._leftRotate(z.parent.parent);
            }
          }
        }
      }
      if (this.isRealNode(this._root))
        this._root.color = "BLACK";
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `_deleteFixup` function is used to fix the red-black tree after a node deletion by adjusting
     * the colors and performing rotations.
     * @param {NODE | undefined} node - The `node` parameter represents a node in a binary tree. It can
     * be either a valid node object or `undefined`.
     * @returns The function does not return any value. It has a return type of `void`, which means it
     * does not return anything.
     */
    _deleteFixup(node) {
      var _a, _b, _c, _d;
      if (!node || node === this.root || node.color === "BLACK") {
        if (node) {
          node.color = "BLACK";
        }
        return;
      }
      while (node && node !== this.root && node.color === "BLACK") {
        const parent = node.parent;
        if (!parent) {
          break;
        }
        if (node === parent.left) {
          let sibling = parent.right;
          if ((sibling == null ? void 0 : sibling.color) === "RED") {
            sibling.color = "BLACK";
            parent.color = "RED";
            this._leftRotate(parent);
            sibling = parent.right;
          }
          if (((_b = (_a = sibling == null ? void 0 : sibling.left) == null ? void 0 : _a.color) != null ? _b : "BLACK") === "BLACK") {
            if (sibling)
              sibling.color = "RED";
            node = parent;
          } else {
            if (sibling == null ? void 0 : sibling.left)
              sibling.left.color = "BLACK";
            if (sibling)
              sibling.color = parent.color;
            parent.color = "BLACK";
            this._rightRotate(parent);
            node = this.root;
          }
        } else {
          let sibling = parent.left;
          if ((sibling == null ? void 0 : sibling.color) === "RED") {
            sibling.color = "BLACK";
            if (parent)
              parent.color = "RED";
            this._rightRotate(parent);
            if (parent)
              sibling = parent.left;
          }
          if (((_d = (_c = sibling == null ? void 0 : sibling.right) == null ? void 0 : _c.color) != null ? _d : "BLACK") === "BLACK") {
            if (sibling)
              sibling.color = "RED";
            node = parent;
          } else {
            if (sibling == null ? void 0 : sibling.right)
              sibling.right.color = "BLACK";
            if (sibling)
              sibling.color = parent.color;
            if (parent)
              parent.color = "BLACK";
            this._leftRotate(parent);
            node = this.root;
          }
        }
      }
      if (node) {
        node.color = "BLACK";
      }
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_leftRotate` function performs a left rotation on a given node in a binary tree.
     * @param {NODE | undefined} x - The parameter `x` is of type `NODE | undefined`. It represents a
     * node in a binary tree or `undefined` if there is no node.
     * @returns void, which means it does not return any value.
     */
    _leftRotate(x) {
      if (!x || !x.right) {
        return;
      }
      const y = x.right;
      x.right = y.left;
      if (this.isRealNode(y.left)) {
        y.left.parent = x;
      }
      y.parent = x.parent;
      if (!x.parent) {
        this._setRoot(y);
      } else if (x === x.parent.left) {
        x.parent.left = y;
      } else {
        x.parent.right = y;
      }
      y.left = x;
      x.parent = y;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_rightRotate` function performs a right rotation on a given node in a binary tree.
     * @param {NODE | undefined} y - The parameter `y` is of type `NODE | undefined`. It represents a
     * node in a binary tree or `undefined` if there is no node.
     * @returns void, which means it does not return any value.
     */
    _rightRotate(y) {
      if (!y || !y.left) {
        return;
      }
      const x = y.left;
      y.left = x.right;
      if (this.isRealNode(x.right)) {
        x.right.parent = y;
      }
      x.parent = y.parent;
      if (!y.parent) {
        this._setRoot(x);
      } else if (y === y.parent.left) {
        y.parent.left = x;
      } else {
        y.parent.right = x;
      }
      x.right = y;
      y.parent = x;
    }
  };

  // src/data-structures/binary-tree/avl-tree-multi-map.ts
  var AVLTreeMultiMapNode = class extends AVLTreeNode {
    /**
     * The constructor function initializes a BinaryTreeNode object with a key, value, and count.
     * @param {K} key - The `key` parameter is of type `K` and represents the unique identifier
     * of the binary tree node.
     * @param {V} [value] - The `value` parameter is an optional parameter of type `V`. It represents the value of the binary
     * tree node. If no value is provided, it will be `undefined`.
     * @param {number} [count=1] - The `count` parameter is a number that represents the number of times a particular value
     * occurs in a binary tree node. It has a default value of 1, which means that if no value is provided for the `count`
     * parameter when creating a new instance of the `BinaryTreeNode` class.
     */
    constructor(key, value, count = 1) {
      super(key, value);
      __publicField(this, "_count", 1);
      this.count = count;
    }
    /**
     * The function returns the value of the protected variable _count.
     * @returns The count property of the object, which is of type number.
     */
    get count() {
      return this._count;
    }
    /**
     * The above function sets the value of the count property.
     * @param {number} value - The value parameter is of type number, which means it can accept any
     * numeric value.
     */
    set count(value) {
      this._count = value;
    }
  };
  var AVLTreeMultiMap = class _AVLTreeMultiMap extends AVLTree {
    /**
     * The constructor initializes a new AVLTreeMultiMap object with optional initial elements.
     * @param keysOrNodesOrEntriesOrRawElements - The `keysOrNodesOrEntriesOrRawElements` parameter is an
     * iterable object that can contain either keys, nodes, entries, or raw elements.
     * @param [options] - The `options` parameter is an optional object that can be used to customize the
     * behavior of the AVLTreeMultiMap. It can include properties such as `compareKeys` and
     * `compareValues` functions to define custom comparison logic for keys and values, respectively.
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super([], options);
      __publicField(this, "_count", 0);
      if (keysOrNodesOrEntriesOrRawElements)
        this.addMany(keysOrNodesOrEntriesOrRawElements);
    }
    /**
     * The function calculates the sum of the count property of all nodes in a tree using depth-first
     * search.
     * @returns the sum of the count property of all nodes in the tree.
     */
    get count() {
      return this._count;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function calculates the sum of the count property of all nodes in a tree using depth-first
     * search.
     * @returns the sum of the count property of all nodes in the tree.
     */
    getComputedCount() {
      let sum = 0;
      this.dfs((node) => sum += node.count);
      return sum;
    }
    /**
     * The function creates a new AVLTreeMultiMapNode with the specified key, value, and count.
     * @param {K} key - The key parameter represents the key of the node being created. It is of type K,
     * which is a generic type that can be replaced with any specific type when using the function.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the key in the node. It is of type `V`, which can be any data type.
     * @param {number} [count] - The `count` parameter represents the number of occurrences of a
     * key-value pair in the AVLTreeMultiMapNode. It is an optional parameter, so it can be omitted when
     * calling the `createNode` method. If provided, it specifies the initial count for the node.
     * @returns a new instance of the AVLTreeMultiMapNode class, casted as NODE.
     */
    createNode(key, value, count) {
      return new AVLTreeMultiMapNode(key, value, count);
    }
    /**
     * The function creates a new AVLTreeMultiMap object with the specified options and returns it.
     * @param [options] - The `options` parameter is an optional object that contains additional
     * configuration options for creating the AVLTreeMultiMap. It can have the following properties:
     * @returns a new instance of the AVLTreeMultiMap class, with the specified options, as a TREE
     * object.
     */
    createTree(options) {
      return new _AVLTreeMultiMap([], __spreadValues({
        iterationType: this.iterationType,
        comparator: this.comparator
      }, options));
    }
    /**
     * The function checks if the input is an instance of AVLTreeMultiMapNode.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `AVLTreeMultiMapNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof AVLTreeMultiMapNode;
    }
    /**
     * The function `keyValueOrEntryOrRawElementToNode` converts a key, value, entry, or raw element into
     * a node object.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The
     * `keyOrNodeOrEntryOrRawElement` parameter can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that can be passed to the
     * `override` function. It represents the value associated with the key in the data structure. If no
     * value is provided, it will default to `undefined`.
     * @param [count=1] - The `count` parameter is an optional parameter that specifies the number of
     * times the key-value pair should be added to the data structure. If not provided, it defaults to 1.
     * @returns either a NODE object or undefined.
     */
    keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value, count = 1) {
      if (keyOrNodeOrEntryOrRawElement === void 0 || keyOrNodeOrEntryOrRawElement === null)
        return;
      if (this.isNode(keyOrNodeOrEntryOrRawElement))
        return keyOrNodeOrEntryOrRawElement;
      if (this.toEntryFn) {
        const [key, entryValue] = this.toEntryFn(keyOrNodeOrEntryOrRawElement);
        if (key)
          return this.createNode(key, entryValue != null ? entryValue : value, count);
      }
      if (this.isEntry(keyOrNodeOrEntryOrRawElement)) {
        const [key, value2] = keyOrNodeOrEntryOrRawElement;
        if (key === void 0 || key === null)
          return;
        else
          return this.createNode(key, value2, count);
      }
      if (this.isKey(keyOrNodeOrEntryOrRawElement))
        return this.createNode(keyOrNodeOrEntryOrRawElement, value, count);
      return;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function overrides the add method of a TypeScript class to add a new node to a data structure
     * and update the count.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The
     * `keyOrNodeOrEntryOrRawElement` parameter can accept a value of type `R`, which can be any type. It
     * can also accept a value of type `KeyOrNodeOrEntry<K, V, NODE>`, which represents a key, node,
     * entry, or raw element
     * @param {V} [value] - The `value` parameter represents the value associated with the key in the
     * data structure. It is an optional parameter, so it can be omitted if not needed.
     * @param [count=1] - The `count` parameter represents the number of times the key-value pair should
     * be added to the data structure. By default, it is set to 1, meaning that the key-value pair will
     * be added once. However, you can specify a different value for `count` if you want to add
     * @returns a boolean value.
     */
    add(keyOrNodeOrEntryOrRawElement, value, count = 1) {
      const newNode = this.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value, count);
      if (newNode === void 0)
        return false;
      const orgNodeCount = (newNode == null ? void 0 : newNode.count) || 0;
      const inserted = super.add(newNode);
      if (inserted) {
        this._count += orgNodeCount;
      }
      return true;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `delete` function in a binary tree data structure deletes a node based on its identifier and
     * returns the deleted node along with the parent node that needs to be balanced.
     * @param identifier - The identifier parameter is the value used to identify the node that needs to
     * be deleted from the binary tree. It can be of any type and is the return type of the callback
     * function.
     * @param {C} callback - The `callback` parameter is a function that is used to determine the
     * equality of nodes in the binary tree. It is optional and has a default value of
     * `this._DEFAULT_CALLBACK`. The `callback` function takes a single argument, which is the identifier
     * of a node, and returns a value that
     * @param [ignoreCount=false] - A boolean flag indicating whether to ignore the count of the node
     * being deleted. If set to true, the count of the node will not be considered and the node will be
     * deleted regardless of its count. If set to false (default), the count of the node will be taken
     * into account and the node
     * @returns an array of `BinaryTreeDeleteResult<NODE>`.
     */
    delete(identifier, callback = this._DEFAULT_CALLBACK, ignoreCount = false) {
      var _a;
      const deletedResult = [];
      if (!this.root)
        return deletedResult;
      callback = this._ensureCallback(identifier, callback);
      const curr = (_a = this.getNode(identifier, callback)) != null ? _a : void 0;
      if (!curr)
        return deletedResult;
      const parent = (curr == null ? void 0 : curr.parent) ? curr.parent : void 0;
      let needBalanced = void 0, orgCurrent = curr;
      if (curr.count > 1 && !ignoreCount) {
        curr.count--;
        this._count--;
      } else {
        if (!curr.left) {
          if (!parent) {
            if (curr.right !== void 0)
              this._setRoot(curr.right);
          } else {
            const { familyPosition: fp } = curr;
            if (fp === "LEFT" || fp === "ROOT_LEFT") {
              parent.left = curr.right;
            } else if (fp === "RIGHT" || fp === "ROOT_RIGHT") {
              parent.right = curr.right;
            }
            needBalanced = parent;
          }
        } else {
          const leftSubTreeRightMost = curr.left ? this.getRightMost(curr.left) : void 0;
          if (leftSubTreeRightMost) {
            const parentOfLeftSubTreeMax = leftSubTreeRightMost.parent;
            orgCurrent = this._swapProperties(curr, leftSubTreeRightMost);
            if (parentOfLeftSubTreeMax) {
              if (parentOfLeftSubTreeMax.right === leftSubTreeRightMost) {
                parentOfLeftSubTreeMax.right = leftSubTreeRightMost.left;
              } else {
                parentOfLeftSubTreeMax.left = leftSubTreeRightMost.left;
              }
              needBalanced = parentOfLeftSubTreeMax;
            }
          }
        }
        this._size = this.size - 1;
        if (orgCurrent)
          this._count -= orgCurrent.count;
      }
      deletedResult.push({ deleted: orgCurrent, needBalanced });
      if (needBalanced) {
        this._balancePath(needBalanced);
      }
      return deletedResult;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The "clear" function overrides the parent class's "clear" function and also resets the count to
     * zero.
     */
    clear() {
      super.clear();
      this._count = 0;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(log n)
     * The `perfectlyBalance` function takes a sorted array of nodes and builds a balanced binary search
     * tree using either a recursive or iterative approach.
     * @param {IterationType} iterationType - The `iterationType` parameter is an optional parameter that
     * specifies the type of iteration to use when building the balanced binary search tree. It has a
     * default value of `this.iterationType`, which means it will use the iteration type currently set in
     * the object.
     * @returns The function `perfectlyBalance` returns a boolean value. It returns `true` if the
     * balancing operation is successful, and `false` if there are no nodes to balance.
     */
    perfectlyBalance(iterationType = this.iterationType) {
      const sorted = this.dfs((node) => node, "IN"), n = sorted.length;
      if (sorted.length < 1)
        return false;
      this.clear();
      if (iterationType === "RECURSIVE") {
        const buildBalanceBST = (l, r) => {
          if (l > r)
            return;
          const m = l + Math.floor((r - l) / 2);
          const midNode = sorted[m];
          this.add(midNode.key, midNode.value, midNode.count);
          buildBalanceBST(l, m - 1);
          buildBalanceBST(m + 1, r);
        };
        buildBalanceBST(0, n - 1);
        return true;
      } else {
        const stack = [[0, n - 1]];
        while (stack.length > 0) {
          const popped = stack.pop();
          if (popped) {
            const [l, r] = popped;
            if (l <= r) {
              const m = l + Math.floor((r - l) / 2);
              const midNode = sorted[m];
              this.add(midNode.key, midNode.value, midNode.count);
              stack.push([m + 1, r]);
              stack.push([l, m - 1]);
            }
          }
        }
        return true;
      }
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The function overrides the clone method to create a deep copy of a tree object.
     * @returns The `clone()` method is returning a cloned instance of the `TREE` object.
     */
    clone() {
      const cloned = this.createTree();
      this.bfs((node) => cloned.add(node.key, node.value, node.count));
      return cloned;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_swapProperties` function swaps the properties (key, value, count, height) between two nodes
     * in a binary search tree.
     * @param {R | BSTNKeyOrNode<K, NODE>} srcNode - The `srcNode` parameter represents the source node
     * that will be swapped with the `destNode`.
     * @param {R | BSTNKeyOrNode<K, NODE>} destNode - The `destNode` parameter represents the destination
     * node where the properties will be swapped with the source node.
     * @returns The method is returning the `destNode` after swapping its properties with the `srcNode`.
     * If either `srcNode` or `destNode` is undefined, it returns `undefined`.
     */
    _swapProperties(srcNode, destNode) {
      srcNode = this.ensureNode(srcNode);
      destNode = this.ensureNode(destNode);
      if (srcNode && destNode) {
        const { key, value, count, height } = destNode;
        const tempNode = this.createNode(key, value, count);
        if (tempNode) {
          tempNode.height = height;
          destNode.key = srcNode.key;
          destNode.value = srcNode.value;
          destNode.count = srcNode.count;
          destNode.height = srcNode.height;
          srcNode.key = tempNode.key;
          srcNode.value = tempNode.value;
          srcNode.count = tempNode.count;
          srcNode.height = tempNode.height;
        }
        return destNode;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces an old node with a new node and updates the count property of the new node.
     * @param {NODE} oldNode - The oldNode parameter represents the node that needs to be replaced in the
     * data structure. It is of type NODE.
     * @param {NODE} newNode - The `newNode` parameter is an instance of the `NODE` class.
     * @returns The method is returning the result of calling the `_replaceNode` method from the
     * superclass, which is of type `NODE`.
     */
    _replaceNode(oldNode, newNode) {
      newNode.count = oldNode.count + newNode.count;
      return super._replaceNode(oldNode, newNode);
    }
  };

  // src/data-structures/binary-tree/tree-multi-map.ts
  var TreeMultiMapNode = class extends RedBlackTreeNode {
    /**
     * The constructor function initializes a Red-Black Tree node with a key, value, count, and color.
     * @param {K} key - The key parameter represents the key of the node in the Red-Black Tree. It is
     * used to identify and locate the node within the tree.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the key in the Red-Black Tree node. It is not required and can be omitted when
     * creating a new node.
     * @param [count=1] - The `count` parameter represents the number of occurrences of a particular key
     * in the Red-Black Tree. It is an optional parameter with a default value of 1.
     * @param {RBTNColor} [color=BLACK] - The `color` parameter is used to specify the color of the node
     * in a Red-Black Tree. It is optional and has a default value of `'BLACK'`.
     */
    constructor(key, value, count = 1, color = "BLACK") {
      super(key, value, color);
      __publicField(this, "_count", 1);
      this.count = count;
    }
    /**
     * The function returns the value of the private variable _count.
     * @returns The count property of the object, which is of type number.
     */
    get count() {
      return this._count;
    }
    /**
     * The above function sets the value of the count property.
     * @param {number} value - The value parameter is of type number, which means it can accept any
     * numeric value.
     */
    set count(value) {
      this._count = value;
    }
  };
  var TreeMultiMap = class _TreeMultiMap extends RedBlackTree {
    /**
     * The constructor function initializes a TreeMultiMap object with optional initial data.
     * @param keysOrNodesOrEntriesOrRawElements - The parameter `keysOrNodesOrEntriesOrRawElements` is an
     * iterable that can contain keys, nodes, entries, or raw elements. It is used to initialize the
     * TreeMultiMap with initial data.
     * @param [options] - The `options` parameter is an optional object that can be used to customize the
     * behavior of the `TreeMultiMap` constructor. It can include properties such as `compareKeys` and
     * `compareValues`, which are functions used to compare keys and values respectively.
     */
    constructor(keysOrNodesOrEntriesOrRawElements = [], options) {
      super([], options);
      __publicField(this, "_count", 0);
      if (keysOrNodesOrEntriesOrRawElements)
        this.addMany(keysOrNodesOrEntriesOrRawElements);
    }
    // TODO the _count is not accurate after nodes count modified
    /**
     * The function calculates the sum of the count property of all nodes in a tree structure.
     * @returns the sum of the count property of all nodes in the tree.
     */
    get count() {
      return this._count;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function calculates the sum of the count property of all nodes in a tree using depth-first
     * search.
     * @returns the sum of the count property of all nodes in the tree.
     */
    getComputedCount() {
      let sum = 0;
      this.dfs((node) => sum += node.count);
      return sum;
    }
    /**
     * The function creates a new TreeMultiMapNode with the specified key, value, color, and count.
     * @param {K} key - The key parameter represents the key of the node being created. It is of type K,
     * which is a generic type representing the type of keys in the tree.
     * @param {V} [value] - The `value` parameter is an optional parameter that represents the value
     * associated with the key in the node. It is of type `V`, which can be any data type.
     * @param {RBTNColor} [color=BLACK] - The color parameter is used to specify the color of the node in
     * a Red-Black Tree. It can have two possible values: 'RED' or 'BLACK'. The default value is 'BLACK'.
     * @param {number} [count] - The `count` parameter represents the number of occurrences of a key in
     * the tree. It is an optional parameter and is used to keep track of the number of values associated
     * with a key in the tree.
     * @returns A new instance of the TreeMultiMapNode class, casted as NODE.
     */
    createNode(key, value, color = "BLACK", count) {
      return new TreeMultiMapNode(key, value, count, color);
    }
    /**
     * The function creates a new instance of a TreeMultiMap with the specified options and returns it.
     * @param [options] - The `options` parameter is an optional object that contains additional
     * configuration options for creating the `TreeMultiMap`. It is of type `TreeMultiMapOptions<K, V,
     * R>`.
     * @returns a new instance of the `TreeMultiMap` class, with the provided options merged with the
     * existing `iterationType` property. The returned value is casted as `TREE`.
     */
    createTree(options) {
      return new _TreeMultiMap([], __spreadValues({
        iterationType: this.iterationType
      }, options));
    }
    /**
     * The function `keyValueOrEntryOrRawElementToNode` takes in a key, value, and count and returns a
     * node based on the input.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that represents the value
     * associated with the key in the node. It is used when creating a new node or updating the value of
     * an existing node.
     * @param [count=1] - The `count` parameter is an optional parameter that specifies the number of
     * times the key-value pair should be added to the data structure. If not provided, it defaults to 1.
     * @returns either a NODE object or undefined.
     */
    keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value, count = 1) {
      if (keyOrNodeOrEntryOrRawElement === void 0 || keyOrNodeOrEntryOrRawElement === null)
        return;
      if (this.isNode(keyOrNodeOrEntryOrRawElement))
        return keyOrNodeOrEntryOrRawElement;
      if (this.toEntryFn) {
        const [key] = this.toEntryFn(keyOrNodeOrEntryOrRawElement);
        if (key)
          return this.getNodeByKey(key);
      }
      if (this.isEntry(keyOrNodeOrEntryOrRawElement)) {
        const [key, value2] = keyOrNodeOrEntryOrRawElement;
        if (key === void 0 || key === null)
          return;
        else
          return this.createNode(key, value2, "BLACK", count);
      }
      if (this.isKey(keyOrNodeOrEntryOrRawElement))
        return this.createNode(keyOrNodeOrEntryOrRawElement, value, "BLACK", count);
      return;
    }
    /**
     * The function checks if the input is an instance of the TreeMultiMapNode class.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `TreeMultiMapNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement) {
      return keyOrNodeOrEntryOrRawElement instanceof TreeMultiMapNode;
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function overrides the add method of a class and adds a new node to a data structure, updating
     * the count and returning a boolean indicating success.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The
     * `keyOrNodeOrEntryOrRawElement` parameter can accept one of the following types:
     * @param {V} [value] - The `value` parameter represents the value associated with the key in the
     * data structure. It is an optional parameter, so it can be omitted if not needed.
     * @param [count=1] - The `count` parameter represents the number of times the key-value pair should
     * be added to the data structure. By default, it is set to 1, meaning that if no value is provided
     * for `count`, the key-value pair will be added once.
     * @returns The method is returning a boolean value. It returns true if the addition of the new node
     * was successful, and false otherwise.
     */
    add(keyOrNodeOrEntryOrRawElement, value, count = 1) {
      const newNode = this.keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement, value, count);
      const orgCount = (newNode == null ? void 0 : newNode.count) || 0;
      const isSuccessAdded = super.add(newNode);
      if (isSuccessAdded) {
        this._count += orgCount;
        return true;
      } else {
        return false;
      }
    }
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `delete` is used to remove a node from a binary tree and fix the tree if necessary.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is the value or
     * key that is used to identify the node that needs to be deleted from the binary tree. It can be of
     * any type that is returned by the callback function `C`. It can also be `null` or `undefined` if
     * the node to be deleted
     * @param {C} callback - The `callback` parameter is a function that is used to determine the
     * equality of nodes in the binary tree. It is optional and has a default value of
     * `this._DEFAULT_CALLBACK`. The `callback` function is used to compare nodes when searching for a
     * specific node or when performing other operations on the
     * @param [ignoreCount=false] - A boolean flag indicating whether to ignore the count of the node
     * being deleted. If set to true, the count of the node will not be taken into account when deleting
     * it. If set to false, the count of the node will be decremented by 1 before deleting it.
     * @returns an array of BinaryTreeDeleteResult<NODE> objects.
     */
    delete(identifier, callback = this._DEFAULT_CALLBACK, ignoreCount = false) {
      if (identifier === null)
        return [];
      const results = [];
      callback = this._ensureCallback(identifier, callback);
      const nodeToDelete = this.isRealNode(identifier) ? identifier : this.getNode(identifier, callback);
      if (!nodeToDelete) {
        return results;
      }
      let originalColor = nodeToDelete.color;
      let replacementNode;
      if (!this.isRealNode(nodeToDelete.left)) {
        replacementNode = nodeToDelete.right;
        if (ignoreCount || nodeToDelete.count <= 1) {
          this._transplant(nodeToDelete, nodeToDelete.right);
          this._count -= nodeToDelete.count;
        } else {
          nodeToDelete.count--;
          this._count--;
          results.push({ deleted: nodeToDelete, needBalanced: void 0 });
          return results;
        }
      } else if (!this.isRealNode(nodeToDelete.right)) {
        replacementNode = nodeToDelete.left;
        if (ignoreCount || nodeToDelete.count <= 1) {
          this._transplant(nodeToDelete, nodeToDelete.left);
          this._count -= nodeToDelete.count;
        } else {
          nodeToDelete.count--;
          this._count--;
          results.push({ deleted: nodeToDelete, needBalanced: void 0 });
          return results;
        }
      } else {
        const successor = this.getLeftMost(nodeToDelete.right);
        if (successor) {
          originalColor = successor.color;
          replacementNode = successor.right;
          if (successor.parent === nodeToDelete) {
            if (this.isRealNode(replacementNode)) {
              replacementNode.parent = successor;
            }
          } else {
            if (ignoreCount || nodeToDelete.count <= 1) {
              this._transplant(successor, successor.right);
              this._count -= nodeToDelete.count;
            } else {
              nodeToDelete.count--;
              this._count--;
              results.push({ deleted: nodeToDelete, needBalanced: void 0 });
              return results;
            }
            successor.right = nodeToDelete.right;
            if (this.isRealNode(successor.right)) {
              successor.right.parent = successor;
            }
          }
          if (ignoreCount || nodeToDelete.count <= 1) {
            this._transplant(nodeToDelete, successor);
            this._count -= nodeToDelete.count;
          } else {
            nodeToDelete.count--;
            this._count--;
            results.push({ deleted: nodeToDelete, needBalanced: void 0 });
            return results;
          }
          successor.left = nodeToDelete.left;
          if (this.isRealNode(successor.left)) {
            successor.left.parent = successor;
          }
          successor.color = nodeToDelete.color;
        }
      }
      this._size--;
      if (originalColor === "BLACK") {
        this._deleteFixup(replacementNode);
      }
      results.push({ deleted: nodeToDelete, needBalanced: void 0 });
      return results;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The "clear" function overrides the parent class's "clear" function and also resets the count to
     * zero.
     */
    clear() {
      super.clear();
      this._count = 0;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(log n)
     *
     * The `perfectlyBalance` function takes a sorted array of nodes and builds a balanced binary search
     * tree using either a recursive or iterative approach.
     * @param {IterationType} iterationType - The `iterationType` parameter is an optional parameter that
     * specifies the type of iteration to use when building the balanced binary search tree. It has a
     * default value of `this.iterationType`, which means it will use the iteration type specified by the
     * `iterationType` property of the current object.
     * @returns The function `perfectlyBalance` returns a boolean value. It returns `true` if the
     * balancing operation is successful, and `false` if there are no nodes to balance.
     */
    perfectlyBalance(iterationType = this.iterationType) {
      const sorted = this.dfs((node) => node, "IN"), n = sorted.length;
      if (sorted.length < 1)
        return false;
      this.clear();
      if (iterationType === "RECURSIVE") {
        const buildBalanceBST = (l, r) => {
          if (l > r)
            return;
          const m = l + Math.floor((r - l) / 2);
          const midNode = sorted[m];
          this.add(midNode.key, midNode.value, midNode.count);
          buildBalanceBST(l, m - 1);
          buildBalanceBST(m + 1, r);
        };
        buildBalanceBST(0, n - 1);
        return true;
      } else {
        const stack = [[0, n - 1]];
        while (stack.length > 0) {
          const popped = stack.pop();
          if (popped) {
            const [l, r] = popped;
            if (l <= r) {
              const m = l + Math.floor((r - l) / 2);
              const midNode = sorted[m];
              this.add(midNode.key, midNode.value, midNode.count);
              stack.push([m + 1, r]);
              stack.push([l, m - 1]);
            }
          }
        }
        return true;
      }
    }
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The function overrides the clone method to create a deep copy of a tree object.
     * @returns The `clone()` method is returning a cloned instance of the `TREE` object.
     */
    clone() {
      const cloned = this.createTree();
      this.bfs((node) => cloned.add(node.key, node.value, node.count));
      return cloned;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The `_swapProperties` function swaps the properties (key, value, count, color) between two nodes
     * in a binary search tree.
     * @param {R | BSTNKeyOrNode<K, NODE>} srcNode - The `srcNode` parameter represents the source node
     * that will be swapped with the `destNode`. It can be either an instance of the `R` class or an
     * instance of the `BSTNKeyOrNode<K, NODE>` class.
     * @param {R | BSTNKeyOrNode<K, NODE>} destNode - The `destNode` parameter represents the destination
     * node where the properties will be swapped with the source node.
     * @returns The method is returning the `destNode` after swapping its properties with the `srcNode`.
     * If either `srcNode` or `destNode` is undefined, it returns undefined.
     */
    _swapProperties(srcNode, destNode) {
      srcNode = this.ensureNode(srcNode);
      destNode = this.ensureNode(destNode);
      if (srcNode && destNode) {
        const { key, value, count, color } = destNode;
        const tempNode = this.createNode(key, value, color, count);
        if (tempNode) {
          tempNode.color = color;
          destNode.key = srcNode.key;
          destNode.value = srcNode.value;
          destNode.count = srcNode.count;
          destNode.color = srcNode.color;
          srcNode.key = tempNode.key;
          srcNode.value = tempNode.value;
          srcNode.count = tempNode.count;
          srcNode.color = tempNode.color;
        }
        return destNode;
      }
      return void 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces an old node with a new node and updates the count property of the new node.
     * @param {NODE} oldNode - The `oldNode` parameter is the node that you want to replace in the data
     * structure.
     * @param {NODE} newNode - The `newNode` parameter is an instance of the `NODE` class.
     * @returns The method is returning the result of calling the `_replaceNode` method from the
     * superclass, which is of type `NODE`.
     */
    _replaceNode(oldNode, newNode) {
      newNode.count = oldNode.count + newNode.count;
      return super._replaceNode(oldNode, newNode);
    }
  };

  // src/data-structures/priority-queue/priority-queue.ts
  var PriorityQueue = class _PriorityQueue extends Heap {
    /**
     * The constructor initializes a priority queue with optional elements and options.
     * @param elements - The `elements` parameter is an iterable object that contains the initial
     * elements to be added to the priority queue. It is an optional parameter, and if not provided, the
     * priority queue will be initialized as empty.
     * @param [options] - The `options` parameter is an optional object that can be used to customize the
     * behavior of the priority queue. It can contain the following properties:
     */
    constructor(elements = [], options) {
      super(elements, options);
    }
    /**
     * The `clone` function returns a new instance of the `PriorityQueue` class with the same comparator
     * and toElementFn as the original instance.
     * @returns The method is returning a new instance of the `PriorityQueue` class with the same
     * elements and properties as the current instance.
     */
    clone() {
      return new _PriorityQueue(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new PriorityQueue object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `PriorityQueue` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredPriorityQueue = new _PriorityQueue([], {
        toElementFn: this.toElementFn,
        comparator: this.comparator
      });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredPriorityQueue.add(current);
        }
        index++;
      }
      return filteredPriorityQueue;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `PriorityQueue` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedPriorityQueue = new _PriorityQueue([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedPriorityQueue.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedPriorityQueue;
    }
  };

  // src/data-structures/priority-queue/min-priority-queue.ts
  var MinPriorityQueue = class _MinPriorityQueue extends PriorityQueue {
    /**
     * The constructor initializes a PriorityQueue with optional elements and options, including a
     * comparator function.
     * @param elements - The `elements` parameter is an iterable object that contains the initial
     * elements to be added to the priority queue. It is optional and defaults to an empty array if not
     * provided.
     * @param options - The `options` parameter is an object that contains additional configuration
     * options for the priority queue. In this case, it has a property called `comparator,` which is a
     * function used to compare elements in the priority queue. The `comparator` function takes two
     * parameters `a` and `b`
     */
    constructor(elements = [], options) {
      super(elements, options);
    }
    /**
     * The `clone` function returns a new instance of the `MinPriorityQueue` class with the same
     * comparator and toElementFn as the original instance.
     * @returns The method is returning a new instance of the `MinPriorityQueue` class with the same
     * properties as the current instance.
     */
    clone() {
      return new _MinPriorityQueue(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new MinPriorityQueue object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `MinPriorityQueue` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredPriorityQueue = new _MinPriorityQueue([], {
        toElementFn: this.toElementFn,
        comparator: this.comparator
      });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredPriorityQueue.add(current);
        }
        index++;
      }
      return filteredPriorityQueue;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `MinPriorityQueue` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedPriorityQueue = new _MinPriorityQueue([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedPriorityQueue.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedPriorityQueue;
    }
  };

  // src/data-structures/priority-queue/max-priority-queue.ts
  var MaxPriorityQueue = class _MaxPriorityQueue extends PriorityQueue {
    /**
     * The constructor initializes a PriorityQueue with optional elements and options, including a
     * comparator function.
     * @param elements - The `elements` parameter is an iterable object that contains the initial
     * elements to be added to the priority queue. It is optional and defaults to an empty array if not
     * provided.
     * @param options - The `options` parameter is an object that contains additional configuration
     * options for the priority queue. In this case, it has a property called `comparator,` which is a
     * function used to compare elements in the priority queue.
     */
    constructor(elements = [], options) {
      super(elements, __spreadValues({
        comparator: (a, b) => {
          if (typeof a === "object" || typeof b === "object") {
            throw TypeError(
              `When comparing object types, a custom comparator must be defined in the constructor's options parameter.`
            );
          }
          if (a < b)
            return 1;
          if (a > b)
            return -1;
          return 0;
        }
      }, options));
    }
    /**
     * The `clone` function returns a new instance of the `MaxPriorityQueue` class with the same
     * comparator and toElementFn as the current instance.
     * @returns The method is returning a new instance of the MaxPriorityQueue class with the same
     * comparator and toElementFn as the current instance.
     */
    clone() {
      return new _MaxPriorityQueue(this, { comparator: this.comparator, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new MaxPriorityQueue object containing elements that pass a given callback
     * function.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: the current element, the index of the current element, and the
     * heap itself. The callback function should return a boolean value indicating whether the current
     * element should be included in the filtered list
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `filter` method is returning a new `MaxPriorityQueue` object that contains the elements that pass
     * the filter condition specified by the `callback` function.
     */
    filter(callback, thisArg) {
      const filteredPriorityQueue = new _MaxPriorityQueue([], {
        toElementFn: this.toElementFn,
        comparator: this.comparator
      });
      let index = 0;
      for (const current of this) {
        if (callback.call(thisArg, current, index, this)) {
          filteredPriorityQueue.add(current);
        }
        index++;
      }
      return filteredPriorityQueue;
    }
    /**
     * Time Complexity: O(n log n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new heap by applying a callback function to each element of the
     * original heap.
     * @param callback - The `callback` parameter is a function that will be called for each element in
     * the heap. It takes three arguments: `el` (the current element), `index` (the index of the current
     * element), and `this` (the heap itself). The callback function should return a value of
     * @param comparator - The `comparator` parameter is a function that defines the order of the
     * elements in the heap. It takes two elements `a` and `b` as arguments and returns a negative number
     * if `a` should be placed before `b`, a positive number if `a` should be placed after
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that converts the raw
     * element `RR` to the desired type `T`. It takes a single argument `rawElement` of type `RR` and
     * returns a value of type `T`. This function is used to transform the elements of the original
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new instance of the `MaxPriorityQueue` class with the mapped elements.
     */
    map(callback, comparator, toElementFn, thisArg) {
      const mappedPriorityQueue = new _MaxPriorityQueue([], { comparator, toElementFn });
      let index = 0;
      for (const el of this) {
        mappedPriorityQueue.add(callback.call(thisArg, el, index, this));
        index++;
      }
      return mappedPriorityQueue;
    }
  };

  // src/data-structures/matrix/matrix.ts
  var Matrix = class _Matrix {
    /**
     * The constructor function initializes a matrix object with the provided data and options, or with
     * default values if no options are provided.
     * @param {number[][]} data - A 2D array of numbers representing the data for the matrix.
     * @param [options] - The `options` parameter is an optional object that can contain the following
     * properties:
     */
    constructor(data, options) {
      __publicField(this, "_rows", 0);
      __publicField(this, "_cols", 0);
      __publicField(this, "_data");
      var _a, _b, _c;
      if (options) {
        const { rows, cols, addFn, subtractFn, multiplyFn } = options;
        if (typeof rows === "number" && rows > 0)
          this._rows = rows;
        else
          this._rows = data.length;
        if (typeof cols === "number" && cols > 0)
          this._cols = cols;
        else
          this._cols = ((_a = data[0]) == null ? void 0 : _a.length) || 0;
        if (addFn)
          this._addFn = addFn;
        if (subtractFn)
          this._subtractFn = subtractFn;
        if (multiplyFn)
          this._multiplyFn = multiplyFn;
      } else {
        this._rows = data.length;
        this._cols = (_c = (_b = data[0]) == null ? void 0 : _b.length) != null ? _c : 0;
      }
      if (data.length > 0) {
        this._data = data;
      } else {
        this._data = [];
        for (let i = 0; i < this.rows; i++) {
          this._data[i] = new Array(this.cols).fill(0);
        }
      }
    }
    /**
     * The function returns the number of rows.
     * @returns The number of rows.
     */
    get rows() {
      return this._rows;
    }
    /**
     * The function returns the value of the protected variable _cols.
     * @returns The number of columns.
     */
    get cols() {
      return this._cols;
    }
    /**
     * The function returns a two-dimensional array of numbers.
     * @returns The data property, which is a two-dimensional array of numbers.
     */
    get data() {
      return this._data;
    }
    /**
     * The above function returns the value of the _addFn property.
     * @returns The value of the property `_addFn` is being returned.
     */
    get addFn() {
      return this._addFn;
    }
    /**
     * The function returns the value of the _subtractFn property.
     * @returns The `_subtractFn` property is being returned.
     */
    get subtractFn() {
      return this._subtractFn;
    }
    /**
     * The function returns the value of the _multiplyFn property.
     * @returns The `_multiplyFn` property is being returned.
     */
    get multiplyFn() {
      return this._multiplyFn;
    }
    /**
     * The `get` function returns the value at the specified row and column index if it is a valid index.
     * @param {number} row - The `row` parameter represents the row index of the element you want to
     * retrieve from the data array.
     * @param {number} col - The parameter "col" represents the column number of the element you want to
     * retrieve from the data array.
     * @returns The `get` function returns a number if the provided row and column indices are valid.
     * Otherwise, it returns `undefined`.
     */
    get(row, col) {
      if (this.isValidIndex(row, col)) {
        return this.data[row][col];
      }
    }
    /**
     * The set function updates the value at a specified row and column in a two-dimensional array.
     * @param {number} row - The "row" parameter represents the row index of the element in a
     * two-dimensional array or matrix. It specifies the row where the value will be set.
     * @param {number} col - The "col" parameter represents the column index of the element in a
     * two-dimensional array.
     * @param {number} value - The value parameter represents the number that you want to set at the
     * specified row and column in the data array.
     * @returns a boolean value. It returns true if the index (row, col) is valid and the value is
     * successfully set in the data array. It returns false if the index is invalid and the value is not
     * set.
     */
    set(row, col, value) {
      if (this.isValidIndex(row, col)) {
        this.data[row][col] = value;
        return true;
      }
      return false;
    }
    /**
     * The function checks if the dimensions of the given matrix match the dimensions of the current
     * matrix.
     * @param {Matrix} matrix - The parameter `matrix` is of type `Matrix`.
     * @returns a boolean value.
     */
    isMatchForCalculate(matrix) {
      return this.rows === matrix.rows && this.cols === matrix.cols;
    }
    /**
     * The `add` function adds two matrices together, returning a new matrix with the result.
     * @param {Matrix} matrix - The `matrix` parameter is an instance of the `Matrix` class.
     * @returns The `add` method returns a new `Matrix` object that represents the result of adding the
     * current matrix with the provided `matrix` parameter.
     */
    add(matrix) {
      if (!this.isMatchForCalculate(matrix)) {
        throw new Error("Matrix dimensions must match for addition.");
      }
      const resultData = [];
      for (let i = 0; i < this.rows; i++) {
        resultData[i] = [];
        for (let j = 0; j < this.cols; j++) {
          const a = this.get(i, j), b = matrix.get(i, j);
          if (a !== void 0 && b !== void 0) {
            const added = this._addFn(a, b);
            if (added) {
              resultData[i][j] = added;
            }
          }
        }
      }
      return new _Matrix(resultData, {
        rows: this.rows,
        cols: this.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The `subtract` function performs element-wise subtraction between two matrices and returns a new
     * matrix with the result.
     * @param {Matrix} matrix - The `matrix` parameter is an instance of the `Matrix` class. It
     * represents the matrix that you want to subtract from the current matrix.
     * @returns a new Matrix object with the result of the subtraction operation.
     */
    subtract(matrix) {
      if (!this.isMatchForCalculate(matrix)) {
        throw new Error("Matrix dimensions must match for subtraction.");
      }
      const resultData = [];
      for (let i = 0; i < this.rows; i++) {
        resultData[i] = [];
        for (let j = 0; j < this.cols; j++) {
          const a = this.get(i, j), b = matrix.get(i, j);
          if (a !== void 0 && b !== void 0) {
            const subtracted = this._subtractFn(a, b);
            if (subtracted) {
              resultData[i][j] = subtracted;
            }
          }
        }
      }
      return new _Matrix(resultData, {
        rows: this.rows,
        cols: this.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The `multiply` function performs matrix multiplication between two matrices and returns the result
     * as a new matrix.
     * @param {Matrix} matrix - The `matrix` parameter is an instance of the `Matrix` class.
     * @returns a new Matrix object.
     */
    multiply(matrix) {
      if (this.cols !== matrix.rows) {
        throw new Error("Matrix dimensions must be compatible for multiplication (A.cols = B.rows).");
      }
      const resultData = [];
      for (let i = 0; i < this.rows; i++) {
        resultData[i] = [];
        for (let j = 0; j < matrix.cols; j++) {
          let sum;
          for (let k = 0; k < this.cols; k++) {
            const a = this.get(i, k), b = matrix.get(k, j);
            if (a !== void 0 && b !== void 0) {
              const multiplied = this.multiplyFn(a, b);
              if (multiplied !== void 0) {
                sum = this.addFn(sum, multiplied);
              }
            }
          }
          if (sum !== void 0)
            resultData[i][j] = sum;
        }
      }
      return new _Matrix(resultData, {
        rows: this.rows,
        cols: matrix.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The transpose function takes a matrix and returns a new matrix that is the transpose of the
     * original matrix.
     * @returns The transpose() function returns a new Matrix object with the transposed data.
     */
    transpose() {
      if (this.data.some((row) => row.length !== this.rows)) {
        throw new Error("Matrix must be rectangular for transposition.");
      }
      const resultData = [];
      for (let j = 0; j < this.cols; j++) {
        resultData[j] = [];
        for (let i = 0; i < this.rows; i++) {
          const trans = this.get(i, j);
          if (trans !== void 0)
            resultData[j][i] = trans;
        }
      }
      return new _Matrix(resultData, {
        rows: this.cols,
        cols: this.rows,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The `inverse` function calculates the inverse of a square matrix using Gaussian elimination.
     * @returns a Matrix object, which represents the inverse of the original matrix.
     */
    inverse() {
      var _a;
      if (this.rows !== this.cols) {
        throw new Error("Matrix must be square for inversion.");
      }
      const augmentedMatrixData = [];
      for (let i = 0; i < this.rows; i++) {
        augmentedMatrixData[i] = this.data[i].slice();
        for (let j = 0; j < this.cols; j++) {
          augmentedMatrixData[i][this.cols + j] = i === j ? 1 : 0;
        }
      }
      const augmentedMatrix = new _Matrix(augmentedMatrixData, {
        rows: this.rows,
        cols: this.cols * 2,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
      for (let i = 0; i < this.rows; i++) {
        let pivotRow = i;
        while (pivotRow < this.rows && augmentedMatrix.get(pivotRow, i) === 0) {
          pivotRow++;
        }
        if (pivotRow === this.rows) {
          throw new Error("Matrix is singular, and its inverse does not exist.");
        }
        augmentedMatrix._swapRows(i, pivotRow);
        const pivotElement = (_a = augmentedMatrix.get(i, i)) != null ? _a : 1;
        if (pivotElement === 0) {
          throw new Error("Matrix is singular, and its inverse does not exist (division by zero).");
        }
        augmentedMatrix._scaleRow(i, 1 / pivotElement);
        for (let j = 0; j < this.rows; j++) {
          if (j !== i) {
            let factor = augmentedMatrix.get(j, i);
            if (factor === void 0)
              factor = 0;
            augmentedMatrix._addScaledRow(j, i, -factor);
          }
        }
      }
      const inverseData = [];
      for (let i = 0; i < this.rows; i++) {
        inverseData[i] = augmentedMatrix.data[i].slice(this.cols);
      }
      return new _Matrix(inverseData, {
        rows: this.rows,
        cols: this.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The dot function calculates the dot product of two matrices and returns a new matrix.
     * @param {Matrix} matrix - The `matrix` parameter is an instance of the `Matrix` class.
     * @returns a new Matrix object.
     */
    dot(matrix) {
      if (this.cols !== matrix.rows) {
        throw new Error(
          "Number of columns in the first matrix must be equal to the number of rows in the second matrix for dot product."
        );
      }
      const resultData = [];
      for (let i = 0; i < this.rows; i++) {
        resultData[i] = [];
        for (let j = 0; j < matrix.cols; j++) {
          let sum;
          for (let k = 0; k < this.cols; k++) {
            const a = this.get(i, k), b = matrix.get(k, j);
            if (a !== void 0 && b !== void 0) {
              const multiplied = this.multiplyFn(a, b);
              if (multiplied !== void 0) {
                sum = this.addFn(sum, multiplied);
              }
            }
          }
          if (sum !== void 0)
            resultData[i][j] = sum;
        }
      }
      return new _Matrix(resultData, {
        rows: this.rows,
        cols: matrix.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    /**
     * The function checks if a given row and column index is valid within a specified range.
     * @param {number} row - The `row` parameter represents the row index of a two-dimensional array or
     * matrix. It is a number that indicates the specific row in the matrix.
     * @param {number} col - The "col" parameter represents the column index in a two-dimensional array
     * or grid. It is used to check if the given column index is valid within the bounds of the grid.
     * @returns A boolean value is being returned.
     */
    isValidIndex(row, col) {
      return row >= 0 && row < this.rows && col >= 0 && col < this.cols;
    }
    /**
     * The `clone` function returns a new instance of the Matrix class with the same data and properties
     * as the original instance.
     * @returns The `clone()` method is returning a new instance of the `Matrix` class with the same data
     * and properties as the current instance.
     */
    clone() {
      return new _Matrix(this.data, {
        rows: this.rows,
        cols: this.cols,
        addFn: this.addFn,
        subtractFn: this.subtractFn,
        multiplyFn: this.multiplyFn
      });
    }
    _addFn(a, b) {
      if (a === void 0)
        return b;
      return a + b;
    }
    _subtractFn(a, b) {
      return a - b;
    }
    _multiplyFn(a, b) {
      return a * b;
    }
    /**
     * The function `_swapRows` swaps the positions of two rows in an array.
     * @param {number} row1 - The `row1` parameter is the index of the first row that you want to swap.
     * @param {number} row2 - The `row2` parameter is the index of the second row that you want to swap
     * with the first row.
     */
    _swapRows(row1, row2) {
      const temp = this.data[row1];
      this.data[row1] = this.data[row2];
      this.data[row2] = temp;
    }
    /**
     * The function scales a specific row in a matrix by a given scalar value.
     * @param {number} row - The `row` parameter represents the index of the row in the matrix that you
     * want to scale. It is a number that indicates the position of the row within the matrix.
     * @param {number} scalar - The scalar parameter is a number that is used to multiply each element in
     * a specific row of a matrix.
     */
    _scaleRow(row, scalar) {
      for (let j = 0; j < this.cols; j++) {
        let multiplied = this.multiplyFn(this.data[row][j], scalar);
        if (multiplied === void 0)
          multiplied = 0;
        this.data[row][j] = multiplied;
      }
    }
    /**
     * The function `_addScaledRow` multiplies a row in a matrix by a scalar value and adds it to another
     * row.
     * @param {number} targetRow - The targetRow parameter represents the index of the row in which the
     * scaled values will be added.
     * @param {number} sourceRow - The sourceRow parameter represents the index of the row from which the
     * values will be scaled and added to the targetRow.
     * @param {number} scalar - The scalar parameter is a number that is used to scale the values in the
     * source row before adding them to the target row.
     */
    _addScaledRow(targetRow, sourceRow, scalar) {
      for (let j = 0; j < this.cols; j++) {
        let multiplied = this.multiplyFn(this.data[sourceRow][j], scalar);
        if (multiplied === void 0)
          multiplied = 0;
        const scaledValue = multiplied;
        let added = this.addFn(this.data[targetRow][j], scaledValue);
        if (added === void 0)
          added = 0;
        this.data[targetRow][j] = added;
      }
    }
  };

  // src/data-structures/matrix/navigator.ts
  var Character = class _Character {
    /**
     * The constructor function takes in a direction and turning object and sets the direction and turn properties of the
     * Character class.
     * @param {Direction} direction - The direction parameter is used to specify the current direction of the character. It
     * can be any value that represents a direction, such as "north", "south", "east", or "west".
     * @param {Turning} turning - The `turning` parameter is an object that maps each direction to the corresponding
     * turning direction. It is used to determine the new direction when the character turns.
     */
    constructor(direction, turning) {
      __publicField(this, "direction");
      __publicField(this, "turn");
      this.direction = direction;
      this.turn = () => new _Character(turning[direction], turning);
    }
  };
  var Navigator = class {
    /**
     * The constructor initializes the Navigator object with the given parameters and sets the current position as visited
     * in the matrix.
     * @param  - - `matrix`: a 2D array representing the grid or map
     */
    constructor({ matrix, turning, onMove, init: { cur, charDir, VISITED } }) {
      __publicField(this, "onMove");
      __publicField(this, "_matrix");
      __publicField(this, "_cur");
      __publicField(this, "_character");
      __publicField(this, "_VISITED");
      this._matrix = matrix;
      this._cur = cur;
      this._character = new Character(charDir, turning);
      this.onMove = onMove;
      this.onMove && this.onMove(this._cur);
      this._VISITED = VISITED;
      this._matrix[this._cur[0]][this._cur[1]] = this._VISITED;
    }
    /**
     * The "start" function moves the character in its current direction until it encounters an obstacle, then it turns the
     * character and repeats the process.
     */
    start() {
      while (this.check(this._character.direction) || this.check(this._character.turn().direction)) {
        const { direction } = this._character;
        if (this.check(direction)) {
          this.move(direction);
        } else if (this.check(this._character.turn().direction)) {
          this._character = this._character.turn();
        }
      }
    }
    /**
     * The function checks if there is a valid move in the specified direction in a matrix.
     * @param {Direction} direction - The direction parameter is a string that represents the direction in which to check.
     * It can be one of the following values: 'up', 'right', 'down', or 'left'.
     * @returns a boolean value.
     */
    check(direction) {
      let forward, row;
      const matrix = this._matrix;
      const [i, j] = this._cur;
      switch (direction) {
        case "up":
          row = matrix[i - 1];
          if (!row)
            return false;
          forward = row[j];
          break;
        case "right":
          forward = matrix[i][j + 1];
          break;
        case "down":
          row = matrix[i + 1];
          if (!row)
            return false;
          forward = row[j];
          break;
        case "left":
          forward = matrix[i][j - 1];
          break;
      }
      return forward !== void 0 && forward !== this._VISITED;
    }
    /**
     * The `move` function updates the current position based on the given direction and updates the matrix accordingly.
     * @param {Direction} direction - The `direction` parameter is a string that represents the direction in which to move.
     * It can have one of the following values: 'up', 'right', 'down', or 'left'.
     */
    move(direction) {
      switch (direction) {
        case "up":
          this._cur[0]--;
          break;
        case "right":
          this._cur[1]++;
          break;
        case "down":
          this._cur[0]++;
          break;
        case "left":
          this._cur[1]--;
          break;
      }
      const [i, j] = this._cur;
      this._matrix[i][j] = this._VISITED;
      this.onMove && this.onMove(this._cur);
    }
  };

  // src/data-structures/trie/trie.ts
  var TrieNode = class {
    constructor(key) {
      __publicField(this, "_key");
      __publicField(this, "_children");
      __publicField(this, "_isEnd");
      this._key = key;
      this._isEnd = false;
      this._children = /* @__PURE__ */ new Map();
    }
    /**
     * The function returns the value of the protected variable _key.
     * @returns The value of the `_key` property, which is a string.
     */
    get key() {
      return this._key;
    }
    /**
     * The above function sets the value of a protected variable called "key".
     * @param {string} value - The value parameter is a string that represents the value to be assigned
     * to the key.
     */
    set key(value) {
      this._key = value;
    }
    /**
     * The function returns the children of a TrieNode as a Map.
     * @returns The `children` property of the TrieNode object, which is a Map containing string keys and
     * TrieNode values.
     */
    get children() {
      return this._children;
    }
    /**
     * The function sets the value of the `_children` property of a TrieNode object.
     * @param value - The value parameter is a Map object that represents the children of a TrieNode. The
     * keys of the map are strings, which represent the characters that are associated with each child
     * TrieNode. The values of the map are TrieNode objects, which represent the child nodes of the
     * current TrieNode.
     */
    set children(value) {
      this._children = value;
    }
    /**
     * The function returns a boolean value indicating whether a certain condition is met.
     * @returns The method is returning a boolean value, specifically the value of the variable `_isEnd`.
     */
    get isEnd() {
      return this._isEnd;
    }
    /**
     * The function sets the value of the "_isEnd" property.
     * @param {boolean} value - The value parameter is a boolean value that indicates whether the current
     * state is the end state or not.
     */
    set isEnd(value) {
      this._isEnd = value;
    }
  };
  var Trie = class _Trie extends IterableElementBase {
    /**
     * The constructor function for the Trie class.
     * @param words: Iterable string Initialize the trie with a set of words
     * @param options?: TrieOptions Allow the user to pass in options for the trie
     * @return This
     */
    constructor(words = [], options) {
      super(options);
      __publicField(this, "_size", 0);
      __publicField(this, "_caseSensitive", true);
      __publicField(this, "_root", new TrieNode(""));
      if (options) {
        const { caseSensitive } = options;
        if (caseSensitive !== void 0)
          this._caseSensitive = caseSensitive;
      }
      if (words) {
        for (const word of words) {
          if (this.toElementFn) {
            this.add(this.toElementFn(word));
          } else {
            this.add(word);
          }
        }
      }
    }
    /**
     * The size function returns the size of the stack.
     * @return The number of elements in the list
     */
    get size() {
      return this._size;
    }
    /**
     * The caseSensitive function is a getter that returns the value of the protected _caseSensitive property.
     * @return The value of the _caseSensitive protected variable
     */
    get caseSensitive() {
      return this._caseSensitive;
    }
    /**
     * The root function returns the root node of the tree.
     * @return The root node
     */
    get root() {
      return this._root;
    }
    /**
     * Time Complexity: O(l), where l is the length of the word being added.
     * Space Complexity: O(l) - Each character in the word adds a TrieNode.
     */
    /**
     * Time Complexity: O(l), where l is the length of the word being added.
     * Space Complexity: O(l) - Each character in the word adds a TrieNode.
     *
     * Add a word to the Trie structure.
     * @param {string} word - The word to add.
     * @returns {boolean} True if the word was successfully added.
     */
    add(word) {
      word = this._caseProcess(word);
      let cur = this.root;
      let isNewWord = false;
      for (const c of word) {
        let nodeC = cur.children.get(c);
        if (!nodeC) {
          nodeC = new TrieNode(c);
          cur.children.set(c, nodeC);
        }
        cur = nodeC;
      }
      if (!cur.isEnd) {
        isNewWord = true;
        cur.isEnd = true;
        this._size++;
      }
      return isNewWord;
    }
    /**
     * Time Complexity: O(l), where l is the length of the input word.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(l), where l is the length of the input word.
     * Space Complexity: O(1) - Constant space.
     *
     * Check if the Trie contains a given word.
     * @param {string} word - The word to check for.
     * @returns {boolean} True if the word is present in the Trie.
     */
    has(word) {
      word = this._caseProcess(word);
      let cur = this.root;
      for (const c of word) {
        const nodeC = cur.children.get(c);
        if (!nodeC)
          return false;
        cur = nodeC;
      }
      return cur.isEnd;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The isEmpty function checks if the size of the queue is 0.
     * @return True if the size of the queue is 0
     */
    isEmpty() {
      return this.size === 0;
    }
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The clear function resets the size of the Trie to 0 and creates a new root TrieNode.
     */
    clear() {
      this._size = 0;
      this._root = new TrieNode("");
    }
    /**
     * Time Complexity: O(l), where l is the length of the word being deleted.
     * Space Complexity: O(n) - Due to the recursive DFS approach.
     */
    /**
     * Time Complexity: O(l), where l is the length of the word being deleted.
     * Space Complexity: O(n) - Due to the recursive DFS approach.
     *
     * Remove a word from the Trie structure.
     * @param{string} word - The word to delete.
     * @returns {boolean} True if the word was successfully removed.
     */
    delete(word) {
      word = this._caseProcess(word);
      let isDeleted = false;
      const dfs = (cur, i) => {
        const char = word[i];
        const child = cur.children.get(char);
        if (child) {
          if (i === word.length - 1) {
            if (child.isEnd) {
              if (child.children.size > 0) {
                child.isEnd = false;
              } else {
                cur.children.delete(char);
              }
              isDeleted = true;
              return true;
            }
            return false;
          }
          const res = dfs(child, i + 1);
          if (res && !cur.isEnd && child.children.size === 0) {
            cur.children.delete(char);
            return true;
          }
          return false;
        }
        return false;
      };
      dfs(this.root, 0);
      if (isDeleted) {
        this._size--;
      }
      return isDeleted;
    }
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(1) - Constant space.
     *
     */
    getHeight() {
      const beginRoot = this.root;
      let maxDepth = 0;
      if (beginRoot) {
        const bfs = (node, level) => {
          if (level > maxDepth) {
            maxDepth = level;
          }
          const { children } = node;
          if (children) {
            for (const child of children.entries()) {
              bfs(child[1], level + 1);
            }
          }
        };
        bfs(beginRoot, 0);
      }
      return maxDepth;
    }
    /**
     * Time Complexity: O(l), where l is the length of the input prefix.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(l), where l is the length of the input prefix.
     * Space Complexity: O(1) - Constant space.
     *
     * Check if a given input string has an absolute prefix in the Trie, meaning it's not a complete word.
     * @param {string} input - The input string to check.
     * @returns {boolean} True if it's an absolute prefix in the Trie.
     */
    hasPurePrefix(input) {
      input = this._caseProcess(input);
      let cur = this.root;
      for (const c of input) {
        const nodeC = cur.children.get(c);
        if (!nodeC)
          return false;
        cur = nodeC;
      }
      return !cur.isEnd;
    }
    /**
     * Time Complexity: O(l), where l is the length of the input prefix.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(l), where l is the length of the input prefix.
     * Space Complexity: O(1) - Constant space.
     *
     * Check if a given input string is a prefix of any existing word in the Trie, whether as an absolute prefix or a complete word.
     * @param {string} input - The input string representing the prefix to check.
     * @returns {boolean} True if it's a prefix in the Trie.
     */
    hasPrefix(input) {
      input = this._caseProcess(input);
      let cur = this.root;
      for (const c of input) {
        const nodeC = cur.children.get(c);
        if (!nodeC)
          return false;
        cur = nodeC;
      }
      return true;
    }
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(l), where l is the length of the input prefix.
     */
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(l), where l is the length of the input prefix.
     *
     * Check if the input string is a common prefix in the Trie, meaning it's a prefix shared by all words in the Trie.
     * @param {string} input - The input string representing the common prefix to check for.
     * @returns {boolean} True if it's a common prefix in the Trie.
     */
    hasCommonPrefix(input) {
      input = this._caseProcess(input);
      let commonPre = "";
      const dfs = (cur) => {
        commonPre += cur.key;
        if (commonPre === input)
          return;
        if (cur.isEnd)
          return;
        if (cur && cur.children && cur.children.size === 1)
          dfs(Array.from(cur.children.values())[0]);
        else
          return;
      };
      dfs(this.root);
      return commonPre === input;
    }
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(l), where l is the length of the longest common prefix.
     */
    /**
     * Time Complexity: O(n), where n is the total number of nodes in the trie.
     * Space Complexity: O(l), where l is the length of the longest common prefix.
     *
     * Get the longest common prefix among all the words stored in the Trie.
     * @returns {string} The longest common prefix found in the Trie.
     */
    getLongestCommonPrefix() {
      let commonPre = "";
      const dfs = (cur) => {
        commonPre += cur.key;
        if (cur.isEnd)
          return;
        if (cur && cur.children && cur.children.size === 1)
          dfs(Array.from(cur.children.values())[0]);
        else
          return;
      };
      dfs(this.root);
      return commonPre;
    }
    /**
     * Time Complexity: O(w * l), where w is the number of words retrieved, and l is the average length of the words.
     * Space Complexity: O(w * l) - The space required for the output array.
     */
    /**
     * Time Complexity: O(w * l), where w is the number of words retrieved, and l is the average length of the words.
     * Space Complexity: O(w * l) - The space required for the output array.
     *
     * The `getAll` function returns an array of all words in a Trie data structure that start with a given prefix.
     * @param {string} prefix - The `prefix` parameter is a string that represents the prefix that we want to search for in the
     * trie. It is an optional parameter, so if no prefix is provided, it will default to an empty string.
     * @param {number} max - The max count of words will be found
     * @param isAllWhenEmptyPrefix - If true, when the prefix provided as '', returns all the words in the trie.
     * @returns {string[]} an array of strings.
     */
    getWords(prefix = "", max = Number.MAX_SAFE_INTEGER, isAllWhenEmptyPrefix = false) {
      prefix = this._caseProcess(prefix);
      const words = [];
      let found = 0;
      function dfs(node, word) {
        for (const char of node.children.keys()) {
          const charNode = node.children.get(char);
          if (charNode !== void 0) {
            dfs(charNode, word.concat(char));
          }
        }
        if (node.isEnd) {
          if (found > max - 1)
            return;
          words.push(word);
          found++;
        }
      }
      let startNode = this.root;
      if (prefix) {
        for (const c of prefix) {
          const nodeC = startNode.children.get(c);
          if (nodeC)
            startNode = nodeC;
        }
      }
      if (isAllWhenEmptyPrefix || startNode !== this.root)
        dfs(startNode, prefix);
      return words;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `clone` function returns a new instance of the Trie class with the same values and case
     * sensitivity as the original Trie.
     * @returns A new instance of the Trie class is being returned.
     */
    clone() {
      return new _Trie(this, { caseSensitive: this.caseSensitive, toElementFn: this.toElementFn });
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function takes a predicate function and returns a new array containing all the
     * elements for which the predicate function returns true.
     * @param predicate - The `predicate` parameter is a callback function that takes three arguments:
     * `word`, `index`, and `this`. It should return a boolean value indicating whether the current
     * element should be included in the filtered results or not.
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. It is used when you want to bind a
     * specific object as the context for the `predicate` function. If `thisArg` is provided, it will be
     * @returns The `filter` method is returning an array of strings (`string[]`).
     */
    filter(predicate, thisArg) {
      const results = new _Trie([], { toElementFn: this.toElementFn, caseSensitive: this.caseSensitive });
      let index = 0;
      for (const word of this) {
        if (predicate.call(thisArg, word, index, this)) {
          results.add(word);
        }
        index++;
      }
      return results;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new Trie by applying a callback function to each element in the
     * current Trie.
     * @param callback - The callback parameter is a function that will be called for each element in the
     * Trie. It takes four arguments:
     * @param [toElementFn] - The `toElementFn` parameter is an optional function that can be used to
     * convert the raw element (`RM`) into a string representation. This can be useful if the raw element
     * is not already a string or if you want to customize how the element is converted into a string. If
     * this parameter is
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the callback function. It is used to set the context or scope
     * in which the callback function will be executed. If `thisArg` is provided, it will be used as the
     * value of
     * @returns a new Trie object.
     */
    map(callback, toElementFn, thisArg) {
      const newTrie = new _Trie([], { toElementFn, caseSensitive: this.caseSensitive });
      let index = 0;
      for (const word of this) {
        newTrie.add(callback.call(thisArg, word, index, this));
        index++;
      }
      return newTrie;
    }
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The function `_getIterator` returns an iterable iterator that performs a depth-first search on a
     * trie data structure and yields all the paths to the end nodes.
     */
    *_getIterator() {
      function* _dfs(node, path) {
        if (node.isEnd) {
          yield path;
        }
        for (const [char, childNode] of node.children) {
          yield* __yieldStar(_dfs(childNode, path + char));
        }
      }
      yield* __yieldStar(_dfs(this.root, ""));
    }
    /**
     * Time Complexity: O(l), where l is the length of the input string.
     * Space Complexity: O(1) - Constant space.
     */
    /**
     * Time Complexity: O(l), where l is the length of the input string.
     * Space Complexity: O(1) - Constant space.
     *
     * @param str
     * @protected
     */
    _caseProcess(str) {
      if (!this._caseSensitive) {
        str = str.toLowerCase();
      }
      return str;
    }
  };

  // src/data-structures/tree/tree.ts
  var TreeNode = class _TreeNode {
    /**
     * The constructor function initializes a TreeNode object with a key, optional value, and optional
     * children.
     * @param {string} key - A string representing the key of the tree node.
     * @param {V} [value] - The `value` parameter is an optional parameter of type `V`. It represents the
     * value associated with the node. If no value is provided, it defaults to `undefined`.
     * @param {TreeNode<V>[]} [children] - The `children` parameter is an optional array of `TreeNode<V>`
     * objects. It represents the child nodes of the current node. If no children are provided, the
     * default value is an empty array.
     */
    constructor(key, value, children) {
      __publicField(this, "_key");
      __publicField(this, "_value");
      __publicField(this, "_children");
      this._key = key;
      this._value = value || void 0;
      this._children = children || [];
    }
    /**
     * The function returns the value of the protected variable _key.
     * @returns The value of the `_key` property, which is a string.
     */
    get key() {
      return this._key;
    }
    /**
     * The above function sets the value of a protected variable called "key".
     * @param {string} value - The value parameter is a string that represents the value to be assigned
     * to the key.
     */
    set key(value) {
      this._key = value;
    }
    /**
     * The function returns the value stored in a variable, or undefined if the variable is empty.
     * @returns The value of the variable `_value` is being returned.
     */
    get value() {
      return this._value;
    }
    /**
     * The function sets the value of a variable.
     * @param {V | undefined} value - The parameter "value" is of type "V | undefined", which means it
     * can accept a value of type "V" or it can be undefined.
     */
    set value(value) {
      this._value = value;
    }
    /**
     * The function returns an array of TreeNode objects or undefined.
     * @returns The `children` property is being returned. It is of type `TreeNode<V>[] | undefined`,
     * which means it can either be an array of `TreeNode<V>` objects or `undefined`.
     */
    get children() {
      return this._children;
    }
    /**
     * The function sets the value of the children property of a TreeNode object.
     * @param {TreeNode<V>[] | undefined} value - The value parameter is of type TreeNode<V>[] |
     * undefined. This means that it can accept an array of TreeNode objects or undefined.
     */
    set children(value) {
      this._children = value;
    }
    /**
     * The function `addChildren` adds one or more child nodes to the current node.
     * @param {TreeNode<V> | TreeNode<V>[]} children - The `children` parameter can be either a single
     * `TreeNode<V>` object or an array of `TreeNode<V>` objects.
     */
    addChildren(children) {
      if (!this._children) {
        this._children = [];
      }
      if (children instanceof _TreeNode) {
        this._children.push(children);
      } else {
        this._children = this._children.concat(children);
      }
    }
    /**
     * The function `getHeight()` calculates the maximum depth of a tree structure by performing a
     * breadth-first search.
     * @returns the maximum depth or height of the tree.
     */
    getHeight() {
      let maxDepth = 0;
      if (this) {
        const bfs = (node, level) => {
          if (level > maxDepth) {
            maxDepth = level;
          }
          const { _children } = node;
          if (_children) {
            for (let i = 0, len = _children.length; i < len; i++) {
              bfs(_children[i], level + 1);
            }
          }
        };
        bfs(this, 0);
      }
      return maxDepth;
    }
  };
  return __toCommonJS(src_exports);
})();
/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
/**
 * @license MIT
 * @copyright Tyler Zeng <zrwusa@gmail.com>
 * @class
 */
/**
 * data-structure-typed
 * @author Kirk Qi
 * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>
 * @license MIT License
 */
/**
 * data-structure-typed
 *
 * @author Kirk Qi
 * @copyright Copyright (c) 2022 Kirk Qi <qilinaus@gmail.com>
 * @license MIT License
 */
