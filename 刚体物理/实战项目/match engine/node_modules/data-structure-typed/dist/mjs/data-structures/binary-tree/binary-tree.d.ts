/**
 * data-structure-typed
 *
 * @author Tyler Zeng
 * @copyright Copyright (c) 2022 Tyler Zeng <zrwusa@gmail.com>
 * @license MIT License
 */
import type { BinaryTreeDeleteResult, BinaryTreeNested, BinaryTreeNodeNested, BinaryTreeOptions, BinaryTreePrintOptions, BTNCallback, BTNEntry, DFSOrderPattern, EntryCallback, FamilyPosition, IterationType, KeyOrNodeOrEntry, NodeDisplayLayout } from '../../types';
import { IBinaryTree } from '../../interfaces';
import { IterableEntryBase } from '../base';
/**
 * Represents a node in a binary tree.
 * @template V - The type of data stored in the node.
 * @template NODE - The type of the family relationship in the binary tree.
 */
export declare class BinaryTreeNode<K = any, V = any, NODE extends BinaryTreeNode<K, V, NODE> = BinaryTreeNode<K, V, BinaryTreeNodeNested<K, V>>> {
    key: K;
    value?: V;
    parent?: NODE;
    /**
     * The constructor function initializes an object with a key and an optional value.
     * @param {K} key - The "key" parameter is of type K, which represents the type of the key for the
     * constructor. It is used to set the key property of the object being created.
     * @param {V} [value] - The "value" parameter is an optional parameter of type V. It represents the
     * value associated with the key in the constructor.
     */
    constructor(key: K, value?: V);
    protected _left?: NODE | null;
    /**
     * The function returns the value of the `_left` property, which can be of type `NODE`, `null`, or
     * `undefined`.
     * @returns The left node of the current node is being returned. It can be either a NODE object,
     * null, or undefined.
     */
    get left(): NODE | null | undefined;
    /**
     * The function sets the left child of a node and updates its parent reference.
     * @param {NODE | null | undefined} v - The parameter `v` can be of type `NODE`, `null`, or
     * `undefined`.
     */
    set left(v: NODE | null | undefined);
    protected _right?: NODE | null;
    /**
     * The function returns the right node of a binary tree or null if it doesn't exist.
     * @returns The method is returning the value of the `_right` property, which can be a `NODE` object,
     * `null`, or `undefined`.
     */
    get right(): NODE | null | undefined;
    /**
     * The function sets the right child of a node and updates its parent.
     * @param {NODE | null | undefined} v - The parameter `v` can be of type `NODE`, `null`, or
     * `undefined`.
     */
    set right(v: NODE | null | undefined);
    /**
     * Get the position of the node within its family.
     * @returns {FamilyPosition} - The family position of the node.
     */
    get familyPosition(): FamilyPosition;
}
/**
 * 1. Two Children Maximum: Each node has at most two children.
 * 2. Left and Right Children: Nodes have distinct left and right children.
 * 3. Depth and Height: Depth is the number of edges from the root to a node; height is the maximum depth in the tree.
 * 4. Subtrees: Each child of a node forms the root of a subtree.
 * 5. Leaf Nodes: Nodes without children are leaves.
 */
export declare class BinaryTree<K = any, V = any, R = BTNEntry<K, V>, NODE extends BinaryTreeNode<K, V, NODE> = BinaryTreeNode<K, V, BinaryTreeNodeNested<K, V>>, TREE extends BinaryTree<K, V, R, NODE, TREE> = BinaryTree<K, V, R, NODE, BinaryTreeNested<K, V, R, NODE>>> extends IterableEntryBase<K, V | undefined> implements IBinaryTree<K, V, R, NODE, TREE> {
    iterationType: IterationType;
    /**
     * The constructor function initializes a binary tree object with optional keysOrNodesOrEntriesOrRawElements and options.
     * @param [keysOrNodesOrEntriesOrRawElements] - Optional iterable of KeyOrNodeOrEntry objects. These objects represent the
     * nodes to be added to the binary tree.
     * @param [options] - The `options` parameter is an optional object that can contain additional
     * configuration options for the binary tree. In this case, it is of type
     * `Partial<BinaryTreeOptions>`, which means that not all properties of `BinaryTreeOptions` are
     * required.
     */
    constructor(keysOrNodesOrEntriesOrRawElements?: Iterable<R | KeyOrNodeOrEntry<K, V, NODE>>, options?: BinaryTreeOptions<K, V, R>);
    protected _root?: NODE | null;
    /**
     * The function returns the root node, which can be of type NODE, null, or undefined.
     * @returns The method is returning the value of the `_root` property, which can be of type `NODE`,
     * `null`, or `undefined`.
     */
    get root(): NODE | null | undefined;
    protected _size: number;
    /**
     * The function returns the size of an object.
     * @returns The size of the object, which is a number.
     */
    get size(): number;
    protected _NIL: NODE;
    /**
     * The function returns the value of the _NIL property.
     * @returns The method is returning the value of the `_NIL` property.
     */
    get NIL(): NODE;
    protected _toEntryFn?: (rawElement: R) => BTNEntry<K, V>;
    /**
     * The function returns the value of the _toEntryFn property.
     * @returns The function being returned is `this._toEntryFn`.
     */
    get toEntryFn(): ((rawElement: R) => BTNEntry<K, V>) | undefined;
    /**
     * Creates a new instance of BinaryTreeNode with the given key and value.
     * @param {K} key - The key for the new node.
     * @param {V} value - The value for the new node.
     * @returns {NODE} - The newly created BinaryTreeNode.
     */
    createNode(key: K, value?: V): NODE;
    /**
     * The function creates a binary tree with the given options.
     * @param [options] - The `options` parameter is an optional object that allows you to customize the
     * behavior of the `BinaryTree` class. It is of type `Partial<BinaryTreeOptions>`, which means that
     * you can provide only a subset of the properties defined in the `BinaryTreeOptions` interface.
     * @returns a new instance of a binary tree.
     */
    createTree(options?: Partial<BinaryTreeOptions<K, V, R>>): TREE;
    /**
     * The function `keyValueOrEntryOrRawElementToNode` converts a key-value pair, entry, or raw element
     * into a node object.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {V} [value] - The `value` parameter is an optional value that can be passed to the
     * `keyValueOrEntryOrRawElementToNode` function. It represents the value associated with a key in a
     * key-value pair. If provided, it will be used to create a node with the specified key and value.
     * @returns The function `keyValueOrEntryOrRawElementToNode` returns either a `NODE` object, `null`,
     * or `undefined`.
     */
    keyValueOrEntryOrRawElementToNode(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>, value?: V): NODE | null | undefined;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `ensureNode` function checks if the input is a valid node and returns it, or converts it to a
     * node if it is a key or entry.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can accept a value of type `R`, `KeyOrNodeOrEntry<K, V, NODE>`, or
     * a raw element.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when searching for a node. It has a
     * default value of `'ITERATIVE'`.
     * @returns The function `ensureNode` returns either a `NODE` object, `null`, or `undefined`.
     */
    ensureNode(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    /**
     * The function checks if the input is an instance of the BinaryTreeNode class.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value indicating whether the input parameter `keyOrNodeOrEntryOrRawElement` is
     * an instance of the `BinaryTreeNode` class.
     */
    isNode(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>): keyOrNodeOrEntryOrRawElement is NODE;
    /**
     * The function checks if a given node is a valid node in a binary search tree.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isRealNode(node: R | KeyOrNodeOrEntry<K, V, NODE>): node is NODE;
    /**
     * The function checks if a given node is a real node or null.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isNodeOrNull(node: R | KeyOrNodeOrEntry<K, V, NODE>): node is NODE | null;
    /**
     * The function checks if a given node is equal to the NIL value.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} node - The parameter `node` can be of type `R` or
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isNIL(node: R | KeyOrNodeOrEntry<K, V, NODE>): boolean;
    /**
     * The function checks if the input is an array with two elements, indicating it is a binary tree
     * node entry.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The parameter
     * `keyOrNodeOrEntryOrRawElement` can be of type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @returns a boolean value.
     */
    isEntry(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>): keyOrNodeOrEntryOrRawElement is BTNEntry<K, V>;
    /**
     * The function checks if a given value is a valid key by evaluating its type and value.
     * @param {any} key - The `key` parameter can be of any type. It is the value that we want to check
     * if it is a valid key.
     * @param [isCheckValueOf=true] - The `isCheckValueOf` parameter is a boolean flag that determines
     * whether the function should check the valueOf() method of an object when the key is of type
     * 'object'. If `isCheckValueOf` is true, the function will recursively call itself with the value
     * returned by key.valueOf().
     * @returns a boolean value.
     */
    isKey(key: any, isCheckValueOf?: boolean): key is K;
    /**
     * Time Complexity O(n)
     * Space Complexity O(1)
     */
    /**
     * Time Complexity O(n)
     * Space Complexity O(1)
     *
     * The `add` function is used to insert a new node into a binary tree, checking for duplicate keys
     * and finding the appropriate insertion position.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} keyOrNodeOrEntryOrRawElement - The
     * `keyOrNodeOrEntryOrRawElement` parameter can accept a value of type `R`, which represents the key,
     * node, entry, or raw element to be added to the tree. It can also accept a value of type
     * `KeyOrNodeOrEntry<K, V, NODE>
     * @param {V} [value] - The `value` parameter is an optional value that can be associated with the
     * key being added to the tree. It represents the value that will be stored in the tree for the given
     * key.
     * @returns a boolean value. It returns `true` if the insertion is successful, and `false` if the
     * insertion position cannot be found or if there are duplicate keys.
     */
    add(keyOrNodeOrEntryOrRawElement: R | KeyOrNodeOrEntry<K, V, NODE>, value?: V): boolean;
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     * Comments: The time complexity for adding a node depends on the depth of the tree. In the best case (when the tree is empty), it's O(1). In the worst case (when the tree is a degenerate tree), it's O(n). The space complexity is constant.
     */
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     *
     * The `addMany` function takes in an iterable of keys or nodes or entries or raw elements, and an
     * optional iterable of values, and adds each key or node or entry with its corresponding value to a
     * data structure, returning an array of booleans indicating whether each insertion was successful.
     * @param keysOrNodesOrEntriesOrRawElements - An iterable containing keys, nodes, entries, or raw
     * elements. These elements will be added to the data structure.
     * @param [values] - An optional iterable of values that correspond to the keys or nodes or entries
     * in the `keysOrNodesOrEntriesOrRawElements` parameter.
     * @returns The function `addMany` returns an array of booleans indicating whether each element was
     * successfully added to the data structure.
     */
    addMany(keysOrNodesOrEntriesOrRawElements: Iterable<R | KeyOrNodeOrEntry<K, V, NODE>>, values?: Iterable<V | undefined>): boolean[];
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     * "n" is the number of nodes in the tree, and "k" is the number of keys to be inserted.
     */
    /**
     * Time Complexity: O(k * n)
     * Space Complexity: O(1)
     *
     * The `refill` function clears the current data and adds new data to the collection.
     * @param keysOrNodesOrEntriesOrRawElements - An iterable collection of keys, nodes, entries, or raw
     * elements. These can be of any type (R) or a specific type (KeyOrNodeOrEntry<K, V, NODE>).
     * @param [values] - The `values` parameter is an optional iterable of values that will be associated
     * with the keys or nodes being added. If provided, the values will be assigned to the corresponding
     * keys or nodes. If not provided, the values will be set to `undefined`.
     */
    refill(keysOrNodesOrEntriesOrRawElements: Iterable<R | KeyOrNodeOrEntry<K, V, NODE>>, values?: Iterable<V | undefined>): void;
    delete<C extends BTNCallback<NODE, K>>(identifier: K, callback?: C): BinaryTreeDeleteResult<NODE>[];
    delete<C extends BTNCallback<NODE, NODE>>(identifier: NODE | null | undefined, callback?: C): BinaryTreeDeleteResult<NODE>[];
    delete<C extends BTNCallback<NODE>>(identifier: ReturnType<C>, callback: C): BinaryTreeDeleteResult<NODE>[];
    getNodes<C extends BTNCallback<NODE, K>>(identifier: K, callback?: C, onlyOne?: boolean, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE[];
    getNodes<C extends BTNCallback<NODE, NODE>>(identifier: NODE | null | undefined, callback?: C, onlyOne?: boolean, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE[];
    getNodes<C extends BTNCallback<NODE>>(identifier: ReturnType<C>, callback: C, onlyOne?: boolean, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE[];
    getNode<C extends BTNCallback<NODE, K>>(identifier: K, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    getNode<C extends BTNCallback<NODE, NODE>>(identifier: NODE | null | undefined, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    getNode<C extends BTNCallback<NODE>>(identifier: ReturnType<C>, callback: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function `getNodeByKey` returns a node with a specific key value from a tree structure.
     * @param {K} key - The key parameter is the value that you want to search for in the tree. It is
     * used to find the node with the matching key value.
     * @param {IterationType} [iterationType=ITERATIVE] - The `iterationType` parameter is an optional
     * parameter that specifies the type of iteration to be used when searching for a node in the tree.
     * It has a default value of `'ITERATIVE'`.
     * @returns a value of type NODE, null, or undefined.
     */
    getNodeByKey(key: K, iterationType?: IterationType): NODE | null | undefined;
    get<C extends BTNCallback<NODE, K>>(identifier: K, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): V | undefined;
    get<C extends BTNCallback<NODE, NODE>>(identifier: NODE | null | undefined, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): V | undefined;
    get<C extends BTNCallback<NODE>>(identifier: ReturnType<C>, callback: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): V | undefined;
    has<C extends BTNCallback<NODE, K>>(identifier: K, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): boolean;
    has<C extends BTNCallback<NODE, NODE>>(identifier: NODE | null | undefined, callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): boolean;
    has<C extends BTNCallback<NODE>>(identifier: ReturnType<C> | null | undefined, callback: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): boolean;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Clear the binary tree, removing all nodes.
     */
    clear(): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * Check if the binary tree is empty.
     * @returns {boolean} - True if the binary tree is empty, false otherwise.
     */
    isEmpty(): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The function checks if a binary tree is perfectly balanced by comparing the minimum height and the
     * height of the tree.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The parameter `beginRoot` is optional and
     * has a default value of `this.root`. It represents the starting point for checking if the tree is
     * perfectly balanced. It can be either a root node (`R`), a key or node or entry
     * (`KeyOrNodeOrEntry<K, V, NODE
     * @returns a boolean value.
     */
    isPerfectlyBalanced(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function `isBST` checks if a binary search tree is valid, either recursively or iteratively.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for checking if a binary search tree (BST) is valid. It can be either a root node
     * of the BST, a key value of a node in the BST, or an entry object containing both the key and value
     * of a node in the BST
     * @param {IterationType} iterationType - The `iterationType` parameter is used to determine the type
     * of iteration to be performed while checking if the binary search tree (BST) is valid. It can have
     * two possible values:
     * @returns a boolean value.
     */
    isBST(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): boolean;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The function calculates the depth of a given node or key in a tree-like data structure.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} dist - The `dist` parameter can be either a `R`
     * (representing a root node), or a `KeyOrNodeOrEntry<K, V, NODE>` (representing a key, node, or
     * entry).
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is optional and
     * represents the starting point from which to calculate the depth. It can be either a reference to a
     * node in the tree or a key-value pair or an entry object. If not provided, the default value is
     * `this.root`, which refers to the root node
     * @returns the depth of a node in a tree structure.
     */
    getDepth(dist: R | KeyOrNodeOrEntry<K, V, NODE>, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>): number;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(1)
     *
     * The `getHeight` function calculates the maximum height of a binary tree using either a recursive
     * or iterative approach.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for calculating the height of a tree. It can be either a root node (`R`), a key or
     * node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or it defaults to the root of the current tree.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration used to calculate the height of the tree. It can have two possible values:
     * @returns the maximum height of the binary tree.
     */
    getHeight(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): number;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(log n)
     *
     * The `getMinHeight` function calculates the minimum height of a binary tree using either a
     * recursive or iterative approach.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for calculating the minimum height of a tree. It can be either a root node (`R`), a
     * key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or it defaults to the root of the current
     * tree.
     * @param {IterationType} iterationType - The `iterationType` parameter determines the type of
     * iteration to be used when calculating the minimum height of the tree. It can have two possible
     * values:
     * @returns The function `getMinHeight` returns a number, which represents the minimum height of the
     * binary tree.
     */
    getMinHeight(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): number;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(log n)
     *
     * The function `getPathToRoot` returns an array of nodes starting from a given node and traversing
     * up to the root node, with an option to reverse the order of the nodes.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginNode - The `beginNode` parameter can be either of
     * type `R` or `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param [isReverse=true] - The `isReverse` parameter is a boolean flag that determines whether the
     * resulting path should be reversed or not. If `isReverse` is set to `true`, the path will be
     * reversed before returning it. If `isReverse` is set to `false` or not provided, the path will
     * @returns The function `getPathToRoot` returns an array of `NODE` objects.
     */
    getPathToRoot(beginNode: R | KeyOrNodeOrEntry<K, V, NODE>, isReverse?: boolean): NODE[];
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `getLeftMost` function returns the leftmost node in a binary tree, either using recursive or
     * iterative traversal.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for finding the leftmost node in a binary tree. It can be either a root node (`R`),
     * a key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or `null` or `undefined`.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed. It can have two possible values:
     * @returns The function `getLeftMost` returns the leftmost node in a binary tree.
     */
    getLeftMost(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The `getRightMost` function returns the rightmost node in a binary tree, either recursively or
     * iteratively.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter represents the
     * starting point for finding the rightmost node in a binary tree. It can be either a root node
     * (`R`), a key or node or entry (`KeyOrNodeOrEntry<K, V, NODE>`), or `null` or `undefined`.
     * @param {IterationType} iterationType - The `iterationType` parameter is used to specify the type
     * of iteration to be performed when finding the rightmost node in a binary tree. It can have two
     * possible values:
     * @returns The function `getRightMost` returns a NODE object, `null`, or `undefined`.
     */
    getRightMost(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType): NODE | null | undefined;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function returns the predecessor node of a given node in a binary tree.
     * @param {NODE} node - The parameter "node" is of type "NODE", which represents a node in a binary
     * tree.
     * @returns the predecessor node of the given node.
     */
    getPredecessor(node: NODE): NODE;
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(log n)
     * Space Complexity: O(1)
     *
     * The function `getSuccessor` returns the next node in a binary tree given a current node.
     * @param {K | NODE | null} [x] - The parameter `x` can be of type `K`, `NODE`, or `null`.
     * @returns The function `getSuccessor` returns a `NODE` object if a successor exists, `null` if
     * there is no successor, and `undefined` if the input `x` is not a valid node.
     */
    getSuccessor(x?: K | NODE | null): NODE | null | undefined;
    dfs<C extends BTNCallback<NODE>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[];
    dfs<C extends BTNCallback<NODE | null>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[];
    bfs<C extends BTNCallback<NODE>>(callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[];
    bfs<C extends BTNCallback<NODE | null>>(callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[];
    listLevels<C extends BTNCallback<NODE>>(callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: false): ReturnType<C>[][];
    listLevels<C extends BTNCallback<NODE | null>>(callback?: C, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, iterationType?: IterationType, includeNull?: true): ReturnType<C>[][];
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `morris` function performs a depth-first traversal on a binary tree using the Morris traversal
     * algorithm.
     * @param {C} callback - The `callback` parameter is a function that will be called for each node in
     * the tree. It takes a single argument, which is the current node, and can return any value. The
     * return type of the `callback` function is determined by the `ReturnType<C>` type, which represents
     * the return
     * @param {DFSOrderPattern} [pattern=IN] - The `pattern` parameter in the `morris` function is used
     * to specify the order in which the nodes of a binary tree are traversed. It can take one of the
     * following values:
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for the traversal. It can be either a node object, a key, or an entry object. If no value is
     * provided, the `root` of the tree is used as the starting point.
     * @returns The function `morris` returns an array of values that are the return values of the
     * callback function `callback`.
     */
    morris<C extends BTNCallback<NODE>>(callback?: C, pattern?: DFSOrderPattern, beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>): ReturnType<C>[];
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     */
    /**
     * Time complexity: O(n)
     * Space complexity: O(n)
     *
     * The `clone` function creates a deep copy of a tree object.
     * @returns The `clone()` method is returning a cloned instance of the `TREE` object.
     */
    clone(): TREE;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `filter` function creates a new tree with entries that pass a given predicate function.
     * @param predicate - The `predicate` parameter is a callback function that is used to test each
     * element in the tree. It takes three arguments: `value`, `key`, and `index`. The `value` argument
     * represents the value of the current element being processed, the `key` argument represents the key
     * of the
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that allows you to
     * specify the value of `this` within the `predicate` function. When the `predicate` function is
     * called, `thisArg` will be used as the value of `this` within the function. If `thisArg`
     * @returns The `filter` method is returning a new tree object that contains the entries that pass
     * the given predicate function.
     */
    filter(predicate: EntryCallback<K, V | undefined, boolean>, thisArg?: any): TREE;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `map` function creates a new tree by applying a callback function to each entry in the current
     * tree.
     * @param callback - The callback parameter is a function that will be called for each entry in the
     * tree. It takes three arguments: value, key, and index. The value argument represents the value of
     * the current entry, the key argument represents the key of the current entry, and the index
     * argument represents the index of the
     * @param {any} [thisArg] - The `thisArg` parameter is an optional argument that specifies the value
     * to be used as `this` when executing the `callback` function. If `thisArg` is provided, it will be
     * passed as the `this` value to the `callback` function. If `thisArg` is
     * @returns The `map` method is returning a new tree object.
     */
    map(callback: EntryCallback<K, V | undefined, V>, thisArg?: any): TREE;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `print` function in TypeScript prints the binary tree structure with customizable options.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} beginRoot - The `beginRoot` parameter is the starting
     * point for printing the binary tree. It can be either a node of the binary tree or a key or entry
     * that exists in the binary tree. If no value is provided, the root of the binary tree will be used
     * as the starting point.
     * @param {BinaryTreePrintOptions} [options] - The `options` parameter is an optional object that
     * allows you to customize the printing behavior. It has the following properties:
     * @returns Nothing is being returned. The function has a return type of `void`, which means it does
     * not return any value.
     */
    print(beginRoot?: R | KeyOrNodeOrEntry<K, V, NODE>, options?: BinaryTreePrintOptions): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_getIterator` is a generator function that returns an iterator for the key-value
     * pairs in a binary search tree.
     * @param node - The `node` parameter represents the current node in the binary search tree. It is
     * initially set to the root node of the tree.
     * @returns an IterableIterator<[K, V | undefined]>.
     */
    protected _getIterator(node?: NODE | null | undefined): IterableIterator<[K, V | undefined]>;
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     */
    /**
     * Time Complexity: O(n)
     * Space Complexity: O(n)
     *
     * The `_displayAux` function is responsible for generating the display layout of a binary tree node,
     * taking into account various options such as whether to show null, undefined, or NaN nodes.
     * @param {NODE | null | undefined} node - The `node` parameter represents a node in a binary tree.
     * It can be of type `NODE`, `null`, or `undefined`.
     * @param {BinaryTreePrintOptions} options - The `options` parameter is an object that contains the
     * following properties:
     * @returns The function `_displayAux` returns a `NodeDisplayLayout` which is an array containing the
     * following elements:
     * 1. `mergedLines`: An array of strings representing the lines of the node display.
     * 2. `totalWidth`: The total width of the node display.
     * 3. `totalHeight`: The total height of the node display.
     * 4. `middleIndex`: The index of the middle character
     */
    protected _displayAux(node: NODE | null | undefined, options: BinaryTreePrintOptions): NodeDisplayLayout;
    protected _DEFAULT_CALLBACK: (node: NODE | null | undefined) => K | undefined;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_swapProperties` swaps the key-value properties between two nodes.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} srcNode - The source node that will be swapped with the
     * destination node. It can be either an instance of the class `R`, or an object of type
     * `KeyOrNodeOrEntry<K, V, NODE>`.
     * @param {R | KeyOrNodeOrEntry<K, V, NODE>} destNode - The `destNode` parameter is the node where
     * the properties will be swapped with the `srcNode`.
     * @returns either the `destNode` object with its properties swapped with the `srcNode` object's
     * properties, or `undefined` if either `srcNode` or `destNode` is falsy.
     */
    protected _swapProperties(srcNode: R | KeyOrNodeOrEntry<K, V, NODE>, destNode: R | KeyOrNodeOrEntry<K, V, NODE>): NODE | undefined;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function replaces a node in a binary tree with a new node, updating the parent, left child,
     * right child, and root if necessary.
     * @param {NODE} oldNode - The oldNode parameter represents the node that needs to be replaced in the
     * tree.
     * @param {NODE} newNode - The `newNode` parameter is the node that will replace the `oldNode` in the
     * tree.
     * @returns the newNode.
     */
    protected _replaceNode(oldNode: NODE, newNode: NODE): NODE;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function sets the root property of an object to the provided value, and also updates the
     * parent property of the new root.
     * @param {NODE | null | undefined} v - The parameter `v` is of type `NODE | null | undefined`. This
     * means that it can accept a value of type `NODE`, `null`, or `undefined`.
     */
    protected _setRoot(v: NODE | null | undefined): void;
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     */
    /**
     * Time Complexity: O(1)
     * Space Complexity: O(1)
     *
     * The function `_ensureCallback` ensures that a callback function is provided and returns it.
     * @param {ReturnType<C> | null | undefined} identifier - The `identifier` parameter is of type
     * `ReturnType<C> | null | undefined`. This means it can accept a value that is the return type of
     * the generic type `C`, or it can be `null` or `undefined`.
     * @param {C} callback - The `callback` parameter is a function that takes a `node` as an argument
     * and returns a value. It is of type `C`, which is a generic type that extends the
     * `BTNCallback<NODE>` type.
     * @returns the callback parameter.
     */
    protected _ensureCallback<C extends BTNCallback<NODE>>(identifier: ReturnType<C> | null | undefined, callback?: C): C;
}
