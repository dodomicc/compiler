開場
你有没有想过，排序这种看起来本质上是“串行”的操作，是怎么在 GPU 上实现并行的？
今天，我们就来一起看看 Bitonic Sort，一种非常适合 GPU 并行实现的排序算法。


Part 1
Bitonic 序列定義
先來看看什么是 Bitonic 序列吧。它就是一种“先上升后下降””的序列。你可以把它想成一个山峰的形状。
现在，我们来看看例子：
这個數組 [2, 5, 8, 12, 10, 7, 3]，明显就是先往上爬到12，然后一路滑下来，这就是标准的 Bitonic 序列。
但是呢，这個數組 [3, 7, 5, 9, 2]，明显不符合，因为它忽上忽下，没有形成一个清晰的山峰。
現在討論第一部分，怎麼把兩個單調數列，組合成一個 Bitonic 序列？
假設現在我們有兩段數列：
上方是一段單調遞增的數列，
下方是一段單調遞減的數列。
那麼，怎麼把這兩段數列結合起來，構造出一個 Bitonic 結構呢？
這裡有一個很簡潔的方法：我們對這兩段數列進行對偶位置的比較與交換。
什麼是對偶位置？
就是上面第 0 個對應下面最後一個，
上面第 1 個對應下面倒數第二個，
依此類推，從兩端向中間配對。
然後，我們對每一對對偶元素進行比較：
把較大的數放到上面，較小的數放到下面。
我們以第一個對偶元素對為例，因為第一個數列的第一個元素1小于第二個數列的最後一個元素2，所以交換這兩個元素，然後再類似的交換其他的對偶元素
這樣交換完成之後，會出現兩個非常重要的特性：
上方的數列仍然是單調遞增的，而且每一個元素都大於或等於下方任何一個元素；
下方的數列仍然是單調遞減的，而且每一個元素都小於或等於上方任何一個元素。
最後一步，我們只需要把這兩個數列从左到右拼接起來，就得到了一個Bitonic 序列：

Part 2
Bitonic 序列排序
為了解決怎麼把 Bitonic 序列排序的問題，我們先來介紹一個重要的理論——Batcher 定理。
Batcher 定理告訴我們，對一個 Bitonic 序列，可以通過一系列固定的比較交換操作，把它排序成一個單調序列。
是不是感覺有點抽象、有點一頭霧水？別擔心，現在我們用一個包含 8 個元素的 Bitonic 序列例子，來一步步說明這個過程。
假設我們有這樣一個長度為8的 Bitonic 序列：
[15, 23, 12, 10, 9, 6, 4, 1]
現在，我們對相鄰對應位置的元素進行比較交換：什麼是相鄰位置呢，在這裏，數組，縱長為8，如果兩個元素下標相差為8/2 = 4，就認為他們相鄰
第一步，把第0個和第4個元素比較，把較小的放在原來的第0個位置，較大的放原來的第4個位置；
把第1個和第5個元素比較，較小的放在原來的第一個位置，較大的放在原來的第五個位置
第2個和第6個，第3個和第7個也同樣比較交換。
經過這一步，我們得到了兩個長度為4的序列：
[9, 6, 4, 1] 和 [15, 23, 12, 10]
你是不是注意到，前4個元素全都小於後4個元素，而且前半部分和後半部分本身還是 Bitonic 序列？
這就是 Batch定理背後的玄機。剛剛這個過程就被稱為Batcher merge
現在可以通過一個樹狀圖來理解Batcher merge是如何讓一個 Bitonic序列變的有序，首先注意到第一列只有一個bitonic序列，長度為8
經過一次Batcher merge以後，裂變為第二列的兩個長度為4的bitonic序列，對於第二列的兩個bitonic序列，分別進行Batcher merge
操作，裂變為第三列的4個bitonic子序列，然後每個子序列長度為2，並且上方的子序列中的元素小于下方子序列的元素，可以注意到此時再
讓第3列的每個子序列變為升序，整個序列就變為升序，這就是Bitonic 序列排序的全過程

Part 3 
任意長度為2^k的數組排序
好，前面我們已經得到了兩個重要的結論：
結論一：一個單調遞增的數列，加上一個單調遞減的數列，可以組合成一個 Bitonic 序列；
結論二：一個 Bitonic 序列，可以通過一系列 Batcher Merge 操作，變成單調遞增或單調遞減的序列。
那麼，問題來了：
我們能不能把這兩個結論結合起來，
用來排序任意長度為 2 的冪次的數組呢？答案是——完全可以。
接下來我用一個長度為 8 的數組來形象地說明 Bitonic Sort 到底是如何應用在任意數組排序上的：
考慮一個長度為 8 的數組，
第一次，我們把它拆成四個子數組：遞增、遞減、遞增、遞減；
然後，這四個數組可以兩兩組合成兩個 Bitonic 數組；
這兩個 Bitonic 數組又可以排序，變成兩個單調的子數組；
然後，這兩個單調子數組又可以組合成一個更大的 Bitonic 數組；
最後，再對這個 Bitonic 數組進行排序，就可以得到整體升序的結果。
這個算法一路走下來，我們可以觀察到：
每一步當中，每個元素的比較與交換都是獨立進行的，
這正是這個算法為什麼如此適合 GPU 並行計算的原因。

